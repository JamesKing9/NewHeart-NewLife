

## 13.6 Compound-Statement Syntax

This section describes the syntax for the    [`BEGIN ... END`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#begin-end)    compound statement and other statements that can be used in the body    of stored programs: Stored procedures and functions, triggers, and    events. These objects are defined in terms of SQL code that is    stored on the server for later invocation (see    [Chapter 20, *Stored Programs and Views*](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/stored-programs-views.html)).  

​    A compound statement is a block that can contain other blocks;    declarations for variables, condition handlers, and cursors; and    flow control constructs such as loops and conditional tests.

### 13.6.1 BEGIN ... END Compound-Statement Syntax

```
[begin_label:] BEGIN
    [statement_list]
END [end_label]

```

​      [`BEGIN ... END`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#begin-end)      syntax is used for writing compound statements, which can appear      within stored programs (stored procedures and functions, triggers,      and events). A compound statement can contain multiple statements,      enclosed by the `BEGIN` and      `END` keywords.      *statement_list* represents a list of one      or more statements, each terminated by a semicolon      (`;`) statement delimiter. The      *statement_list* itself is optional, so      the empty compound statement (`BEGIN END`) is      legal.    

​      [`BEGIN ... END`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#begin-end)      blocks can be nested.    

​      Use of multiple statements requires that a client is able to send      statement strings containing the `;` statement      delimiter. In the [**mysql**](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/programs.html#mysql) command-line client,      this is handled with the `delimiter` command.      Changing the `;` end-of-statement delimiter (for      example, to `//`) permit `;` to      be used in a program body. For an example, see      [Section 20.1, “Defining Stored Programs”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/stored-programs-views.html#stored-programs-defining).    

​      A [`BEGIN ...      END`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#begin-end) block can be labeled. See      [Section 13.6.2, “Statement Label Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#statement-labels).    

​      The optional `[NOT] ATOMIC` clause is not      supported. This means that no transactional savepoint is set at      the start of the instruction block and the      `BEGIN` clause used in this context has no effect      on the current transaction.

Note

​        Within all stored programs, the parser treats        [`BEGIN [WORK\]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit)        as the beginning of a        [`BEGIN ...        END`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#begin-end) block. To begin a transaction in this context, use        [`START        TRANSACTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit) instead.

### 13.6.2 Statement Label Syntax

```
[begin_label:] BEGIN
    [statement_list]
END [end_label]

[begin_label:] LOOP
    statement_list
END LOOP [end_label]

[begin_label:] REPEAT
    statement_list
UNTIL search_condition
END REPEAT [end_label]

[begin_label:] WHILE search_condition DO
    statement_list
END WHILE [end_label]

```

​      Labels are permitted for      [`BEGIN ... END`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#begin-end)      blocks and for the [`LOOP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#loop),      [`REPEAT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#repeat), and      [`WHILE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#while) statements. Label use for      those statements follows these rules:

- ​          *begin_label* must be followed by a          colon.        
- ​          *begin_label* can be given without          *end_label*. If          *end_label* is present, it must be          the same as *begin_label*.        
- ​          *end_label* cannot be given without          *begin_label*.        
- ​          Labels at the same nesting level must be distinct.        
- ​          Labels can be up to 16 characters long.

​      To refer to a label within the labeled construct, use an      [`ITERATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#iterate) or      [`LEAVE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#leave) statement. The following      example uses those statements to continue iterating or terminate      the loop:    

```
CREATE PROCEDURE doiterate(p1 INT)
BEGIN
  label1: LOOP
    SET p1 = p1 + 1;
    IF p1 < 10 THEN ITERATE label1; END IF;
    LEAVE label1;
  END LOOP label1;
END;

```

​      The scope of a block label does not include the code for handlers      declared within the block. For details, see      [Section 13.6.7.2, “DECLARE ... HANDLER Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare-handler).

### 13.6.3 DECLARE Syntax

​      The [`DECLARE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare) statement is used to      define various items local to a program:

- ​          Local variables. See          [Section 13.6.4, “Variables in Stored Programs”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#stored-program-variables).        
- ​          Conditions and handlers. See          [Section 13.6.7, “Condition Handling”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#condition-handling).        
- ​          Cursors. See [Section 13.6.6, “Cursors”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#cursors).

​      [`DECLARE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare) is permitted only inside a      [`BEGIN ... END`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#begin-end)      compound statement and must be at its start, before any other      statements.    

​      Declarations must follow a certain order. Cursor declarations must      appear before handler declarations. Variable and condition      declarations must appear before cursor or handler declarations.

### 13.6.4 Variables in Stored Programs

- [13.6.4.1 Local Variable DECLARE Syntax](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare-local-variable)
- [13.6.4.2 Local Variable Scope and Resolution](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#local-variable-scope)

​      System variables and user-defined variables can be used in stored      programs, just as they can be used outside stored-program context.      In addition, stored programs can use `DECLARE` to      define local variables, and stored routines (procedures and      functions) can be declared to take parameters that communicate      values between the routine and its caller.

- ​          To declare local variables, use the          [`DECLARE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare-local-variable)          statement, as described in          [Section 13.6.4.1, “Local Variable DECLARE Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare-local-variable).        
- ​          Variables can be set directly with the          [`SET`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#set-variable)          statement. See [Section 13.7.4.1, “SET Syntax for Variable Assignment”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#set-variable).        
- ​          Results from queries can be retrieved into local variables          using [`SELECT ...          INTO *var_list*`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select-into) or by          opening a cursor and using          [`FETCH ... INTO          *var_list*`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#fetch). See          [Section 13.2.9.1, “SELECT ... INTO Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select-into), and [Section 13.6.6, “Cursors”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#cursors).

​      For information about the scope of local variables and how MySQL      resolves ambiguous names, see      [Section 13.6.4.2, “Local Variable Scope and Resolution”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#local-variable-scope).

#### 13.6.4.1 Local Variable DECLARE Syntax

```
DECLARE var_name [, var_name] ... type [DEFAULT value]

```

​        This statement declares local variables within stored programs.        To provide a default value for a variable, include a        `DEFAULT` clause. The value can be specified as        an expression; it need not be a constant. If the        `DEFAULT` clause is missing, the initial value        is `NULL`.      

​        Local variables are treated like stored routine parameters with        respect to data type and overflow checking. See        [Section 13.1.15, “CREATE PROCEDURE and CREATE FUNCTION Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-procedure).      

​        Variable declarations must appear before cursor or handler        declarations.      

​        Local variable names are not case sensitive. Permissible        characters and quoting rules are the same as for other        identifiers, as described in [Section 9.2, “Schema Object Names”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/language-structure.html#identifiers).      

​        The scope of a local variable is the        [`BEGIN ...        END`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#begin-end) block within which it is declared. The variable        can be referred to in blocks nested within the declaring block,        except those blocks that declare a variable with the same name.      

​        For examples of variable declarations, see        [Section 13.6.4.2, “Local Variable Scope and Resolution”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#local-variable-scope).

#### 13.6.4.2 Local Variable Scope and Resolution

​        The scope of a local variable is the        [`BEGIN ...        END`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#begin-end) block within which it is declared. The variable        can be referred to in blocks nested within the declaring block,        except those blocks that declare a variable with the same name.      

​        Because local variables are in scope only during stored program        execution, references to them are not permitted in prepared        statements created within a stored program. Prepared statement        scope is the current session, not the stored program, so the        statement could be executed after the program ends, at which        point the variables would no longer be in scope. For example,        `SELECT ... INTO        *local_var*` cannot be used as        a prepared statement. This restriction also applies to stored        procedure and function parameters. See        [Section 13.5.1, “PREPARE Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#prepare).      

​        A local variable should not have the same name as a table        column. If an SQL statement, such as a        [`SELECT ...        INTO`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement, contains a reference to a column and a        declared local variable with the same name, MySQL currently        interprets the reference as the name of a variable. Consider the        following procedure definition:      

```
CREATE PROCEDURE sp1 (x VARCHAR(5))
BEGIN
  DECLARE xname VARCHAR(5) DEFAULT 'bob';
  DECLARE newname VARCHAR(5);
  DECLARE xid INT;

  SELECT xname, id INTO newname, xid
    FROM table1 WHERE xname = xname;
  SELECT newname;
END;

```

​        MySQL interprets `xname` in the        [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement as a reference        to the `xname` *variable*        rather than the `xname`        *column*. Consequently, when the procedure        `sp1()`is called, the        `newname` variable returns the value        `'bob'` regardless of the value of the        `table1.xname` column.      

​        Similarly, the cursor definition in the following procedure        contains a [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement that        refers to `xname`. MySQL interprets this as a        reference to the variable of that name rather than a column        reference.      

```
CREATE PROCEDURE sp2 (x VARCHAR(5))
BEGIN
  DECLARE xname VARCHAR(5) DEFAULT 'bob';
  DECLARE newname VARCHAR(5);
  DECLARE xid INT;
  DECLARE done TINYINT DEFAULT 0;
  DECLARE cur1 CURSOR FOR SELECT xname, id FROM table1;
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

  OPEN cur1;
  read_loop: LOOP
    FETCH FROM cur1 INTO newname, xid;
    IF done THEN LEAVE read_loop; END IF;
    SELECT newname;
  END LOOP;
  CLOSE cur1;
END;

```

​        See also [Section C.1, “Restrictions on Stored Programs”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/restrictions.html#stored-program-restrictions).

### 13.6.5 Flow Control Statements

- [13.6.5.1 CASE Syntax](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#case)
- [13.6.5.2 IF Syntax](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#if)
- [13.6.5.3 ITERATE Syntax](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#iterate)
- [13.6.5.4 LEAVE Syntax](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#leave)
- [13.6.5.5 LOOP Syntax](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#loop)
- [13.6.5.6 REPEAT Syntax](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#repeat)
- [13.6.5.7 RETURN Syntax](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#return)
- [13.6.5.8 WHILE Syntax](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#while)

​      MySQL supports the [`IF`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#if),      [`CASE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#case),      [`ITERATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#iterate),      [`LEAVE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#leave)      [`LOOP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#loop),      [`WHILE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#while), and      [`REPEAT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#repeat) constructs for flow control      within stored programs. It also supports      [`RETURN`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#return) within stored functions.    

​      Many of these constructs contain other statements, as indicated by      the grammar specifications in the following sections. Such      constructs may be nested. For example, an      [`IF`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#if) statement might contain a      [`WHILE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#while) loop, which itself contains a      [`CASE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#case) statement.    

​      MySQL does not support `FOR` loops.

#### 13.6.5.1 CASE Syntax

```
CASE case_value
    WHEN when_value THEN statement_list
    [WHEN when_value THEN statement_list] ...
    [ELSE statement_list]
END CASE

```

​        Or:      

```
CASE
    WHEN search_condition THEN statement_list
    [WHEN search_condition THEN statement_list] ...
    [ELSE statement_list]
END CASE

```

​        The [`CASE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#case) statement for stored        programs implements a complex conditional construct.

Note

​          There is also a [`CASE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#operator_case)          *expression*, which differs from the          [`CASE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#case)          *statement* described here. See          [Section 12.4, “Control Flow Functions”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#control-flow-functions). The          [`CASE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#case) statement cannot have an          `ELSE NULL` clause, and it is terminated with          `END CASE` instead of `END`.

​        For the first syntax, *case_value* is        an expression. This value is compared to the        *when_value* expression in each        `WHEN` clause until one of them is equal. When        an equal *when_value* is found, the        corresponding `THEN` clause        *statement_list* executes. If no        *when_value* is equal, the        `ELSE` clause        *statement_list* executes, if there is        one.      

​        This syntax cannot be used to test for equality with        `NULL` because `NULL = NULL`        is false. See [Section 3.3.4.6, “Working with NULL Values”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/tutorial.html#working-with-null).      

​        For the second syntax, each `WHEN` clause        *search_condition* expression is        evaluated until one is true, at which point its corresponding        `THEN` clause        *statement_list* executes. If no        *search_condition* is equal, the        `ELSE` clause        *statement_list* executes, if there is        one.      

​        If no *when_value* or        *search_condition* matches the value        tested and the [`CASE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#case) statement        contains no `ELSE` clause, a Case        not found for CASE statement error results.      

​        Each *statement_list* consists of one        or more SQL statements; an empty        *statement_list* is not permitted.      

​        To handle situations where no value is matched by any        `WHEN` clause, use an `ELSE`        containing an empty        [`BEGIN ...        END`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#begin-end) block, as shown in this example. (The indentation        used here in the `ELSE` clause is for purposes        of clarity only, and is not otherwise significant.)      

```
DELIMITER |

CREATE PROCEDURE p()
  BEGIN
    DECLARE v INT DEFAULT 1;

    CASE v
      WHEN 2 THEN SELECT v;
      WHEN 3 THEN SELECT 0;
      ELSE
        BEGIN
        END;
    END CASE;
  END;
  |

```

#### 13.6.5.2 IF Syntax

```
IF search_condition THEN statement_list
    [ELSEIF search_condition THEN statement_list] ...
    [ELSE statement_list]
END IF

```

​        The [`IF`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#if) statement for stored        programs implements a basic conditional construct.

Note

​          There is also an [`IF()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_if)          *function*, which differs from the          [`IF`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#if)          *statement* described here. See          [Section 12.4, “Control Flow Functions”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#control-flow-functions). The          [`IF`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#if) statement can have          `THEN`, `ELSE`, and          `ELSEIF` clauses, and it is terminated with          `END IF`.

​        If the *search_condition* evaluates to        true, the corresponding `THEN` or        `ELSEIF` clause        *statement_list* executes. If no        *search_condition* matches, the        `ELSE` clause        *statement_list* executes.      

​        Each *statement_list* consists of one        or more SQL statements; an empty        *statement_list* is not permitted.      

​        An `IF ... END IF` block, like all other        flow-control blocks used within stored programs, must be        terminated with a semicolon, as shown in this example:      

```
DELIMITER //

CREATE FUNCTION SimpleCompare(n INT, m INT)
  RETURNS VARCHAR(20)

  BEGIN
    DECLARE s VARCHAR(20);

    IF n > m THEN SET s = '>';
    ELSEIF n = m THEN SET s = '=';
    ELSE SET s = '<';
    END IF;

    SET s = CONCAT(n, ' ', s, ' ', m);

    RETURN s;
  END //

DELIMITER ;

```

​        As with other flow-control constructs, `IF ... END        IF` blocks may be nested within other flow-control        constructs, including other [`IF`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#if)        statements. Each [`IF`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#if) must be        terminated by its own `END IF` followed by a        semicolon. You can use indentation to make nested flow-control        blocks more easily readable by humans (although this is not        required by MySQL), as shown here:      

```
DELIMITER //

CREATE FUNCTION VerboseCompare (n INT, m INT)
  RETURNS VARCHAR(50)

  BEGIN
    DECLARE s VARCHAR(50);

    IF n = m THEN SET s = 'equals';
    ELSE
      IF n > m THEN SET s = 'greater';
      ELSE SET s = 'less';
      END IF;

      SET s = CONCAT('is ', s, ' than');
    END IF;

    SET s = CONCAT(n, ' ', s, ' ', m, '.');

    RETURN s;
  END //

DELIMITER ;

```

​        In this example, the inner [`IF`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#if) is        evaluated only if `n` is not equal to        `m`.

#### 13.6.5.3 ITERATE Syntax

```
ITERATE label

```

​        [`ITERATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#iterate) can appear only within        [`LOOP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#loop),        [`REPEAT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#repeat), and        [`WHILE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#while) statements.        [`ITERATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#iterate) means “start the        loop again.”      

​        For an example, see [Section 13.6.5.5, “LOOP Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#loop).

#### 13.6.5.4 LEAVE Syntax

```
LEAVE label

```

​        This statement is used to exit the flow control construct that        has the given label. If the label is for the outermost stored        program block, [`LEAVE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#leave) exits the        program.      

​        [`LEAVE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#leave) can be used within        [`BEGIN ...        END`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#begin-end) or loop constructs        ([`LOOP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#loop),        [`REPEAT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#repeat),        [`WHILE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#while)).      

​        For an example, see [Section 13.6.5.5, “LOOP Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#loop).

#### 13.6.5.5 LOOP Syntax

```
[begin_label:] LOOP
    statement_list
END LOOP [end_label]

```

​        [`LOOP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#loop) implements a simple loop        construct, enabling repeated execution of the statement list,        which consists of one or more statements, each terminated by a        semicolon (`;`) statement delimiter. The        statements within the loop are repeated until the loop is        terminated. Usually, this is accomplished with a        [`LEAVE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#leave) statement. Within a stored        function, [`RETURN`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#return) can also be        used, which exits the function entirely.      

​        Neglecting to include a loop-termination statement results in an        infinite loop.      

​        A [`LOOP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#loop) statement can be labeled.        For the rules regarding label use, see        [Section 13.6.2, “Statement Label Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#statement-labels).      

​        Example:      

```
CREATE PROCEDURE doiterate(p1 INT)
BEGIN
  label1: LOOP
    SET p1 = p1 + 1;
    IF p1 < 10 THEN
      ITERATE label1;
    END IF;
    LEAVE label1;
  END LOOP label1;
  SET @x = p1;
END;

```

#### 13.6.5.6 REPEAT Syntax

```
[begin_label:] REPEAT
    statement_list
UNTIL search_condition
END REPEAT [end_label]

```

​        The statement list within a        [`REPEAT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#repeat) statement is repeated        until the *search_condition* expression        is true. Thus, a [`REPEAT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#repeat) always        enters the loop at least once.        *statement_list* consists of one or        more statements, each terminated by a semicolon        (`;`) statement delimiter.      

​        A [`REPEAT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#repeat) statement can be        labeled. For the rules regarding label use, see        [Section 13.6.2, “Statement Label Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#statement-labels).      

​        Example:      

```
mysql> delimiter //

mysql> CREATE PROCEDURE dorepeat(p1 INT)
    -> BEGIN
    ->   SET @x = 0;
    ->   REPEAT
    ->     SET @x = @x + 1;
    ->   UNTIL @x > p1 END REPEAT;
    -> END
    -> //
Query OK, 0 rows affected (0.00 sec)

mysql> CALL dorepeat(1000)//
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT @x//
+------+
| @x   |
+------+
| 1001 |
+------+
1 row in set (0.00 sec)

```

#### 13.6.5.7 RETURN Syntax

```
RETURN expr

```

​        The [`RETURN`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#return) statement terminates        execution of a stored function and returns the value        *expr* to the function caller. There        must be at least one [`RETURN`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#return)        statement in a stored function. There may be more than one if        the function has multiple exit points.      

​        This statement is not used in stored procedures, triggers, or        events. The [`LEAVE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#leave) statement can        be used to exit a stored program of those types.

#### 13.6.5.8 WHILE Syntax

```
[begin_label:] WHILE search_condition DO
    statement_list
END WHILE [end_label]

```

​        The statement list within a [`WHILE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#while)        statement is repeated as long as the        *search_condition* expression is true.        *statement_list* consists of one or        more SQL statements, each terminated by a semicolon        (`;`) statement delimiter.      

​        A [`WHILE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#while) statement can be labeled.        For the rules regarding label use, see        [Section 13.6.2, “Statement Label Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#statement-labels).      

​        Example:      

```
CREATE PROCEDURE dowhile()
BEGIN
  DECLARE v1 INT DEFAULT 5;

  WHILE v1 > 0 DO
    ...
    SET v1 = v1 - 1;
  END WHILE;
END;

```

### 13.6.6 Cursors

- [13.6.6.1 Cursor CLOSE Syntax](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#close)
- [13.6.6.2 Cursor DECLARE Syntax](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare-cursor)
- [13.6.6.3 Cursor FETCH Syntax](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#fetch)
- [13.6.6.4 Cursor OPEN Syntax](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#open)

​      MySQL supports cursors inside stored programs. The syntax is as in      embedded SQL. Cursors have these properties:

- ​          Asensitive: The server may or may not make a copy of its          result table        
- ​          Read only: Not updatable        
- ​          Nonscrollable: Can be traversed only in one direction and          cannot skip rows

​      Cursor declarations must appear before handler declarations and      after variable and condition declarations.    

​      Example:    

```
CREATE PROCEDURE curdemo()
BEGIN
  DECLARE done INT DEFAULT FALSE;
  DECLARE a CHAR(16);
  DECLARE b, c INT;
  DECLARE cur1 CURSOR FOR SELECT id,data FROM test.t1;
  DECLARE cur2 CURSOR FOR SELECT i FROM test.t2;
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

  OPEN cur1;
  OPEN cur2;

  read_loop: LOOP
    FETCH cur1 INTO a, b;
    FETCH cur2 INTO c;
    IF done THEN
      LEAVE read_loop;
    END IF;
    IF b < c THEN
      INSERT INTO test.t3 VALUES (a,b);
    ELSE
      INSERT INTO test.t3 VALUES (a,c);
    END IF;
  END LOOP;

  CLOSE cur1;
  CLOSE cur2;
END;

```

#### 13.6.6.1 Cursor CLOSE Syntax

```
CLOSE cursor_name

```

​        This statement closes a previously opened cursor. For an        example, see [Section 13.6.6, “Cursors”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#cursors).      

​        An error occurs if the cursor is not open.      

​        If not closed explicitly, a cursor is closed at the end of the        [`BEGIN ...        END`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#begin-end) block in which it was declared.

#### 13.6.6.2 Cursor DECLARE Syntax

```
DECLARE cursor_name CURSOR FOR select_statement

```

​        This statement declares a cursor and associates it with a        [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement that retrieves        the rows to be traversed by the cursor. To fetch the rows later,        use a [`FETCH`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#fetch) statement. The number        of columns retrieved by the        [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement must match the        number of output variables specified in the        [`FETCH`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#fetch) statement.      

​        The [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement cannot have        an `INTO` clause.      

​        Cursor declarations must appear before handler declarations and        after variable and condition declarations.      

​        A stored program may contain multiple cursor declarations, but        each cursor declared in a given block must have a unique name.        For an example, see [Section 13.6.6, “Cursors”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#cursors).      

​        For information available through        [`SHOW`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show) statements, it is possible        in many cases to obtain equivalent information by using a cursor        with an `INFORMATION_SCHEMA` table.

#### 13.6.6.3 Cursor FETCH Syntax

```
FETCH [[NEXT] FROM] cursor_name INTO var_name [, var_name] ...

```

​        This statement fetches the next row for the        [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement associated with        the specified cursor (which must be open), and advances the        cursor pointer. If a row exists, the fetched columns are stored        in the named variables. The number of columns retrieved by the        [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement must match the        number of output variables specified in the        [`FETCH`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#fetch) statement.      

​        If no more rows are available, a No Data condition occurs with        SQLSTATE value `'02000'`. To detect this        condition, you can set up a handler for it (or for a        `NOT FOUND` condition). For an example, see        [Section 13.6.6, “Cursors”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#cursors).      

​        Be aware that another operation, such as a        `SELECT` or another `FETCH`,        may also cause the handler to execute by raising the same        condition. If it is necessary to distinguish which operation        raised the condition, place the operation within its own        [`BEGIN ...        END`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#begin-end) block so that it can be associated with its own        handler.

#### 13.6.6.4 Cursor OPEN Syntax

```
OPEN cursor_name

```

​        This statement opens a previously declared cursor. For an        example, see [Section 13.6.6, “Cursors”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#cursors).

### 13.6.7 Condition Handling

- [13.6.7.1 DECLARE ... CONDITION Syntax](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare-condition)
- [13.6.7.2 DECLARE ... HANDLER Syntax](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare-handler)
- [13.6.7.3 RESIGNAL Syntax](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal)
- [13.6.7.4 SIGNAL Syntax](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal)

​      Conditions may arise during stored program execution that require      special handling, such as exiting the current program block or      continuing execution. Handlers can be defined for general      conditions such as warnings or exceptions, or for specific      conditions such as a particular error code. Specific conditions      can be assigned names and referred to that way in handlers.    

​      To name a condition, use the      [`DECLARE ...      CONDITION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare-condition) statement. To declare a handler, use the      [`DECLARE ...      HANDLER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare-handler) statement. See      [Section 13.6.7.1, “DECLARE ... CONDITION Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare-condition), and      [Section 13.6.7.2, “DECLARE ... HANDLER Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare-handler).    

​      To raise a condition, use the      [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal) statement. To modify      condition information within a condition handler, use      [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal). See      [Section 13.6.7.1, “DECLARE ... CONDITION Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare-condition), and      [Section 13.6.7.2, “DECLARE ... HANDLER Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare-handler).    

​      Another statement related to conditions is `GET      DIAGNOSTICS`. The `GET DIAGNOSTICS`      statement is not supported until MySQL 5.6.    

​      Before MySQL 5.6.3, if a statement that generates a warning or      error causes a condition handler to be invoked, the handler may      not clear the diagnostic area. This might lead to the appearance      that the handler was not invoked. The following discussion      demonstrates the issue and provides a workaround.    

​      Suppose that a table `t1` is empty. The following      procedure selects from it, raising a No Data condition:    

```
CREATE PROCEDURE p1()
BEGIN
  DECLARE a INT;
  DECLARE CONTINUE HANDLER FOR NOT FOUND
    BEGIN
      SET @handler_invoked = 1;
    END;
  SELECT c1 INTO a FROM t1;
END;

```

​      As can be seen from the following sequence of statements, the      condition is not cleared by handler invocation (otherwise, the      [`SHOW WARNINGS`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-warnings) output would be      empty). But as can be seen by the value of      `@handler_invoked`, the handler was indeed      invoked (otherwise its value would be 0).    

```
mysql> SET @handler_invoked = 0;
Query OK, 0 rows affected (0.00 sec)

mysql> CALL p1();
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql> SHOW WARNINGS;
+---------+------+-----------------------------------------------------+
| Level   | Code | Message                                             |
+---------+------+-----------------------------------------------------+
| Warning | 1329 | No data - zero rows fetched, selected, or processed |
+---------+------+-----------------------------------------------------+
1 row in set (0.00 sec)

mysql> SELECT @handler_invoked;
+------------------+
| @handler_invoked |
+------------------+
|                1 |
+------------------+
1 row in set (0.00 sec)

```

​      To work around this issue, use a condition handler containing a      statement that clears warnings:    

```
CREATE PROCEDURE p1()
BEGIN
  DECLARE a INT;
  DECLARE CONTINUE HANDLER FOR NOT FOUND
    BEGIN
      SELECT 1 INTO @handler_invoked FROM (SELECT 1) AS t;
    END;
  SELECT c1 INTO a FROM t1;
END;

```

​      This works for `CONTINUE` and      `EXIT` handlers.    

​      This issue is resolved as of MySQL 5.6.3 and no workaround is      needed.

#### 13.6.7.1 DECLARE ... CONDITION Syntax

```
DECLARE condition_name CONDITION FOR condition_value

condition_value:
    mysql_error_code
  | SQLSTATE [VALUE] sqlstate_value

```

​        The [`DECLARE        ... CONDITION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare-condition) statement declares a named error        condition, associating a name with a condition that needs        specific handling. The name can be referred to in a subsequent        [`DECLARE ...        HANDLER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare-handler) statement (see        [Section 13.6.7.2, “DECLARE ... HANDLER Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare-handler)).      

​        Condition declarations must appear before cursor or handler        declarations.      

​        The *condition_value* for        [`DECLARE ...        CONDITION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare-condition) indicates the specific condition or class of        conditions to associate with the condition name. It can take the        following forms:

- ​            *mysql_error_code*: An integer            literal indicating a MySQL error code.          

  ​            Do not use MySQL error code 0 because that indicates success            rather than an error condition. For a list of MySQL error            codes, see [Section B.3, “Server Error Codes and Messages”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/error-handling.html#error-messages-server).          

- ​            SQLSTATE [VALUE] *sqlstate_value*:            A 5-character string literal indicating an SQLSTATE value.          

  ​            Do not use SQLSTATE values that begin with            `'00'` because those indicate success            rather than an error condition. For a list of SQLSTATE            values, see [Section B.3, “Server Error Codes and Messages”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/error-handling.html#error-messages-server).

​        Condition names referred to in        [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal) or use        [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) statements must be        associated with SQLSTATE values, not MySQL error codes.      

​        Using names for conditions can help make stored program code        clearer. For example, this handler applies to attempts to drop a        nonexistent table, but that is apparent only if you know that        1051 is the MySQL error code for “unknown table”:      

```
DECLARE CONTINUE HANDLER FOR 1051
  BEGIN
    -- body of handler
  END;

```

​        By declaring a name for the condition, the purpose of the        handler is more readily seen:      

```
DECLARE no_such_table CONDITION FOR 1051;
DECLARE CONTINUE HANDLER FOR no_such_table
  BEGIN
    -- body of handler
  END;

```

​        Here is a named condition for the same condition, but based on        the corresponding SQLSTATE value rather than the MySQL error        code:      

```
DECLARE no_such_table CONDITION FOR SQLSTATE '42S02';
DECLARE CONTINUE HANDLER FOR no_such_table
  BEGIN
    -- body of handler
  END;

```

#### 13.6.7.2 DECLARE ... HANDLER Syntax

```
DECLARE handler_action HANDLER
    FOR condition_value [, condition_value] ...
    statement

handler_action:
    CONTINUE
  | EXIT
  | UNDO

condition_value:
    mysql_error_code
  | SQLSTATE [VALUE] sqlstate_value
  | condition_name
  | SQLWARNING
  | NOT FOUND
  | SQLEXCEPTION

```

​        The [`DECLARE ...        HANDLER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare-handler) statement specifies a handler that deals with        one or more conditions. If one of these conditions occurs, the        specified *statement* executes.        *statement* can be a simple statement        such as `SET *var_name* =        *value*`, or a compound        statement written using `BEGIN` and        `END` (see [Section 13.6.1, “BEGIN ... END Compound-Statement Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#begin-end)).      

​        Handler declarations must appear after variable or condition        declarations.      

​        The *handler_action* value indicates        what action the handler takes after execution of the handler        statement:

- ​            `CONTINUE`: Execution of the current            program continues.          
- ​            `EXIT`: Execution terminates for the            [`BEGIN ...            END`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#begin-end) compound statement in which the handler is            declared. This is true even if the condition occurs in an            inner block.          
- ​            `UNDO`: Not supported.

​        The *condition_value* for        [`DECLARE ...        HANDLER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare-handler) indicates the specific condition or class of        conditions that activates the handler. It can take the following        forms:

- ​            *mysql_error_code*: An integer            literal indicating a MySQL error code, such as 1051 to            specify “unknown table”:          

  ```
  DECLARE CONTINUE HANDLER FOR 1051
    BEGIN
      -- body of handler
    END;

  ```

  ​            Do not use MySQL error code 0 because that indicates success            rather than an error condition. For a list of MySQL error            codes, see [Section B.3, “Server Error Codes and Messages”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/error-handling.html#error-messages-server).          

- ​            SQLSTATE [VALUE] *sqlstate_value*:            A 5-character string literal indicating an SQLSTATE value,            such as `'42S01'` to specify “unknown            table”:          

  ```
  DECLARE CONTINUE HANDLER FOR SQLSTATE '42S02'
    BEGIN
      -- body of handler
    END;

  ```

  ​            Do not use SQLSTATE values that begin with            `'00'` because those indicate success            rather than an error condition. For a list of SQLSTATE            values, see [Section B.3, “Server Error Codes and Messages”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/error-handling.html#error-messages-server).          

- ​            *condition_name*: A condition name            previously specified with            [`DECLARE            ... CONDITION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare-condition). A condition name can be associated            with a MySQL error code or SQLSTATE value. See            [Section 13.6.7.1, “DECLARE ... CONDITION Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare-condition).          

- ​            `SQLWARNING`: Shorthand for the class of            SQLSTATE values that begin with `'01'`.          

  ```
  DECLARE CONTINUE HANDLER FOR SQLWARNING
    BEGIN
      -- body of handler
    END;

  ```

- ​            `NOT FOUND`: Shorthand for the class of            SQLSTATE values that begin with `'02'`.            This is relevant within the context of cursors and is used            to control what happens when a cursor reaches the end of a            data set. If no more rows are available, a No Data condition            occurs with SQLSTATE value `'02000'`. To            detect this condition, you can set up a handler for it or            for a `NOT FOUND` condition.          

  ```
  DECLARE CONTINUE HANDLER FOR NOT FOUND
    BEGIN
      -- body of handler
    END;

  ```

  ​            For another example, see [Section 13.6.6, “Cursors”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#cursors). The            `NOT FOUND` condition also occurs for            `SELECT ... INTO            *var_list*` statements            that retrieve no rows.          

- ​            `SQLEXCEPTION`: Shorthand for the class of            SQLSTATE values that do not begin with            `'00'`, `'01'`, or            `'02'`.          

  ```
  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
    BEGIN
      -- body of handler
    END;

  ```

​        If a condition occurs for which no handler has been declared,        the action taken depends on the condition class:

- ​            For `SQLEXCEPTION` conditions, the stored            program terminates at the statement that raised the            condition, as if there were an `EXIT`            handler. If the program was called by another stored            program, the calling program handles the condition using the            handler selection rules applied to its own handlers.          
- ​            For `SQLWARNING` conditions, the program            continues executing, as if there were a            `CONTINUE` handler.          
- ​            For `NOT FOUND` conditions, if the            condition was raised normally, the action is            `CONTINUE`. If it was raised by            [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal) or            [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal), the action is            `EXIT`.

​        The following example uses a handler for `SQLSTATE        '23000'`, which occurs for a duplicate-key error:      

```
mysql> CREATE TABLE test.t (s1 INT, PRIMARY KEY (s1));
Query OK, 0 rows affected (0.00 sec)

mysql> delimiter //

mysql> CREATE PROCEDURE handlerdemo ()
    -> BEGIN
    ->   DECLARE CONTINUE HANDLER FOR SQLSTATE '23000' SET @x2 = 1;
    ->   SET @x = 1;
    ->   INSERT INTO test.t VALUES (1);
    ->   SET @x = 2;
    ->   INSERT INTO test.t VALUES (1);
    ->   SET @x = 3;
    -> END;
    -> //
Query OK, 0 rows affected (0.00 sec)

mysql> CALL handlerdemo()//
Query OK, 0 rows affected, 1 warning (0.01 sec)

mysql> SHOW WARNINGS//
+-------+------+---------------------------------------+
| Level | Code | Message                               |
+-------+------+---------------------------------------+
| Error | 1062 | Duplicate entry '1' for key 'PRIMARY' |
+-------+------+---------------------------------------+
1 row in set (0.00 sec)


mysql> SELECT @x//
    +------+
    | @x   |
    +------+
    | 3    |
    +------+
    1 row in set (0.00 sec)

```

​        Notice that `@x` is `3` after        the procedure executes, which shows that execution continued to        the end of the procedure after the error occurred. If the        [`DECLARE ...        HANDLER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare-handler) statement had not been present, MySQL would        have taken the default action (`EXIT`) after        the second [`INSERT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert) failed due to        the `PRIMARY KEY` constraint, and        `SELECT @x` would have returned        `2`.      

​        To ignore a condition, declare a `CONTINUE`        handler for it and associate it with an empty block. For        example:      

```
DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN END;

```

​        The scope of a block label does not include the code for        handlers declared within the block. Therefore, the statement        associated with a handler cannot use        [`ITERATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#iterate) or        [`LEAVE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#leave) to refer to labels for        blocks that enclose the handler declaration. Consider the        following example, where the        [`REPEAT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#repeat) block has a label of        `retry`:      

```
CREATE PROCEDURE p ()
BEGIN
  DECLARE i INT DEFAULT 3;
  retry:
    REPEAT
      BEGIN
        DECLARE CONTINUE HANDLER FOR SQLWARNING
          BEGIN
            ITERATE retry;    # illegal
          END;
        IF i < 0 THEN
          LEAVE retry;        # legal
        END IF;
        SET i = i - 1;
      END;
    UNTIL FALSE END REPEAT;
END;

```

​        The `retry` label is in scope for the        [`IF`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#if) statement within the block. It        is not in scope for the `CONTINUE` handler, so        the reference there is invalid and results in an error:      

```
ERROR 1308 (42000): LEAVE with no matching label: retry

```

​        To avoid references to outer labels in handlers, use one of        these strategies:

- ​            To leave the block, use an `EXIT` handler.            If no block cleanup is required, the            [`BEGIN ...            END`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#begin-end) handler body can be empty:          

  ```
  DECLARE EXIT HANDLER FOR SQLWARNING BEGIN END;

  ```

  ​            Otherwise, put the cleanup statements in the handler body:          

  ```
  DECLARE EXIT HANDLER FOR SQLWARNING
    BEGIN
      block cleanup statements
    END;

  ```

- ​            To continue execution, set a status variable in a            `CONTINUE` handler that can be checked in            the enclosing block to determine whether the handler was            invoked. The following example uses the variable            `done` for this purpose:          

  ```
  CREATE PROCEDURE p ()
  BEGIN
    DECLARE i INT DEFAULT 3;
    DECLARE done INT DEFAULT FALSE;
    retry:
      REPEAT
        BEGIN
          DECLARE CONTINUE HANDLER FOR SQLWARNING
            BEGIN
              SET done = TRUE;
            END;
          IF done OR i < 0 THEN
            LEAVE retry;
          END IF;
          SET i = i - 1;
        END;
      UNTIL FALSE END REPEAT;
  END;

  ```

#### 13.6.7.3 RESIGNAL Syntax

```
RESIGNAL [condition_value]
    [SET signal_information_item
    [, signal_information_item] ...]

condition_value:
    SQLSTATE [VALUE] sqlstate_value
  | condition_name

signal_information_item:
    condition_information_item_name = simple_value_specification

condition_information_item_name:
    CLASS_ORIGIN
  | SUBCLASS_ORIGIN
  | MESSAGE_TEXT
  | MYSQL_ERRNO
  | CONSTRAINT_CATALOG
  | CONSTRAINT_SCHEMA
  | CONSTRAINT_NAME
  | CATALOG_NAME
  | SCHEMA_NAME
  | TABLE_NAME
  | COLUMN_NAME
  | CURSOR_NAME

condition_name, simple_value_specification:
    (see following discussion)

```

​        [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) passes on the error        condition information that is available during execution of a        condition handler within a compound statement inside a stored        procedure or function, trigger, or event.        [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) may change some or all        information before passing it on.        [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) is related to        [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal), but instead of        originating a condition as [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal)        does, [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) relays existing        condition information, possibly after modifying it.      

​        [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) makes it possible to        both handle an error and return the error information.        Otherwise, by executing an SQL statement within the handler,        information that caused the handler's activation is destroyed.        [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) also can make some        procedures shorter if a given handler can handle part of a        situation, then pass the condition “up the line” to        another handler.      

​        No special privileges are required to execute the        [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) statement.      

​        All forms of [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) require        that the current context be a condition handler. Otherwise,        [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) is illegal and a        `RESIGNAL when handler not active` error        occurs.      

​        For *condition_value* and        *signal_information_item*, the        definitions and rules are the same for        [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) as for        [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal). For example, the        *condition_value* can be an        `SQLSTATE` value, and the value can indicate        errors, warnings, or “not found.” For additional        information, see [Section 13.6.7.4, “SIGNAL Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal).      

​        The [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) statement takes        *condition_value* and        `SET` clauses, both of which are optional. This        leads to several possible uses:

- ​            [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) alone:          

  ```
  RESIGNAL;

  ```

- ​            [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) with new signal            information:          

  ```
  RESIGNAL SET signal_information_item [, signal_information_item] ...;

  ```

- ​            [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) with a condition            value and possibly new signal information:          

  ```
  RESIGNAL condition_value
      [SET signal_information_item [, signal_information_item] ...];

  ```

​        These use cases all cause changes to the diagnostics and        condition areas:

- ​            A diagnostics area contains one or more condition areas.          
- ​            A condition area contains condition information items, such            as the `SQLSTATE` value,            `MYSQL_ERRNO`, or            `MESSAGE_TEXT`.

​        The maximum number of condition areas in a diagnostics area is        determined by the value of the        [`max_error_count`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_max_error_count) system        variable.

##### 13.6.7.3.1 RESIGNAL Alone

​          A simple [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) alone means          “pass on the error with no change.” It restores          the last diagnostics area and makes it the current diagnostics          area. That is, it “pops” the diagnostics area          stack.        

​          Within a condition handler that catches a condition, one use          for [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) alone is to          perform some other actions, and then pass on without change          the original condition information (the information that          existed before entry into the handler).        

​          Example:        

```
DROP TABLE IF EXISTS xx;
delimiter //
CREATE PROCEDURE p ()
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SET @error_count = @error_count + 1;
    IF @a = 0 THEN RESIGNAL; END IF;
  END;
  DROP TABLE xx;
END//
delimiter ;
SET @error_count = 0;
SET @a = 0;
CALL p();

```

​          Suppose that the `DROP TABLE xx` statement          fails. The diagnostics area stack looks like this:        

```
DA 1. ERROR 1051 (42S02): Unknown table 'xx'

```

​          Then execution enters the `EXIT` handler. It          starts by pushing a diagnostics area to the top of the stack,          which now looks like this:        

```
DA 1. ERROR 1051 (42S02): Unknown table 'xx'
DA 2. ERROR 1051 (42S02): Unknown table 'xx'

```

​          Usually a procedure statement clears the first diagnostics          area (also called the “current” diagnostics          area). `BEGIN` is an exception, it does not          clear, it does nothing. `SET` is not an          exception, it clears, performs the operation, and produces a          result of “success.” The diagnostics area stack          now looks like this:        

```
DA 1. ERROR 0000 (00000): Successful operation
DA 2. ERROR 1051 (42S02): Unknown table 'xx'

```

​          At this point, if `@a = 0`,          [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) pops the diagnostics          area stack, which now looks like this:        

```
DA 1. ERROR 1051 (42S02): Unknown table 'xx'

```

​          And that is what the caller sees.        

​          If `@a` is not 0, the handler simply ends,          which means that there is no more use for the current          diagnostics area (it has been “handled”), so it          can be thrown away, causing the stacked diagnostics area to          become the current diagnostics area again. The diagnostics          area stack looks like this:        

```
DA 1. ERROR 0000 (00000): Successful operation

```

​          The details make it look complex, but the end result is quite          useful: Handlers can execute without destroying information          about the condition that caused activation of the handler.

##### 13.6.7.3.2 RESIGNAL with New Signal Information

​          [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) with a          `SET` clause provides new signal information,          so the statement means “pass on the error with          changes”:        

```
RESIGNAL SET signal_information_item [, signal_information_item] ...;

```

​          As with [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) alone, the          idea is to pop the diagnostics area stack so that the original          information will go out. Unlike          [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) alone, anything          specified in the `SET` clause changes.        

​          Example:        

```
DROP TABLE IF EXISTS xx;
delimiter //
CREATE PROCEDURE p ()
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SET @error_count = @error_count + 1;
    IF @a = 0 THEN RESIGNAL SET MYSQL_ERRNO = 5; END IF;
  END;
  DROP TABLE xx;
END//
delimiter ;
SET @error_count = 0;
SET @a = 0;
CALL p();

```

​          Remember from the previous discussion that          [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) alone results in a          diagnostics area stack like this:        

```
DA 1. ERROR 1051 (42S02): Unknown table 'xx'

```

​          The `RESIGNAL SET MYSQL_ERRNO = 5` statement          results in this stack instead, which is what the caller sees:        

```
DA 1. ERROR 5 (42S02): Unknown table 'xx'

```

​          In other words, it changes the error number, and nothing else.        

​          The [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) statement can          change any or all of the signal information items, making the          first condition area of the diagnostics area look quite          different.

##### 13.6.7.3.3 RESIGNAL with a Condition Value and Optional New Signal Information

​          [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) with a condition value          means “push a condition into the current diagnostics          area.” If the `SET` clause is present,          it also changes the error information.        

```
RESIGNAL condition_value
    [SET signal_information_item [, signal_information_item] ...];

```

​          This form of [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) restores          the last diagnostics area and makes it the current diagnostics          area. That is, it “pops” the diagnostics area          stack, which is the same as what a simple          [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) alone would do.          However, it also changes the diagnostics area depending on the          condition value or signal information.        

​          Example:        

```
DROP TABLE IF EXISTS xx;
delimiter //
CREATE PROCEDURE p ()
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SET @error_count = @error_count + 1;
    IF @a = 0 THEN RESIGNAL SQLSTATE '45000' SET MYSQL_ERRNO=5; END IF;
  END;
  DROP TABLE xx;
END//
delimiter ;
SET @error_count = 0;
SET @a = 0;
SET @@max_error_count = 2;
CALL p();
SHOW ERRORS;

```

​          This is similar to the previous example, and the effects are          the same, except that if          [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) happens, the current          condition area looks different at the end. (The reason the          condition adds to rather than replaces the existing condition          is the use of a condition value.)        

​          The [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) statement includes          a condition value (`SQLSTATE '45000'`), so it          adds a new condition area, resulting in a diagnostics area          stack that looks like this:        

```
DA 1. (condition 2) ERROR 1051 (42S02): Unknown table 'xx'
      (condition 1) ERROR 5 (45000) Unknown table 'xx'

```

​          The result of [`CALL          p()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#call) and [`SHOW ERRORS`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-errors)          for this example is:        

```
mysql> CALL p();
ERROR 5 (45000): Unknown table 'xx'
mysql> SHOW ERRORS;
+-------+------+----------------------------------+
| Level | Code | Message                          |
+-------+------+----------------------------------+
| Error | 1051 | Unknown table 'xx'               |
| Error |    5 | Unknown table 'xx'               |
+-------+------+----------------------------------+

```

##### 13.6.7.3.4 RESIGNAL Requires Condition Handler Context

​          All forms of [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) require          that the current context be a condition handler. Otherwise,          [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) is illegal and a          `RESIGNAL when handler not active` error          occurs. For example:        

```
mysql> CREATE PROCEDURE p () RESIGNAL;
Query OK, 0 rows affected (0.00 sec)

mysql> CALL p();
ERROR 1645 (0K000): RESIGNAL when handler not active

```

​          Here is a more difficult example:        

```
delimiter //
CREATE FUNCTION f () RETURNS INT
BEGIN
  RESIGNAL;
  RETURN 5;
END//
CREATE PROCEDURE p ()
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @a=f();
  SIGNAL SQLSTATE '55555';
END//
delimiter ;
CALL p();

```

​          [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal) occurs within the          stored function `f()`, which is invoked from          within the `EXIT` handler. Thus, a handler is          active at the time [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal)          executes, even though [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal)          is not defined inside the handler.





#### 13.6.7.4 SIGNAL Syntax

```
SIGNAL condition_value
    [SET signal_information_item
    [, signal_information_item] ...]

condition_value:
    SQLSTATE [VALUE] sqlstate_value
  | condition_name

signal_information_item:
    condition_information_item_name = simple_value_specification

condition_information_item_name:
    CLASS_ORIGIN
  | SUBCLASS_ORIGIN
  | MESSAGE_TEXT
  | MYSQL_ERRNO
  | CONSTRAINT_CATALOG
  | CONSTRAINT_SCHEMA
  | CONSTRAINT_NAME
  | CATALOG_NAME
  | SCHEMA_NAME
  | TABLE_NAME
  | COLUMN_NAME
  | CURSOR_NAME

condition_name, simple_value_specification:
    (see following discussion)

```

​        [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal) is the way to        “return” an error.        [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal) provides error information        to a handler, to an outer portion of the application, or to the        client. Also, it provides control over the error's        characteristics (error number, `SQLSTATE`        value, message). Without [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal),        it is necessary to resort to workarounds such as deliberately        referring to a nonexistent table to cause a routine to return an        error.      

​        No special privileges are required to execute the        [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal) statement.      

​        The *condition_value* in a        [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal) statement indicates the        error value to be returned. It can be an        `SQLSTATE` value (a 5-character string literal)        or a *condition_name* that refers to a        named condition previously defined with        [`DECLARE ...        CONDITION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare-condition) (see [Section 13.6.7.1, “DECLARE ... CONDITION Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare-condition)).      

​        An `SQLSTATE` value can indicate errors,        warnings, or “not found.” The first two characters        of the value indicate its error class, as discussed in        [Section 13.6.7.4.1, “Signal Condition Information Items”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal-condition-information-items). Some        signal values cause statement termination; see        [Section 13.6.7.4.2, “Effect of Signals on Handlers, Cursors, and Statements”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal-effects).      

​        The `SQLSTATE` value for a        [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal) statement should not start        with `'00'` because such values indicate        success and are not valid for signaling an error. This is true        whether the `SQLSTATE` value is specified        directly in the [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal) statement        or in a named condition referred to in the statement. If the        value is invalid, a `Bad SQLSTATE` error        occurs.      

​        To signal a generic `SQLSTATE` value, use        `'45000'`, which means “unhandled        user-defined exception.”      

​        The [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal) statement optionally        includes a `SET` clause that contains multiple        signal items, in a comma-separated list of        *condition_information_item_name* =        *simple_value_specification*        assignments.      

​        Each *condition_information_item_name*        may be specified only once in the `SET` clause.        Otherwise, a `Duplicate condition information        item` error occurs.      

​        Valid *simple_value_specification*        designators can be specified using stored procedure or function        parameters, stored program local variables declared with        [`DECLARE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare), user-defined variables,        system variables, or literals. A character literal may include a        *_charset* introducer.      

​        For information about permissible        *condition_information_item_name*        values, see        [Section 13.6.7.4.1, “Signal Condition Information Items”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal-condition-information-items).      

​        The following procedure signals an error or warning depending on        the value of `pval`, its input parameter:      

```
CREATE PROCEDURE p (pval INT)
BEGIN
  DECLARE specialty CONDITION FOR SQLSTATE '45000';
  IF pval = 0 THEN
    SIGNAL SQLSTATE '01000';
  ELSEIF pval = 1 THEN
    SIGNAL SQLSTATE '45000'
      SET MESSAGE_TEXT = 'An error occurred';
  ELSEIF pval = 2 THEN
    SIGNAL specialty
      SET MESSAGE_TEXT = 'An error occurred';
  ELSE
    SIGNAL SQLSTATE '01000'
      SET MESSAGE_TEXT = 'A warning occurred', MYSQL_ERRNO = 1000;
    SIGNAL SQLSTATE '45000'
      SET MESSAGE_TEXT = 'An error occurred', MYSQL_ERRNO = 1001;
  END IF;
END;

```

​        If `pval` is 0, `p()` signals        a warning because `SQLSTATE` values that begin        with `'01'` are signals in the warning class.        The warning does not terminate the procedure, and can be seen        with [`SHOW WARNINGS`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-warnings) after the        procedure returns.      

​        If `pval` is 1, `p()` signals        an error and sets the `MESSAGE_TEXT` condition        information item. The error terminates the procedure, and the        text is returned with the error information.      

​        If `pval` is 2, the same error is signaled,        although the `SQLSTATE` value is specified        using a named condition in this case.      

​        If `pval` is anything else,        `p()` first signals a warning and sets the        message text and error number condition information items. This        warning does not terminate the procedure, so execution continues        and `p()` then signals an error. The error does        terminate the procedure. The message text and error number set        by the warning are replaced by the values set by the error,        which are returned with the error information.      

​        [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal) is typically used within        stored programs, but it is a MySQL extension that it is        permitted outside handler context. For example, if you invoke        the [**mysql**](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/programs.html#mysql) client program, you can enter any        of these statements at the prompt:      

```
mysql> SIGNAL SQLSTATE '77777';
mysql> CREATE TRIGGER t_bi BEFORE INSERT ON t
    -> FOR EACH ROW SIGNAL SQLSTATE '77777';
mysql> CREATE EVENT e ON SCHEDULE EVERY 1 SECOND
    -> DO SIGNAL SQLSTATE '77777';

```

​        [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal) executes according to the        following rules:      

​        If the [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal) statement indicates        a particular `SQLSTATE` value, that value is        used to signal the condition specified. Example:      

```
CREATE PROCEDURE p (divisor INT)
BEGIN
  IF divisor = 0 THEN
    SIGNAL SQLSTATE '22012';
  END IF;
END;

```

​        If the [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal) statement uses a        named condition, the condition must be declared in some scope        that applies to the [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal)        statement, and must be defined using an        `SQLSTATE` value, not a MySQL error number.        Example:      

```
CREATE PROCEDURE p (divisor INT)
BEGIN
  DECLARE divide_by_zero CONDITION FOR SQLSTATE '22012';
  IF divisor = 0 THEN
    SIGNAL divide_by_zero;
  END IF;
END;

```

​        If the named condition does not exist in the scope of the        [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal) statement, an        `Undefined CONDITION` error occurs.      

​        If [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal) refers to a named        condition that is defined with a MySQL error number rather than        an `SQLSTATE` value, a `SIGNAL/RESIGNAL        can only use a CONDITION defined with SQLSTATE` error        occurs. The following statements cause that error because the        named condition is associated with a MySQL error number:      

```
DECLARE no_such_table CONDITION FOR 1051;
SIGNAL no_such_table;

```

​        If a condition with a given name is declared multiple times in        different scopes, the declaration with the most local scope        applies. Consider the following procedure:      

```
CREATE PROCEDURE p (divisor INT)
BEGIN
  DECLARE my_error CONDITION FOR SQLSTATE '45000';
  IF divisor = 0 THEN
    BEGIN
      DECLARE my_error CONDITION FOR SQLSTATE '22012';
      SIGNAL my_error;
    END;
  END IF;
  SIGNAL my_error;
END;

```

​        If `divisor` is 0, the first        [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal) statement executes. The        innermost `my_error` condition declaration        applies, raising `SQLSTATE`        `'22012'`.      

​        If `divisor` is not 0, the second        [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal) statement executes. The        outermost `my_error` condition declaration        applies, raising `SQLSTATE`        `'45000'`.      

​        Signals can be raised within exception handlers:      

```
CREATE PROCEDURE p ()
BEGIN
  DECLARE EXIT HANDLER FOR SQLEXCEPTION
  BEGIN
    SIGNAL SQLSTATE VALUE '99999'
      SET MESSAGE_TEXT = 'An error occurred';
  END;
  DROP TABLE no_such_table;
END;

```

​        `CALL p()` reaches the        [`DROP TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-table) statement. There is no        table named `no_such_table`, so the error        handler is activated. The error handler destroys the original        error (“no such table”) and makes a new error with        `SQLSTATE` `'99999'` and        message `An error occurred`.

##### 13.6.7.4.1 Signal Condition Information Items

​          The following table lists the names of diagnostics area          condition information items that can be set in a          [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal) (or          [`RESIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#resignal)) statement. All items          are standard SQL except `MYSQL_ERRNO`, which          is a MySQL extension.        

```
Item Name             Definition
---------             ----------
CLASS_ORIGIN          VARCHAR(64)
SUBCLASS_ORIGIN       VARCHAR(64)
CONSTRAINT_CATALOG    VARCHAR(64)
CONSTRAINT_SCHEMA     VARCHAR(64)
CONSTRAINT_NAME       VARCHAR(64)
CATALOG_NAME          VARCHAR(64)
SCHEMA_NAME           VARCHAR(64)
TABLE_NAME            VARCHAR(64)
COLUMN_NAME           VARCHAR(64)
CURSOR_NAME           VARCHAR(64)
MESSAGE_TEXT          VARCHAR(128)
MYSQL_ERRNO           SMALLINT UNSIGNED

```

​          The character set for character items is UTF-8.        

​          It is illegal to assign `NULL` to a condition          information item in a [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal)          statement.        

​          A [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal) statement always          specifies an `SQLSTATE` value, either          directly, or indirectly by referring to a named condition          defined with an `SQLSTATE` value. The first          two characters of an `SQLSTATE` value are its          class, and the class determines the default value for the          condition information items:

- ​              Class = `'00'` (success)            

  ​              Illegal. `SQLSTATE` values that begin              with `'00'` indicate success and are not              valid for [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal).            

- ​              Class = `'01'` (warning)            

  ```
  MESSAGE_TEXT = 'Unhandled user-defined warning condition';
  MYSQL_ERRNO = ER_SIGNAL_WARN

  ```

- ​              Class = `'02'` (not found)            

  ```
  MESSAGE_TEXT = 'Unhandled user-defined not found condition';
  MYSQL_ERRNO = ER_SIGNAL_NOT_FOUND

  ```

- ​              Class > `'02'` (exception)            

  ```
  MESSAGE_TEXT = 'Unhandled user-defined exception condition';
  MYSQL_ERRNO = ER_SIGNAL_EXCEPTION

  ```

​          For legal classes, the other condition information items are          set as follows:        

```
CLASS_ORIGIN = SUBCLASS_ORIGIN = '';
CONSTRAINT_CATALOG = CONSTRAINT_SCHEMA = CONSTRAINT_NAME = '';
CATALOG_NAME = SCHEMA_NAME = TABLE_NAME = COLUMN_NAME = '';
CURSOR_NAME = '';

```

​          The error values that are accessible after          [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal) executes are the          `SQLSTATE` value raised by the          [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal) statement and the          `MESSAGE_TEXT` and          `MYSQL_ERRNO` items. These values are          available from the C API:

- ​              `SQLSTATE` value: Call              [`mysql_sqlstate()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/connectors-apis.html#mysql-sqlstate)            
- ​              `MYSQL_ERRNO` value: Call              [`mysql_errno()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/connectors-apis.html#mysql-errno)            
- ​              `MESSAGE_TEXT` value: Call              [`mysql_error()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/connectors-apis.html#mysql-error)

​          From SQL, the output from [`SHOW          WARNINGS`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-warnings) and [`SHOW          ERRORS`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-errors) indicates the `MYSQL_ERRNO`          and `MESSAGE_TEXT` values in the          `Code` and `Message`          columns.        

​          Other condition information items can be set, but currently          have no effect, in the sense that they are not accessible from          error returns. For example, you can set          `CLASS_ORIGIN` in a          [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal) statement, but cannot          see it after [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal) executes.          In MySQL 5.6, condition information can be inspected with the          `GET DIAGNOSTICS` statement.

##### 13.6.7.4.2 Effect of Signals on Handlers, Cursors, and Statements

​          Signals have different effects on statement execution          depending on the signal class. The class determines how severe          an error is. MySQL ignores the value of the          [`sql_mode`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_sql_mode) system variable; in          particular, strict SQL mode does not matter. MySQL also          ignores `IGNORE`: The intent of          [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal) is to raise a          user-generated error explicitly, so a signal is never ignored.        

​          In the following descriptions, “unhandled” means          that no handler for the signaled `SQLSTATE`          value has been defined with          [`DECLARE ...          HANDLER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare-handler).

- ​              Class = `'00'` (success)            

  ​              Illegal. `SQLSTATE` values that begin              with `'00'` indicate success and are not              valid for [`SIGNAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#signal).            

- ​              Class = `'01'` (warning)            

  ​              The value of the              [`warning_count`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_warning_count) system              variable goes up. [`SHOW              WARNINGS`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-warnings) shows the signal.              `SQLWARNING` handlers catch the signal.              If the signal is unhandled in a function, statements do              not end.            

- ​              Class = `'02'` (not found)            

  ​              `NOT FOUND` handlers catch the signal.              There is no effect on cursors. If the signal is unhandled              in a function, statements end.            

- ​              Class > `'02'` (exception)            

  ​              `SQLEXCEPTION` handlers catch the signal.              If the signal is unhandled in a function, statements end.            

- ​              Class = `'40'`            

  ​              Treated as an ordinary exception.

​          Example:        

```
mysql> delimiter //
mysql> CREATE FUNCTION f () RETURNS INT
    -> BEGIN
    ->   SIGNAL SQLSTATE '01234';  -- signal a warning
    ->   RETURN 5;
    -> END//
mysql> delimiter ;
mysql> CREATE TABLE t (s1 INT);
mysql> INSERT INTO t VALUES (f());

```

​          The result is that a row containing 5 is inserted into table          `t`. The warning that is signaled can be          viewed with [`SHOW WARNINGS`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-warnings).