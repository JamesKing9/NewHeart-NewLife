
# Chapter 11 Data Types

MySQL supports a number of [SQL](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/glossary.html#glos_sql) data    types in several categories: numeric types, date and time types,    string (character and byte) types, and spatial types. This chapter    provides an overview of these data types, a more detailed    description of the properties of the types in each category, and a    summary of the data type storage requirements. The initial overview    is intentionally brief. The more detailed descriptions later in the    chapter should be consulted for additional information about    particular data types, such as the permissible formats in which you    can specify values.  

​    Data type descriptions use these conventions:

- ​                                                        *M* indicates the maximum display width        for integer types. For floating-point and fixed-point types,        *M* is the total number of digits that        can be stored (the precision). For string types,        *M* is the maximum length. The maximum        permissible value of *M* depends on the        data type.      
- ​                                        *D* applies to floating-point and        fixed-point types and indicates the number of digits following        the decimal point (the scale). The maximum possible value is 30,        but should be no greater than        *M*−2.      
- ​                        Square brackets (`[` and `]`)        indicate optional parts of type definitions.

## 11.1 Data Type Overview

- [11.1.1 Numeric Type Overview](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#numeric-type-overview)
- [11.1.2 Date and Time Type Overview](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#date-and-time-type-overview)
- [11.1.3 String Type Overview](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#string-type-overview)

### 11.1.1 Numeric Type Overview

​        A summary of the numeric data types follows. For additional        information about properties and storage requirements of the        numeric types, see [Section 11.2, “Numeric Types”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#numeric-types), and        [Section 11.7, “Data Type Storage Requirements”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#storage-requirements).      

​        *M* indicates the maximum display width        for integer types. The maximum display width is 255. Display        width is unrelated to the range of values a type can contain, as        described in [Section 11.2, “Numeric Types”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#numeric-types). For floating-point        and fixed-point types, *M* is the total        number of digits that can be stored.      

​        If you specify `ZEROFILL` for a numeric column,        MySQL automatically adds the `UNSIGNED`        attribute to the column.      

​        Numeric data types that permit the `UNSIGNED`        attribute also permit `SIGNED`. However, these        data types are signed by default, so the        `SIGNED` attribute has no effect.      

​        `SERIAL` is an alias for `BIGINT        UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE`.      

​        `SERIAL DEFAULT VALUE` in the definition of an        integer column is an alias for `NOT NULL AUTO_INCREMENT        UNIQUE`.

Warning

​          When you use subtraction between integer values where one is          of type `UNSIGNED`, the result is unsigned          unless the          [`NO_UNSIGNED_SUBTRACTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_no_unsigned_subtraction) SQL          mode is enabled. See [Section 12.10, “Cast Functions and Operators”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#cast-functions).

- ​                                    [`BIT[(*M*)\]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#bit-type)          

  ​            A bit-value type. *M* indicates the            number of bits per value, from 1 to 64. The default is 1 if            *M* is omitted.          

- ​                                    [`TINYINT[(*M*)\]            [UNSIGNED] [ZEROFILL]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types)          

  ​            A very small integer. The signed range is            `-128` to `127`. The            unsigned range is `0` to            `255`.          

- ​                                                            [`BOOL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types),            [`BOOLEAN`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types)          

  ​            These types are synonyms for            [`TINYINT(1)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types). A value of zero            is considered false. Nonzero values are considered true:          

  ```
  mysql> SELECT IF(0, 'true', 'false');
  +------------------------+
  | IF(0, 'true', 'false') |
  +------------------------+
  | false                  |
  +------------------------+

  mysql> SELECT IF(1, 'true', 'false');
  +------------------------+
  | IF(1, 'true', 'false') |
  +------------------------+
  | true                   |
  +------------------------+

  mysql> SELECT IF(2, 'true', 'false');
  +------------------------+
  | IF(2, 'true', 'false') |
  +------------------------+
  | true                   |
  +------------------------+

  ```

  ​            However, the values `TRUE` and            `FALSE` are merely aliases for            `1` and `0`, respectively,            as shown here:          

  ```
  mysql> SELECT IF(0 = FALSE, 'true', 'false');
  +--------------------------------+
  | IF(0 = FALSE, 'true', 'false') |
  +--------------------------------+
  | true                           |
  +--------------------------------+

  mysql> SELECT IF(1 = TRUE, 'true', 'false');
  +-------------------------------+
  | IF(1 = TRUE, 'true', 'false') |
  +-------------------------------+
  | true                          |
  +-------------------------------+

  mysql> SELECT IF(2 = TRUE, 'true', 'false');
  +-------------------------------+
  | IF(2 = TRUE, 'true', 'false') |
  +-------------------------------+
  | false                         |
  +-------------------------------+

  mysql> SELECT IF(2 = FALSE, 'true', 'false');
  +--------------------------------+
  | IF(2 = FALSE, 'true', 'false') |
  +--------------------------------+
  | false                          |
  +--------------------------------+

  ```

  ​            The last two statements display the results shown because            `2` is equal to neither            `1` nor `0`.          

- ​                                    [`SMALLINT[(*M*)\]            [UNSIGNED] [ZEROFILL]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types)          

  ​            A small integer. The signed range is            `-32768` to `32767`. The            unsigned range is `0` to            `65535`.          

- ​                                    [`MEDIUMINT[(*M*)\]            [UNSIGNED] [ZEROFILL]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types)          

  ​            A medium-sized integer. The signed range is            `-8388608` to `8388607`.            The unsigned range is `0` to            `16777215`.          

- ​                                    [`INT[(*M*)\]            [UNSIGNED] [ZEROFILL]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types)          

  ​            A normal-size integer. The signed range is            `-2147483648` to            `2147483647`. The unsigned range is            `0` to `4294967295`.          

- ​                                    [`INTEGER[(*M*)\]            [UNSIGNED] [ZEROFILL]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types)          

  ​            This type is a synonym for            [`INT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types).          

- ​                                                [`BIGINT[(*M*)\]            [UNSIGNED] [ZEROFILL]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types)          

  ​            A large integer. The signed range is            `-9223372036854775808` to            `9223372036854775807`. The unsigned range            is `0` to            `18446744073709551615`.          

  ​            `SERIAL` is an alias for `BIGINT            UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE`.          

  ​            Some things you should be aware of with respect to            [`BIGINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) columns:

  - ​                                All arithmetic is done using signed                [`BIGINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) or                [`DOUBLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types) values, so you                should not use unsigned big integers larger than                `9223372036854775807` (63 bits) except                with bit functions! If you do that, some of the last                digits in the result may be wrong because of rounding                errors when converting a                [`BIGINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) value to a                [`DOUBLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types).              

    ​                MySQL can handle [`BIGINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types)                in the following cases:

    - ​                    When using integers to store large unsigned values                    in a [`BIGINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) column.                  
    - ​                    In                    [`MIN(*col_name*)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_min)                    or                    [`MAX(*col_name*)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_max),                    where *col_name* refers to                    a [`BIGINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) column.                  
    - ​                    When using operators                    ([`+`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#operator_plus),                    [`-`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#operator_minus),                    [`*`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#operator_times),                    and so on) where both operands are integers.

  - ​                You can always store an exact integer value in a                [`BIGINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) column by storing                it using a string. In this case, MySQL performs a                string-to-number conversion that involves no                intermediate double-precision representation.              

  - ​                The [`-`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#operator_minus),                [`+`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#operator_plus), and                [`*`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#operator_times)                operators use [`BIGINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types)                arithmetic when both operands are integer values. This                means that if you multiply two big integers (or results                from functions that return integers), you may get                unexpected results when the result is larger than                `9223372036854775807`.

- ​                                    [`DECIMAL[(*M*[,*D*\])]            [UNSIGNED] [ZEROFILL]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fixed-point-types)          

  ​            A packed “exact” fixed-point number.            *M* is the total number of digits            (the precision) and *D* is the            number of digits after the decimal point (the scale). The            decimal point and (for negative numbers) the            `-` sign are not counted in            *M*. If            *D* is 0, values have no decimal            point or fractional part. The maximum number of digits            (*M*) for            [`DECIMAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fixed-point-types) is 65. The maximum            number of supported decimals (*D*)            is 30. If *D* is omitted, the            default is 0. If *M* is omitted,            the default is 10.          

  ​            `UNSIGNED`, if specified, disallows            negative values.          

  ​            All basic calculations (`+, -, *, /`) with            [`DECIMAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fixed-point-types) columns are done with            a precision of 65 digits.          

- ​                                                                                    [`DEC[(*M*[,*D*\])]            [UNSIGNED] [ZEROFILL]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fixed-point-types),            [`NUMERIC[(*M*[,*D*\])]            [UNSIGNED] [ZEROFILL]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fixed-point-types),            [`FIXED[(*M*[,*D*\])]            [UNSIGNED] [ZEROFILL]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fixed-point-types)          

  ​            These types are synonyms for            [`DECIMAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fixed-point-types). The            [`FIXED`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fixed-point-types) synonym is available            for compatibility with other database systems.          

- ​                                    [`FLOAT[(*M*,*D*)\]            [UNSIGNED] [ZEROFILL]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types)          

  ​            A small (single-precision) floating-point number.            Permissible values are `-3.402823466E+38`            to `-1.175494351E-38`,            `0`, and `1.175494351E-38`            to `3.402823466E+38`. These are the            theoretical limits, based on the IEEE standard. The actual            range might be slightly smaller depending on your hardware            or operating system.          

  ​            *M* is the total number of digits            and *D* is the number of digits            following the decimal point. If *M*            and *D* are omitted, values are            stored to the limits permitted by the hardware. A            single-precision floating-point number is accurate to            approximately 7 decimal places.          

  ​            `UNSIGNED`, if specified, disallows            negative values.          

  ​            Using [`FLOAT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types) might give you            some unexpected problems because all calculations in MySQL            are done with double precision. See            [Section B.5.4.7, “Solving Problems with No Matching Rows”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/error-handling.html#no-matching-rows).          

- ​                                                            [`DOUBLE[(*M*,*D*)\]            [UNSIGNED] [ZEROFILL]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types)          

  ​            A normal-size (double-precision) floating-point number.            Permissible values are            `-1.7976931348623157E+308` to            `-2.2250738585072014E-308`,            `0`, and            `2.2250738585072014E-308` to            `1.7976931348623157E+308`. These are the            theoretical limits, based on the IEEE standard. The actual            range might be slightly smaller depending on your hardware            or operating system.          

  ​            *M* is the total number of digits            and *D* is the number of digits            following the decimal point. If *M*            and *D* are omitted, values are            stored to the limits permitted by the hardware. A            double-precision floating-point number is accurate to            approximately 15 decimal places.          

  ​            `UNSIGNED`, if specified, disallows            negative values.          

- ​                                                            [`DOUBLE            PRECISION[(*M*,*D*)\]            [UNSIGNED] [ZEROFILL]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types),            [`REAL[(*M*,*D*)\]            [UNSIGNED] [ZEROFILL]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types)          

  ​            These types are synonyms for            [`DOUBLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types). Exception: If the            [`REAL_AS_FLOAT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_real_as_float) SQL mode is            enabled, [`REAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types) is a synonym            for [`FLOAT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types) rather than            [`DOUBLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types).          

- ​                                                [`FLOAT(*p*)            [UNSIGNED\] [ZEROFILL]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types)          

  ​            A floating-point number. *p*            represents the precision in bits, but MySQL uses this value            only to determine whether to use            [`FLOAT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types) or            [`DOUBLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types) for the resulting data            type. If *p* is from 0 to 24, the            data type becomes [`FLOAT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types) with            no *M* or            *D* values. If            *p* is from 25 to 53, the data type            becomes [`DOUBLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types) with no            *M* or *D*            values. The range of the resulting column is the same as for            the single-precision [`FLOAT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types) or            double-precision [`DOUBLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types) data            types described earlier in this section.          

  ​                                    [`FLOAT(*p*)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types)            syntax is provided for ODBC compatibility.

### 11.1.2 Date and Time Type Overview

​        A summary of the temporal data types follows. For additional        information about properties and storage requirements of the        temporal types, see [Section 11.3, “Date and Time Types”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#date-and-time-types), and        [Section 11.7, “Data Type Storage Requirements”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#storage-requirements). For descriptions of        functions that operate on temporal values, see        [Section 12.7, “Date and Time Functions”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#date-and-time-functions).      

​        For the [`DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) and        [`DATETIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) range descriptions,        “supported” means that although earlier values        might work, there is no guarantee.

- ​                                    [`DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime)          

  ​            A date. The supported range is            `'1000-01-01'` to            `'9999-12-31'`. MySQL displays            [`DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) values in            `'YYYY-MM-DD'` format, but permits            assignment of values to [`DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime)            columns using either strings or numbers.          

- ​                                    [`DATETIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime)          

  ​            A date and time combination. The supported range is            `'1000-01-01 00:00:00'` to            `'9999-12-31 23:59:59'`. MySQL displays            [`DATETIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) values in            `'YYYY-MM-DD HH:MM:SS'` format, but permits            assignment of values to            [`DATETIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) columns using either            strings or numbers.          

- ​                                    [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime)          

  ​            A timestamp. The range is `'1970-01-01            00:00:01'` UTC to `'2038-01-19            03:14:07'` UTC.            [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) values are stored            as the number of seconds since the epoch            (`'1970-01-01 00:00:00'` UTC). A            [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) cannot represent            the value `'1970-01-01 00:00:00'` because            that is equivalent to 0 seconds from the epoch and the value            0 is reserved for representing `'0000-00-00            00:00:00'`, the “zero”            [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) value.          

  ​            Unless specified otherwise, the first            [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) column in a table            is defined to be automatically set to the date and time of            the most recent modification if not explicitly assigned a            value. This makes [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime)            useful for recording the timestamp of an            [`INSERT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert) or            [`UPDATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#update) operation. You can            also set any [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) column            to the current date and time by assigning it a            `NULL` value, unless it has been defined            with the `NULL` attribute to permit            `NULL` values. The automatic initialization            and updating to the current date and time can be specified            using `DEFAULT CURRENT_TIMESTAMP` and            `ON UPDATE CURRENT_TIMESTAMP` clauses, as            described in [Section 11.3.5, “Automatic Initialization and Updating for TIMESTAMP”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#timestamp-initialization).          

- ​                                    [`TIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#time)          

  ​            A time. The range is `'-838:59:59'` to            `'838:59:59'`. MySQL displays            [`TIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#time) values in            `'HH:MM:SS'` format, but permits assignment            of values to [`TIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#time) columns            using either strings or numbers.          

- ​                                    [`YEAR[(2|4)\]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year)          

  ​            A year in two-digit or four-digit format. The default is            four-digit format. `YEAR(2)` or            `YEAR(4)` differ in display format, but            have the same range of values. In four-digit format, values            display as `1901` to            `2155`, and `0000`. In            two-digit format, values display as `70` to            `69`, representing years from 1970 to 2069.            MySQL displays [`YEAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) values in            `YYYY` or `YY` format, but            permits assignment of values to            [`YEAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) columns using either            strings or numbers.

  Note

  ​              The `YEAR(2)` data type has certain              issues that you should consider before choosing to use it.              As of MySQL 5.5.27, `YEAR(2)` is              deprecated. For more information, see              [Section 11.3.4, “YEAR(2) Limitations and Migrating to YEAR(4)”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#migrating-to-year4).

  ​            For additional information about `YEAR`            display format and interpretation of input values, see            [Section 11.3.3, “The YEAR Type”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year).

​        The [`SUM()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_sum) and        [`AVG()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_avg) aggregate functions do not        work with temporal values. (They convert the values to numbers,        losing everything after the first nonnumeric character.) To work        around this problem, convert to numeric units, perform the        aggregate operation, and convert back to a temporal value.        Examples:      

```
SELECT SEC_TO_TIME(SUM(TIME_TO_SEC(time_col))) FROM tbl_name;
SELECT FROM_DAYS(SUM(TO_DAYS(date_col))) FROM tbl_name;

```

Note

​          The MySQL server can be run with the          [`MAXDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_maxdb) SQL mode enabled. In          this case, [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) is          identical with [`DATETIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime). If          this mode is enabled at the time that a table is created,          [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) columns are created          as [`DATETIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) columns. As a          result, such columns use          [`DATETIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) display format, have          the same range of values, and there is no automatic          initialization or updating to the current date and time. See          [Section 5.1.8, “Server SQL Modes”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sql-mode).

### 11.1.3 String Type Overview

​        A summary of the string data types follows. For additional        information about properties and storage requirements of the        string types, see [Section 11.4, “String Types”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#string-types), and        [Section 11.7, “Data Type Storage Requirements”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#storage-requirements).      

​        In some cases, MySQL may change a string column to a type        different from that given in a [`CREATE        TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) or [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table)        statement. See [Section 13.1.17.7, “Silent Column Specification Changes”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#silent-column-changes).      

​        MySQL interprets length specifications in character column        definitions in character units. This applies to        [`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),        [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char), and the        [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) types.      

​        Column definitions for many string data types can include        attributes that specify the character set or collation of the        column. These attributes apply to the        [`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),        [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char), the        [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) types,        [`ENUM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum), and        [`SET`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#set) data types:

- ​            The `CHARACTER SET` attribute specifies the            character set, and the `COLLATE` attribute            specifies a collation for the character set. For example:          

  ```
  CREATE TABLE t
  (
      c1 VARCHAR(20) CHARACTER SET utf8,
      c2 TEXT CHARACTER SET latin1 COLLATE latin1_general_cs
  );

  ```

  ​            This table definition creates a column named            `c1` that has a character set of            `utf8` with the default collation for that            character set, and a column named `c2` that            has a character set of `latin1` and a            case-sensitive collation.          

  ​            The rules for assigning the character set and collation when            either or both of the `CHARACTER SET` and            `COLLATE` attributes are missing are            described in [Section 10.1.3.5, “Column Character Set and Collation”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/globalization.html#charset-column).          

  ​            `CHARSET` is a synonym for            `CHARACTER SET`.          

- ​            Specifying the `CHARACTER SET binary`            attribute for a character string data type causes the column            to be created as the corresponding binary string data type:            [`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) becomes            [`BINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary),            [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) becomes            [`VARBINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary), and            [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) becomes            [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob). For the            [`ENUM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum) and            [`SET`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#set) data types, this does not            occur; they are created as declared. Suppose that you            specify a table using this definition:          

  ```
  CREATE TABLE t
  (
    c1 VARCHAR(10) CHARACTER SET binary,
    c2 TEXT CHARACTER SET binary,
    c3 ENUM('a','b','c') CHARACTER SET binary
  );

  ```

  ​            The resulting table has this definition:          

  ```
  CREATE TABLE t
  (
    c1 VARBINARY(10),
    c2 BLOB,
    c3 ENUM('a','b','c') CHARACTER SET binary
  );

  ```

- ​            The `BINARY` attribute is shorthand for            specifying the table default character set and the binary            (`_bin`) collation of that character set.            In this case, comparison and sorting are based on numeric            character code values.          

- ​            The `ASCII` attribute is shorthand for            `CHARACTER SET latin1`.          

- ​            The `UNICODE` attribute is shorthand for            `CHARACTER SET ucs2`.

​        Character column comparison and sorting are based on the        collation assigned to the column. For the        [`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),        [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),        [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob),        [`ENUM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum), and        [`SET`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#set) data types, you can declare a        column with a binary (`_bin`) collation or the        `BINARY` attribute to cause comparison and        sorting to use the underlying character code values rather than        a lexical ordering.      

​        For additional information about use of character sets in MySQL,        see [Section 10.1, “Character Set Support”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/globalization.html#charset).

- ​                                                                                                            `[NATIONAL] CHAR[(*M*)]            [CHARACTER SET *charset_name*]            [COLLATE            *collation_name*]`          

  ​            A fixed-length string that is always right-padded with            spaces to the specified length when stored.            *M* represents the column length in            characters. The range of *M* is 0            to 255. If *M* is omitted, the            length is 1.

  ​

  Note

  ​              Trailing spaces are removed when              [`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) values are retrieved              unless the              [`PAD_CHAR_TO_FULL_LENGTH`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_pad_char_to_full_length)              SQL mode is enabled.

  ​            [`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) is shorthand for            [`CHARACTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char).            [`NATIONAL CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) (or its            equivalent short form, [`NCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char))            is the standard SQL way to define that a            [`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) column should use some            predefined character set. MySQL uses `utf8`            as this predefined character set.            [Section 10.1.3.7, “The National Character Set”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/globalization.html#charset-national).          

  ​            The [`CHAR BYTE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary) data type is an            alias for the [`BINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary) data            type. This is a compatibility feature.          

  ​            MySQL permits you to create a column of type            `CHAR(0)`. This is useful primarily when            you have to be compliant with old applications that depend            on the existence of a column but that do not actually use            its value. `CHAR(0)` is also quite nice            when you need a column that can take only two values: A            column that is defined as `CHAR(0) NULL`            occupies only one bit and can take only the values            `NULL` and `''` (the empty            string).          

- ​                                                                                                                                                            `[NATIONAL] VARCHAR(*M*)            [CHARACTER SET *charset_name*]            [COLLATE            *collation_name*]`          

  ​

  ​            A variable-length string. *M*            represents the maximum column length in characters. The            range of *M* is 0 to 65,535. The            effective maximum length of a            [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) is subject to the            maximum row size (65,535 bytes, which is shared among all            columns) and the character set used. For example,            `utf8` characters can require up to three            bytes per character, so a            [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) column that uses the            `utf8` character set can be declared to be            a maximum of 21,844 characters. See            [Section C.10.4, “Limits on Table Column Count and Row Size”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/restrictions.html#column-count-limit).          

  ​            MySQL stores [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) values            as a 1-byte or 2-byte length prefix plus data. The length            prefix indicates the number of bytes in the value. A            [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) column uses one            length byte if values require no more than 255 bytes, two            length bytes if values may require more than 255 bytes.

  Note

  ​              MySQL follows the standard SQL specification, and does              *not* remove trailing spaces from              [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) values.

  ​            [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) is shorthand for            [`CHARACTER VARYING`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char).            [`NATIONAL VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) is the            standard SQL way to define that a            [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) column should use            some predefined character set. MySQL uses            `utf8` as this predefined character set.            [Section 10.1.3.7, “The National Character Set”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/globalization.html#charset-national).            [`NVARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) is shorthand for            [`NATIONAL VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char).          

- ​                                    [`BINARY[(*M*)\]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary)          

  ​            The [`BINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary) type is similar to            the [`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) type, but stores            binary byte strings rather than nonbinary character strings.            An optional length *M* represents            the column length in bytes. If omitted,            *M* defaults to 1.          

- ​                                    [`VARBINARY(*M*)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary)          

  ​            The [`VARBINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary) type is similar            to the [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) type, but            stores binary byte strings rather than nonbinary character            strings. *M* represents the maximum            column length in bytes.          

- ​                                    [`TINYBLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob)          

  ​            A [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) column with a maximum            length of 255 (28 − 1)            bytes. Each [`TINYBLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) value is            stored using a 1-byte length prefix that indicates the            number of bytes in the value.          

- ​                                    [`TINYTEXT            [CHARACTER SET *charset_name*\]            [COLLATE            *collation_name*]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob)          

  ​            A [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) column with a maximum            length of 255 (28 − 1)            characters. The effective maximum length is less if the            value contains multibyte characters. Each            [`TINYTEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) value is stored            using a 1-byte length prefix that indicates the number of            bytes in the value.          

- ​                                    [`BLOB[(*M*)\]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob)          

  ​            A [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) column with a maximum            length of 65,535 (216 − 1)            bytes. Each [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) value is            stored using a 2-byte length prefix that indicates the            number of bytes in the value.          

  ​            An optional length *M* can be given            for this type. If this is done, MySQL creates the column as            the smallest [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) type large            enough to hold values *M* bytes            long.          

- ​                                    [`TEXT[(*M*)\]            [CHARACTER SET *charset_name*]            [COLLATE            *collation_name*]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob)          

  ​            A [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) column with a maximum            length of 65,535 (216 − 1)            characters. The effective maximum length is less if the            value contains multibyte characters. Each            [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) value is stored using a            2-byte length prefix that indicates the number of bytes in            the value.          

  ​            An optional length *M* can be given            for this type. If this is done, MySQL creates the column as            the smallest [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) type large            enough to hold values *M*            characters long.          

- ​                                    [`MEDIUMBLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob)          

  ​            A [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) column with a maximum            length of 16,777,215 (224 −            1) bytes. Each [`MEDIUMBLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob)            value is stored using a 3-byte length prefix that indicates            the number of bytes in the value.          

- ​                                    [`MEDIUMTEXT            [CHARACTER SET *charset_name*\]            [COLLATE            *collation_name*]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob)          

  ​            A [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) column with a maximum            length of 16,777,215 (224 −            1) characters. The effective maximum length is less if the            value contains multibyte characters. Each            [`MEDIUMTEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) value is stored            using a 3-byte length prefix that indicates the number of            bytes in the value.          

- ​                                    [`LONGBLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob)          

  ​            A [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) column with a maximum            length of 4,294,967,295 or 4GB            (232 − 1) bytes. The            effective maximum length of            [`LONGBLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) columns depends on            the configured maximum packet size in the client/server            protocol and available memory. Each            [`LONGBLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) value is stored            using a 4-byte length prefix that indicates the number of            bytes in the value.          

- ​                                    [`LONGTEXT            [CHARACTER SET *charset_name*\]            [COLLATE            *collation_name*]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob)          

  ​            A [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) column with a maximum            length of 4,294,967,295 or 4GB            (232 − 1) characters. The            effective maximum length is less if the value contains            multibyte characters. The effective maximum length of            [`LONGTEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob)            columns also depends on the configured maximum packet size            in the client/server protocol and available memory. Each            [`LONGTEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob)            value is stored using a 4-byte length prefix that indicates            the number of bytes in the value.          

- ​                                    [`ENUM('*value1*','*value2*',...)            [CHARACTER SET *charset_name*\]            [COLLATE            *collation_name*]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum)          

  ​            An enumeration. A string object that can have only one            value, chosen from the list of values            `'*value1*'`,            `'*value2*'`,            `...`, `NULL` or the            special `''` error value.            [`ENUM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum) values are represented            internally as integers.          

  ​            An [`ENUM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum) column can have a            maximum of 65,535 distinct elements. (The practical limit is            less than 3000.) A table can have no more than 255 unique            element list definitions among its            [`ENUM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum) and            [`SET`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#set) columns considered as a            group. For more information on these limits, see            [Section C.10.5, “Limits Imposed by .frm File Structure”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/restrictions.html#limits-frm-file).          

- ​                                    [`SET('*value1*','*value2*',...)            [CHARACTER SET *charset_name*\]            [COLLATE            *collation_name*]`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#set)          

  ​            A set. A string object that can have zero or more values,            each of which must be chosen from the list of values            `'*value1*'`,            `'*value2*'`,            `...` [`SET`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#set)            values are represented internally as integers.          

  ​            A [`SET`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#set) column can have a            maximum of 64 distinct members. A table can have no more            than 255 unique element list definitions among its            [`ENUM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum) and            [`SET`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#set) columns considered as a            group. For more information on this limit, see            [Section C.10.5, “Limits Imposed by .frm File Structure”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/restrictions.html#limits-frm-file).

## 11.2 Numeric Types

- [11.2.1 Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT,MEDIUMINT, BIGINT](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types)
- [11.2.2 Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fixed-point-types)
- [11.2.3 Floating-Point Types (Approximate Value) - FLOAT, DOUBLE](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types)
- [11.2.4 Bit-Value Type - BIT](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#bit-type)
- [11.2.5 Numeric Type Attributes](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#numeric-type-attributes)
- [11.2.6 Out-of-Range and Overflow Handling](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#out-of-range-and-overflow)

​      MySQL supports all standard SQL numeric data types. These types      include the exact numeric data types      ([`INTEGER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types),      [`SMALLINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types),      [`DECIMAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fixed-point-types), and      [`NUMERIC`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fixed-point-types)), as well as the      approximate numeric data types      ([`FLOAT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types),      [`REAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types), and      [`DOUBLE PRECISION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types)). The keyword      [`INT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) is a synonym for      [`INTEGER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types), and the keywords      [`DEC`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fixed-point-types) and      [`FIXED`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fixed-point-types) are synonyms for      [`DECIMAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fixed-point-types). MySQL treats      [`DOUBLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types) as a synonym for      [`DOUBLE PRECISION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types) (a nonstandard      extension). MySQL also treats [`REAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types)      as a synonym for [`DOUBLE PRECISION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types)      (a nonstandard variation), unless the      [`REAL_AS_FLOAT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_real_as_float) SQL mode is      enabled.    

​      The [`BIT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#bit-type) data type stores bit values      and is supported for [`MyISAM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#myisam-storage-engine),      [`MEMORY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#memory-storage-engine),      [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html), and      [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) tables.    

​      For information about how MySQL handles assignment of out-of-range      values to columns and overflow during expression evaluation, see      [Section 11.2.6, “Out-of-Range and Overflow Handling”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#out-of-range-and-overflow).    

​      For information about numeric type storage requirements, see      [Section 11.7, “Data Type Storage Requirements”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#storage-requirements).    

​      The data type used for the result of a calculation on numeric      operands depends on the types of the operands and the operations      performed on them. For more information, see      [Section 12.6.1, “Arithmetic Operators”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#arithmetic-functions).

### 11.2.1 Integer Types (Exact Value) - INTEGER, INT, SMALLINT, TINYINT,MEDIUMINT, BIGINT

​        MySQL supports the SQL standard integer types        `INTEGER` (or `INT`) and        `SMALLINT`. As an extension to the standard,        MySQL also supports the integer types        `TINYINT`, `MEDIUMINT`, and        `BIGINT`. The following table shows the        required storage and range for each integer type.

| Type        | Storage | Minimum Value          | Maximum Value          |
| ----------- | ------- | ---------------------- | ---------------------- |
|             | (Bytes) | (Signed/Unsigned)      | (Signed/Unsigned)      |
| `TINYINT`   | 1       | `-128`                 | `127`                  |
|             |         | `0`                    | `255`                  |
| `SMALLINT`  | 2       | `-32768`               | `32767`                |
|             |         | `0`                    | `65535`                |
| `MEDIUMINT` | 3       | `-8388608`             | `8388607`              |
|             |         | `0`                    | `16777215`             |
| `INT`       | 4       | `-2147483648`          | `2147483647`           |
|             |         | `0`                    | `4294967295`           |
| `BIGINT`    | 8       | `-9223372036854775808` | `9223372036854775807`  |
|             |         | `0`                    | `18446744073709551615` |

### 11.2.2 Fixed-Point Types (Exact Value) - DECIMAL, NUMERIC

​        The `DECIMAL` and `NUMERIC`        types store exact numeric data values. These types are used when        it is important to preserve exact precision, for example with        monetary data. In MySQL, `NUMERIC` is        implemented as `DECIMAL`, so the following        remarks about `DECIMAL` apply equally to        `NUMERIC`.      

​        MySQL stores `DECIMAL` values in binary format.        See [Section 12.18, “Precision Math”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#precision-math).      

​        In a `DECIMAL` column declaration, the        precision and scale can be (and usually is) specified; for        example:      

```
salary DECIMAL(5,2)

```

​        In this example, `5` is the precision and        `2` is the scale. The precision represents the        number of significant digits that are stored for values, and the        scale represents the number of digits that can be stored        following the decimal point.      

​        Standard SQL requires that `DECIMAL(5,2)` be        able to store any value with five digits and two decimals, so        values that can be stored in the `salary`        column range from `-999.99` to        `999.99`.      

​        In standard SQL, the syntax        `DECIMAL(*M*)` is        equivalent to        `DECIMAL(*M*,0)`.        Similarly, the syntax `DECIMAL` is equivalent        to `DECIMAL(*M*,0)`,        where the implementation is permitted to decide the value of        *M*. MySQL supports both of these        variant forms of `DECIMAL` syntax. The default        value of *M* is 10.      

​        If the scale is 0, `DECIMAL` values contain no        decimal point or fractional part.      

​        The maximum number of digits for `DECIMAL` is        65, but the actual range for a given `DECIMAL`        column can be constrained by the precision or scale for a given        column. When such a column is assigned a value with more digits        following the decimal point than are permitted by the specified        scale, the value is converted to that scale. (The precise        behavior is operating system-specific, but generally the effect        is truncation to the permissible number of digits.)

### 11.2.3 Floating-Point Types (Approximate Value) - FLOAT, DOUBLE

​        The `FLOAT` and `DOUBLE` types        represent approximate numeric data values. MySQL uses four bytes        for single-precision values and eight bytes for double-precision        values.      

​        For `FLOAT`, the SQL standard permits an        optional specification of the precision (but not the range of        the exponent) in bits following the keyword        `FLOAT` in parentheses. MySQL also supports        this optional precision specification, but the precision value        is used only to determine storage size. A precision from 0 to 23        results in a 4-byte single-precision `FLOAT`        column. A precision from 24 to 53 results in an 8-byte        double-precision `DOUBLE` column.      

​        MySQL permits a nonstandard syntax:        `FLOAT(*M*,*D*)`        or        `REAL(*M*,*D*)`        or `DOUBLE        PRECISION(*M*,*D*)`.        Here,        `(*M*,*D*)`        means than values can be stored with up to        *M* digits in total, of which        *D* digits may be after the decimal        point. For example, a column defined as        `FLOAT(7,4)` will look like        `-999.9999` when displayed. MySQL performs        rounding when storing values, so if you insert        `999.00009` into a        `FLOAT(7,4)` column, the approximate result is        `999.0001`.      

​        Because floating-point values are approximate and not stored as        exact values, attempts to treat them as exact in comparisons may        lead to problems. They are also subject to platform or        implementation dependencies. For more information, see        [Section B.5.4.8, “Problems with Floating-Point Values”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/error-handling.html#problems-with-float)      

​        For maximum portability, code requiring storage of approximate        numeric data values should use `FLOAT` or        `DOUBLE PRECISION` with no specification of        precision or number of digits.

### 11.2.4 Bit-Value Type - BIT

​        The `BIT` data type is used to store bit        values. A type of        `BIT(*M*)` enables        storage of *M*-bit values.        *M* can range from 1 to 64.      

​        To specify bit values,        `b'*value*'` notation        can be used. *value* is a binary value        written using zeros and ones. For example,        `b'111'` and `b'10000000'`        represent 7 and 128, respectively. See        [Section 9.1.5, “Bit-Value Literals”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/language-structure.html#bit-value-literals).      

​        If you assign a value to a        `BIT(*M*)` column that        is less than *M* bits long, the value        is padded on the left with zeros. For example, assigning a value        of `b'101'` to a `BIT(6)`        column is, in effect, the same as assigning        `b'000101'`.      

**NDB Cluster. **          The maximum combined size of all `BIT`          columns used in a given [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) table          must not exceed 4096 bits.

### 11.2.5 Numeric Type Attributes

​        MySQL supports an extension for optionally specifying the        display width of integer data types in parentheses following the        base keyword for the type. For example,        [`INT(4)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) specifies an        [`INT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) with a display width of four        digits. This optional display width may be used by applications        to display integer values having a width less than the width        specified for the column by left-padding them with spaces. (That        is, this width is present in the metadata returned with result        sets. Whether it is used or not is up to the application.)      

​        The display width does *not* constrain the        range of values that can be stored in the column. Nor does it        prevent values wider than the column display width from being        displayed correctly. For example, a column specified as        [`SMALLINT(3)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) has the usual        [`SMALLINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) range of        `-32768` to `32767`, and        values outside the range permitted by three digits are displayed        in full using more than three digits.      

​        When used in conjunction with the optional (nonstandard)        attribute `ZEROFILL`, the default padding of        spaces is replaced with zeros. For example, for a column        declared as [`INT(4) ZEROFILL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types), a        value of `5` is retrieved as        `0005`.

Note

​          The `ZEROFILL` attribute is ignored when a          column is involved in expressions or          [`UNION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#union) queries.        

​          If you store values larger than the display width in an          integer column that has the `ZEROFILL`          attribute, you may experience problems when MySQL generates          temporary tables for some complicated joins. In these cases,          MySQL assumes that the data values fit within the column          display width.

​        All integer types can have an optional (nonstandard) attribute        `UNSIGNED`. Unsigned type can be used to permit        only nonnegative numbers in a column or when you need a larger        upper numeric range for the column. For example, if an        [`INT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) column is        `UNSIGNED`, the size of the column's range is        the same but its endpoints shift from        `-2147483648` and `2147483647`        up to `0` and `4294967295`.      

​        Floating-point and fixed-point types also can be        `UNSIGNED`. As with integer types, this        attribute prevents negative values from being stored in the        column. Unlike the integer types, the upper range of column        values remains the same.      

​        If you specify `ZEROFILL` for a numeric column,        MySQL automatically adds the `UNSIGNED`        attribute to the column.      

​        Integer or floating-point data types can have the additional        attribute `AUTO_INCREMENT`. When you insert a        value of `NULL` into an indexed        `AUTO_INCREMENT` column, the column is set to        the next sequence value. Typically this is        `*value*+1`, where        *value* is the largest value for the        column currently in the table.        (`AUTO_INCREMENT` sequences begin with        `1`.)      

​        Storing `0` into an        `AUTO_INCREMENT` column has the same effect as        storing `NULL`, unless the        [`NO_AUTO_VALUE_ON_ZERO`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_no_auto_value_on_zero) SQL mode        is enabled.      

​        Inserting `NULL` to generate        `AUTO_INCREMENT` values requires that the        column be declared `NOT NULL`. If the column is        declared `NULL`, inserting        `NULL` stores a `NULL`. When        you insert any other value into an        `AUTO_INCREMENT` column, the column is set to        that value and the sequence is reset so that the next        automatically generated value follows sequentially from the        inserted value.      

​        As of MySQL 5.5.29, negative values for        `AUTO_INCREMENT` columns are not supported.

### 11.2.6 Out-of-Range and Overflow Handling

​        When MySQL stores a value in a numeric column that is outside        the permissible range of the column data type, the result        depends on the SQL mode in effect at the time:

- ​            If strict SQL mode is enabled, MySQL rejects the            out-of-range value with an error, and the insert fails, in            accordance with the SQL standard.          

- ​            If no restrictive modes are enabled, MySQL clips the value            to the appropriate endpoint of the column data type range            and stores the resulting value instead.          

  ​            When an out-of-range value is assigned to an integer column,            MySQL stores the value representing the corresponding            endpoint of the column data type range.          

  ​            When a floating-point or fixed-point column is assigned a            value that exceeds the range implied by the specified (or            default) precision and scale, MySQL stores the value            representing the corresponding endpoint of that range.

​        Suppose that a table `t1` has this definition:      

```
CREATE TABLE t1 (i1 TINYINT, i2 TINYINT UNSIGNED);

```

​        With strict SQL mode enabled, an out of range error occurs:      

```
mysql> SET sql_mode = 'TRADITIONAL';
mysql> INSERT INTO t1 (i1, i2) VALUES(256, 256);
ERROR 1264 (22003): Out of range value for column 'i1' at row 1
mysql> SELECT * FROM t1;
Empty set (0.00 sec)

```

​        With strict SQL mode not enabled, clipping with warnings occurs:      

```
mysql> SET sql_mode = '';
mysql> INSERT INTO t1 (i1, i2) VALUES(256, 256);
mysql> SHOW WARNINGS;
+---------+------+---------------------------------------------+
| Level   | Code | Message                                     |
+---------+------+---------------------------------------------+
| Warning | 1264 | Out of range value for column 'i1' at row 1 |
| Warning | 1264 | Out of range value for column 'i2' at row 1 |
+---------+------+---------------------------------------------+
mysql> SELECT * FROM t1;
+------+------+
| i1   | i2   |
+------+------+
|  127 |  255 |
+------+------+

```

​        When strict SQL mode is not enabled, column-assignment        conversions that occur due to clipping are reported as warnings        for [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table),        [`LOAD DATA        INFILE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#load-data), [`UPDATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#update), and        multiple-row [`INSERT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert) statements.        In strict mode, these statements fail, and some or all the        values are not inserted or changed, depending on whether the        table is a transactional table and other factors. For details,        see [Section 5.1.8, “Server SQL Modes”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sql-mode).      

​        Overflow during numeric expression evaluation results in an        error. For example, the largest signed        [`BIGINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) value is        9223372036854775807, so the following expression produces an        error:      

```
mysql> SELECT 9223372036854775807 + 1;
ERROR 1690 (22003): BIGINT value is out of range in '(9223372036854775807 + 1)'

```

​        To enable the operation to succeed in this case, convert the        value to unsigned;      

```
mysql> SELECT CAST(9223372036854775807 AS UNSIGNED) + 1;
+-------------------------------------------+
| CAST(9223372036854775807 AS UNSIGNED) + 1 |
+-------------------------------------------+
|                       9223372036854775808 |
+-------------------------------------------+

```

​        Whether overflow occurs depends on the range of the operands, so        another way to handle the preceding expression is to use        exact-value arithmetic because        [`DECIMAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fixed-point-types) values have a larger        range than integers:      

```
mysql> SELECT 9223372036854775807.0 + 1;
+---------------------------+
| 9223372036854775807.0 + 1 |
+---------------------------+
|     9223372036854775808.0 |
+---------------------------+

```

​        Subtraction between integer values, where one is of type        `UNSIGNED`, produces an unsigned result by        default. If the result would otherwise have been negative, an        error results:      

```
mysql> SET sql_mode = '';
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT CAST(0 AS UNSIGNED) - 1;
ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in '(cast(0 as unsigned) - 1)'

```

​        If the [`NO_UNSIGNED_SUBTRACTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_no_unsigned_subtraction)        SQL mode is enabled, the result is negative:      

```
mysql> SET sql_mode = 'NO_UNSIGNED_SUBTRACTION';
mysql> SELECT CAST(0 AS UNSIGNED) - 1;
+-------------------------+
| CAST(0 AS UNSIGNED) - 1 |
+-------------------------+
|                      -1 |
+-------------------------+

```

​        If the result of such an operation is used to update an        `UNSIGNED` integer column, the result is        clipped to the maximum value for the column type, or clipped to        0 if [`NO_UNSIGNED_SUBTRACTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_no_unsigned_subtraction)        is enabled. If strict SQL mode is enabled, an error occurs and        the column remains unchanged.

## 11.3 Date and Time Types

- [11.3.1 The DATE, DATETIME, and TIMESTAMP Types](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime)
- [11.3.2 The TIME Type](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#time)
- [11.3.3 The YEAR Type](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year)
- [11.3.4 YEAR(2) Limitations and Migrating to YEAR(4)](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#migrating-to-year4)
- [11.3.5 Automatic Initialization and Updating for TIMESTAMP](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#timestamp-initialization)
- [11.3.6 Fractional Seconds in Time Values](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fractional-seconds)
- [11.3.7 Conversion Between Date and Time Types](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#date-and-time-type-conversion)
- [11.3.8 Two-Digit Years in Dates](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#two-digit-years)

​      The date and time types for representing temporal values are      [`DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime),      [`TIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#time),      [`DATETIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime),      [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime), and      [`YEAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year). Each temporal type has a      range of valid values, as well as a “zero” value that      may be used when you specify an invalid value that MySQL cannot      represent. The [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) type has      special automatic updating behavior, described later. For temporal      type storage requirements, see      [Section 11.7, “Data Type Storage Requirements”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#storage-requirements).    

​      Keep in mind these general considerations when working with date      and time types:

- ​          MySQL retrieves values for a given date or time type in a          standard output format, but it attempts to interpret a variety          of formats for input values that you supply (for example, when          you specify a value to be assigned to or compared to a date or          time type). For a description of the permitted formats for          date and time types, see          [Section 9.1.3, “Date and Time Literals”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/language-structure.html#date-and-time-literals). It is expected that          you supply valid values. Unpredictable results may occur if          you use values in other formats.        

- ​          Although MySQL tries to interpret values in several formats,          date parts must always be given in year-month-day order (for          example, `'98-09-04'`), rather than in the          month-day-year or day-month-year orders commonly used          elsewhere (for example, `'09-04-98'`,          `'04-09-98'`).        

- ​          Dates containing two-digit year values are ambiguous because          the century is unknown. MySQL interprets two-digit year values          using these rules:

  - ​              Year values in the range `70-99` are              converted to `1970-1999`.            
  - ​              Year values in the range `00-69` are              converted to `2000-2069`.

  ​          See also [Section 11.3.8, “Two-Digit Years in Dates”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#two-digit-years).        

- ​          Conversion of values from one temporal type to another occurs          according to the rules in          [Section 11.3.7, “Conversion Between Date and Time Types”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#date-and-time-type-conversion).        

- ​          MySQL automatically converts a date or time value to a number          if the value is used in a numeric context and vice versa.        

- ​          By default, when MySQL encounters a value for a date or time          type that is out of range or otherwise invalid for the type,          it converts the value to the “zero” value for          that type. The exception is that out-of-range          [`TIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#time) values are clipped to the          appropriate endpoint of the          [`TIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#time) range.        

- ​          By setting the SQL mode to the appropriate value, you can          specify more exactly what kind of dates you want MySQL to          support. (See [Section 5.1.8, “Server SQL Modes”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sql-mode).) You can get MySQL          to accept certain dates, such as          `'2009-11-31'`, by enabling the          [`ALLOW_INVALID_DATES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_allow_invalid_dates) SQL          mode. This is useful when you want to store a “possibly          wrong” value which the user has specified (for example,          in a web form) in the database for future processing. Under          this mode, MySQL verifies only that the month is in the range          from 1 to 12 and that the day is in the range from 1 to 31.        

- ​          MySQL permits you to store dates where the day or month and          day are zero in a [`DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) or          [`DATETIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) column. This is useful          for applications that need to store birthdates for which you          may not know the exact date. In this case, you simply store          the date as `'2009-00-00'` or          `'2009-01-00'`. If you store dates such as          these, you should not expect to get correct results for          functions such as [`DATE_SUB()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_date-sub) or          [`DATE_ADD()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_date-add) that require          complete dates. To disallow zero month or day parts in dates,          enable the [`NO_ZERO_IN_DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_no_zero_in_date)          SQL mode.        

- ​          MySQL permits you to store a “zero” value of          `'0000-00-00'` as a “dummy          date.” This is in some cases more convenient than using          `NULL` values, and uses less data and index          space. To disallow `'0000-00-00'`, enable the          [`NO_ZERO_DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_no_zero_date) SQL mode.        

- ​          “Zero” date or time values used through          Connector/ODBC are converted automatically to          `NULL` because ODBC cannot handle such          values.

​      The following table shows the format of the “zero”      value for each type. The “zero” values are special,      but you can store or refer to them explicitly using the values      shown in the table. You can also do this using the values      `'0'` or `0`, which are easier      to write. For temporal types that include a date part      ([`DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime),      [`DATETIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime), and      [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime)), use of these values      produces warnings if the      [`NO_ZERO_DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_no_zero_date) SQL mode is      enabled.

| Data Type                                | “Zero” Value            |
| ---------------------------------------- | ----------------------- |
| [`DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) | `'0000-00-00'`          |
| [`TIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#time) | `'00:00:00'`            |
| [`DATETIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) | `'0000-00-00 00:00:00'` |
| [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) | `'0000-00-00 00:00:00'` |
| [`YEAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) | `0000`                  |

### 11.3.1 The DATE, DATETIME, and TIMESTAMP Types

​        The `DATE`, `DATETIME`, and        `TIMESTAMP` types are related. This section        describes their characteristics, how they are similar, and how        they differ. MySQL recognizes `DATE`,        `DATETIME`, and `TIMESTAMP`        values in several formats, described in        [Section 9.1.3, “Date and Time Literals”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/language-structure.html#date-and-time-literals). For the        `DATE` and `DATETIME` range        descriptions, “supported” means that although        earlier values might work, there is no guarantee.      

​        The `DATE` type is used for values with a date        part but no time part. MySQL retrieves and displays        `DATE` values in        `'YYYY-MM-DD'` format. The supported range is        `'1000-01-01'` to        `'9999-12-31'`.      

​        The `DATETIME` type is used for values that        contain both date and time parts. MySQL retrieves and displays        `DATETIME` values in `'YYYY-MM-DD        HH:MM:SS'` format. The supported range is        `'1000-01-01 00:00:00'` to `'9999-12-31        23:59:59'`.      

​        The `TIMESTAMP` data type is used for values        that contain both date and time parts.        `TIMESTAMP` has a range of `'1970-01-01        00:00:01'` UTC to `'2038-01-19        03:14:07'` UTC.      

​        MySQL converts `TIMESTAMP` values from the        current time zone to UTC for storage, and back from UTC to the        current time zone for retrieval. (This does not occur for other        types such as `DATETIME`.) By default, the        current time zone for each connection is the server's time. The        time zone can be set on a per-connection basis. As long as the        time zone setting remains constant, you get back the same value        you store. If you store a `TIMESTAMP` value,        and then change the time zone and retrieve the value, the        retrieved value is different from the value you stored. This        occurs because the same time zone was not used for conversion in        both directions. The current time zone is available as the value        of the [`time_zone`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_time_zone) system        variable. For more information, see        [Section 10.6, “MySQL Server Time Zone Support”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/globalization.html#time-zone-support).      

​        The `TIMESTAMP` data type offers automatic        initialization and updating to the current date and time. For        more information, see        [Section 11.3.5, “Automatic Initialization and Updating for TIMESTAMP”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#timestamp-initialization).      

​        A `DATETIME` or `TIMESTAMP`        value can include a trailing fractional seconds part in up to        microseconds (6 digits) precision. Although this fractional part        is recognized, it is discarded from values stored into        `DATETIME` or `TIMESTAMP`        columns. For information about fractional seconds support in        MySQL, see [Section 11.3.6, “Fractional Seconds in Time Values”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fractional-seconds).      

​        Invalid `DATE`, `DATETIME`, or        `TIMESTAMP` values are converted to the        “zero” value of the appropriate type        (`'0000-00-00'` or `'0000-00-00        00:00:00'`).      

​        Be aware of certain properties of date value interpretation in        MySQL:

- ​            MySQL permits a “relaxed” format for values            specified as strings, in which any punctuation character may            be used as the delimiter between date parts or time parts.            In some cases, this syntax can be deceiving. For example, a            value such as `'10:11:12'` might look like            a time value because of the `:`, but is            interpreted as the year `'2010-11-12'` if            used in a date context. The value            `'10:45:15'` is converted to            `'0000-00-00'` because            `'45'` is not a valid month.          

- ​            The server requires that month and day values be valid, and            not merely in the range 1 to 12 and 1 to 31, respectively.            With strict mode disabled, invalid dates such as            `'2004-04-31'` are converted to            `'0000-00-00'` and a warning is generated.            With strict mode enabled, invalid dates generate an error.            To permit such dates, enable            [`ALLOW_INVALID_DATES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_allow_invalid_dates). See            [Section 5.1.8, “Server SQL Modes”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sql-mode), for more information.          

- ​            MySQL does not accept `TIMESTAMP` values            that include a zero in the day or month column or values            that are not a valid date. The sole exception to this rule            is the special “zero” value            `'0000-00-00 00:00:00'`.          

- ​            [`CAST()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_cast) treats a            `TIMESTAMP` value as a string when not            selecting from a table. (This is true even if you specify            `FROM DUAL`.) See            [Section 12.10, “Cast Functions and Operators”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#cast-functions).          

- ​            Dates containing two-digit year values are ambiguous because            the century is unknown. MySQL interprets two-digit year            values using these rules:

  - ​                Year values in the range `00-69` are                converted to `2000-2069`.              
  - ​                Year values in the range `70-99` are                converted to `1970-1999`.

  ​            See also [Section 11.3.8, “Two-Digit Years in Dates”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#two-digit-years).

Note

​          The MySQL server can be run with the          [`MAXDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_maxdb) SQL mode enabled. In          this case, `TIMESTAMP` is identical with          `DATETIME`. If this mode is enabled at the          time that a table is created, `TIMESTAMP`          columns are created as `DATETIME` columns. As          a result, such columns use `DATETIME` display          format, have the same range of values, and there is no          automatic initialization or updating to the current date and          time. See [Section 5.1.8, “Server SQL Modes”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sql-mode).

### 11.3.2 The TIME Type

​        MySQL retrieves and displays `TIME` values in        `'HH:MM:SS'` format (or        `'HHH:MM:SS'` format for large hours values).        `TIME` values may range from        `'-838:59:59'` to        `'838:59:59'`. The hours part may be so large        because the `TIME` type can be used not only to        represent a time of day (which must be less than 24 hours), but        also elapsed time or a time interval between two events (which        may be much greater than 24 hours, or even negative).      

​        MySQL recognizes `TIME` values in several        formats, described in [Section 9.1.3, “Date and Time Literals”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/language-structure.html#date-and-time-literals).        Some of these formats can include a trailing fractional seconds        part in up to microseconds (6 digits) precision. Although this        fractional part is recognized, it is discarded from values        stored into `TIME` columns. For information        about fractional seconds support in MySQL, see        [Section 11.3.6, “Fractional Seconds in Time Values”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fractional-seconds).      

​        Be careful about assigning abbreviated values to a        `TIME` column. MySQL interprets abbreviated        `TIME` values with colons as time of the day.        That is, `'11:12'` means        `'11:12:00'`, not        `'00:11:12'`. MySQL interprets abbreviated        values without colons using the assumption that the two        rightmost digits represent seconds (that is, as elapsed time        rather than as time of day). For example, you might think of        `'1112'` and `1112` as meaning        `'11:12:00'` (12 minutes after 11 o'clock), but        MySQL interprets them as `'00:11:12'` (11        minutes, 12 seconds). Similarly, `'12'` and        `12` are interpreted as        `'00:00:12'`.      

​        By default, values that lie outside the `TIME`        range but are otherwise valid are clipped to the closest        endpoint of the range. For example,        `'-850:00:00'` and        `'850:00:00'` are converted to        `'-838:59:59'` and        `'838:59:59'`. Invalid `TIME`        values are converted to `'00:00:00'`. Note that        because `'00:00:00'` is itself a valid        `TIME` value, there is no way to tell, from a        value of `'00:00:00'` stored in a table,        whether the original value was specified as        `'00:00:00'` or whether it was invalid.      

​        For more restrictive treatment of invalid        `TIME` values, enable strict SQL mode to cause        errors to occur. See [Section 5.1.8, “Server SQL Modes”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sql-mode).

### 11.3.3 The YEAR Type

​        The `YEAR` type is a 1-byte type used to        represent year values. It can be declared as        `YEAR(4)` or `YEAR(2)` to        specify a display width of four or two characters. The default        is four characters if no width is given.

Note

​          The `YEAR(2)` data type has certain issues          that you should consider before choosing to use it. As of          MySQL 5.5.27, `YEAR(2)` is deprecated. For          more information, see [Section 11.3.4, “YEAR(2) Limitations and Migrating to YEAR(4)”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#migrating-to-year4).

​        `YEAR(4)` and `YEAR(2)` differ        in display format, but have the same range of values. For        4-digit format, MySQL displays `YEAR` values in        `YYYY` format, with a range of        `1901` to `2155`, or        `0000`. For 2-digit format, MySQL displays only        the last two (least significant) digits; for example,        `70` (1970 or 2070) or `69`        (2069).      

​        You can specify input `YEAR` values in a        variety of formats:

- ​            As a 4-digit number in the range `1901` to            `2155`.          
- ​            As a 4-digit string in the range `'1901'`            to `'2155'`.          
- ​            As a 1- or 2-digit number in the range `1`            to `99`. MySQL converts values in the            ranges `1` to `69` and            `70` to `99` to            `YEAR` values in the ranges            `2001` to `2069` and            `1970` to `1999`.          
- ​            As a 1- or 2-digit string in the range            `'0'` to `'99'`. MySQL            converts values in the ranges `'0'` to            `'69'` and `'70'` to            `'99'` to `YEAR` values in            the ranges `2000` to            `2069` and `1970` to            `1999`.          
- ​            Inserting a numeric `0` has a different            effect for `YEAR(2)` and            `YEAR(4)`. For `YEAR(2)`,            the result has a display value of `00` and            an internal value of `2000`. For            `YEAR(4)`, the result has a display value            of `0000` and an internal value of            `0000`. To specify zero for            `YEAR(4)` and have it be interpreted as            `2000`, specify it as a string            `'0'` or `'00'`.          
- ​            As the result of a function that returns a value that is            acceptable in a `YEAR` context, such as            [`NOW()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_now).

​        MySQL converts invalid `YEAR` values to        `0000`.      

​        See also [Section 11.3.8, “Two-Digit Years in Dates”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#two-digit-years).

### 11.3.4 YEAR(2) Limitations and Migrating to YEAR(4)

​        This section describes problems that can occur when using        [`YEAR(2)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) and provides information        about converting existing [`YEAR(2)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year)        columns to [`YEAR(4)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year).      

​        Although the internal range of values for        [`YEAR(4)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) and        [`YEAR(2)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) is the same        (`1901` to `2155`, and        `0000`), the display width for        [`YEAR(2)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) makes that type        inherently ambiguous because displayed values indicate only the        last two digits of the internal values and omit the century        digits. The result can be a loss of information under certain        circumstances. For this reason, consider avoiding        [`YEAR(2)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) throughout your        applications and using [`YEAR(4)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year)        wherever you need a [`YEAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) data        type. Note that conversion will become necessary at some point        because support for [`YEAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) data        types with display values other than 4, most notably        [`YEAR(2)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year), is reduced as of MySQL        5.6.6 and will be removed entirely in a future release.

#### YEAR(2) Limitations

​          Issues with the [`YEAR(2)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) data          type include ambiguity of displayed values, and possible loss          of information when values are dumped and reloaded or          converted to strings.

- ​              Displayed [`YEAR(2)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) values              can be ambiguous. It is possible for up to three              [`YEAR(2)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) values that have              different internal values to have the same displayed              value, as the following example demonstrates:            

  ```
  mysql> CREATE TABLE t (y2 YEAR(2), y4 YEAR(4));
  Query OK, 0 rows affected (0.01 sec)

  mysql> INSERT INTO t (y2) VALUES(1912),(2012),(2112);
  Query OK, 3 rows affected (0.00 sec)
  Records: 3  Duplicates: 0  Warnings: 0

  mysql> UPDATE t SET y4 = y2;
  Query OK, 3 rows affected (0.00 sec)
  Rows matched: 3  Changed: 3  Warnings: 0

  mysql> SELECT * FROM t;
  +------+------+
  | y2   | y4   |
  +------+------+
  |   12 | 1912 |
  |   12 | 2012 |
  |   12 | 2112 |
  +------+------+
  3 rows in set (0.00 sec)

  ```

- ​              If you use [**mysqldump**](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/programs.html#mysqldump) to dump the table              created in the preceding item, the dump file represents              all `y2` values using the same 2-digit              representation (`12`). If you reload the              table from the dump file, all resulting rows have internal              value `2012` and display value              `12`, thus losing the distinctions among              them.            

- ​              Conversion of a [`YEAR(2)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) or              [`YEAR(4)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) data value to              string form uses the display width of the              [`YEAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) type. Suppose that              [`YEAR(2)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) and              [`YEAR(4)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) columns both              contain the value `1970`. Assigning each              column to a string results in a value of              `'70'` or `'1970'`,              respectively. That is, loss of information occurs for              conversion from [`YEAR(2)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) to              string.            

- ​              Values outside the range from `1970` to              `2069` are stored incorrectly when              inserted into a [`YEAR(2)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year)              column in a [`CSV`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#csv-storage-engine) table. For              example, inserting `2111` results in a              display value of `11` but an internal              value of `2011`.

​          To avoid these problems, use          [`YEAR(4)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) rather than          [`YEAR(2)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year). Suggestions regarding          migration strategies appear later in this section.

#### Migrating from YEAR(2) to YEAR(4)

​          To convert [`YEAR(2)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) columns to          [`YEAR(4)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year), use          [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table). Suppose that a          table `t1` has this definition:        

```
CREATE TABLE t1 (ycol YEAR(2) NOT NULL DEFAULT '70');

```

​          Modify the column using `ALTER TABLE` as          follows. Remember to include any column attributes such as          `NOT NULL` or `DEFAULT`:        

```
ALTER TABLE t1 MODIFY ycol YEAR(4) NOT NULL DEFAULT '1970';

```

​          The [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) statement          converts the table without changing          [`YEAR(2)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) values. If the server          is a replication master, the [`ALTER          TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) statement replicates to slaves and makes the          corresponding table change on each one.        

​          One migration method should be avoided: Do not dump your data          with [**mysqldump**](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/programs.html#mysqldump) and reload the dump file          after upgrading. This has the potential to change          [`YEAR(2)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) values, as described          previously.        

​          A migration from [`YEAR(2)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) to          [`YEAR(4)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) should also involve          examining application code for the possibility of changed          behavior under conditions such as these:

- ​              Code that expects selecting a              [`YEAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) column to produce              exactly two digits.            
- ​              Code that does not account for different handling for              inserts of numeric `0`: Inserting              `0` into              [`YEAR(2)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) or              [`YEAR(4)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) results in an              internal value of `2000` or              `0000`, respectively.

### 11.3.5 Automatic Initialization and Updating for TIMESTAMP

Note

​          In older versions of MySQL (prior to 4.1), the properties of          the [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) data type          differed significantly in several ways from what is described          in this section (see the *MySQL 3.23, 4.0, 4.1          Reference Manual* for details); these include          syntax extensions which are deprecated in MySQL 5.1, and no          longer supported in MySQL 5.5. This has implications for          performing a dump and restore or replicating between MySQL          Server versions. If you are using columns that are defined          using the old [`TIMESTAMP(N)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime)          syntax, see [Section 2.11.1.1, “Changes Affecting Upgrades to MySQL 5.5”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/installing.html#upgrading-from-previous-series),          prior to upgrading to MySQL 5.5.

​        The [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) data type offers        automatic initialization and updating to the current date and        time (that is, the current timestamp). You can choose whether to        use these properties and which column should have them:

- ​            One [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) column in a            table can have the current timestamp as the default value            for initializing the column, as the auto-update value, or            both. It is not possible to have the current timestamp be            the default value for one column and the auto-update value            for another column.          
- ​            If the column is auto-initialized, it is set to the current            timestamp for inserted rows that specify no value for the            column.          
- ​            If the column is auto-updated, it is automatically updated            to the current timestamp when the value of any other column            in the row is changed from its current value. The column            remains unchanged if all other columns are set to their            current values. To prevent the column from updating when            other columns change, explicitly set it to its current            value. To update the column even when other columns do not            change, explicitly set it to the value it should have (for            example, set it to            [`CURRENT_TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-timestamp)).

​        In addition, you can initialize or update any        [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) column to the current        date and time by assigning it a `NULL` value,        unless it has been defined with the `NULL`        attribute to permit `NULL` values.      

​        To specify automatic properties, use the `DEFAULT        CURRENT_TIMESTAMP` and `ON UPDATE        CURRENT_TIMESTAMP` clauses. The order of the clauses        does not matter. If both are present in a column definition,        either can occur first. Any of the synonyms for        [`CURRENT_TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-timestamp) have the same        meaning as [`CURRENT_TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-timestamp).        These are [`CURRENT_TIMESTAMP()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-timestamp),        [`NOW()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_now),        [`LOCALTIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_localtime),        [`LOCALTIME()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_localtime),        [`LOCALTIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_localtimestamp), and        [`LOCALTIMESTAMP()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_localtimestamp).      

​        Use of `DEFAULT CURRENT_TIMESTAMP` and        `ON UPDATE CURRENT_TIMESTAMP` is specific to        [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime). The        `DEFAULT` clause also can be used to specify a        constant (nonautomatic) default value; for example,        `DEFAULT 0` or `DEFAULT '2000-01-01        00:00:00'`.

Note

​          The following examples use `DEFAULT 0`, a          default that can produce warnings or errors depending on          whether strict SQL mode or the          [`NO_ZERO_DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_no_zero_date) SQL mode is          enabled. Be aware that the          [`TRADITIONAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_traditional) SQL mode          includes strict mode and          [`NO_ZERO_DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_no_zero_date). See          [Section 5.1.8, “Server SQL Modes”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sql-mode).

​        The following rules describe the possibilities for defining the        first [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) column in a table        with the current timestamp for both the default and auto-update        values, for one but not the other, or for neither:

- ​            With both `DEFAULT CURRENT_TIMESTAMP` and            `ON UPDATE CURRENT_TIMESTAMP`, the column            has the current timestamp for its default value and is            automatically updated to the current timestamp.          

  ```
  CREATE TABLE t1 (
    ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
  );

  ```

- ​            With neither `DEFAULT CURRENT_TIMESTAMP`            nor `ON UPDATE CURRENT_TIMESTAMP`, it is            the same as specifying both `DEFAULT            CURRENT_TIMESTAMP` and `ON UPDATE            CURRENT_TIMESTAMP`.          

  ```
  CREATE TABLE t1 (
    ts TIMESTAMP
  );

  ```

- ​            With a `DEFAULT` clause but no `ON            UPDATE CURRENT_TIMESTAMP` clause, the column has            the given default value and is not automatically updated to            the current timestamp.          

  ​            The default depends on whether the            `DEFAULT` clause specifies            `CURRENT_TIMESTAMP` or a constant value.            With `CURRENT_TIMESTAMP`, the default is            the current timestamp.          

  ```
  CREATE TABLE t1 (
    ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  );

  ```

  ​            With a constant, the default is the given value. In this            case, the column has no automatic properties at all.          

  ```
  CREATE TABLE t1 (
    ts TIMESTAMP DEFAULT 0
  );

  ```

- ​            With an `ON UPDATE CURRENT_TIMESTAMP`            clause and a constant `DEFAULT` clause, the            column is automatically updated to the current timestamp and            has the given constant default value.          

  ```
  CREATE TABLE t1 (
    ts TIMESTAMP DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP
  );

  ```

- ​            With an `ON UPDATE CURRENT_TIMESTAMP`            clause but no `DEFAULT` clause, the column            is automatically updated to the current timestamp. The            default is 0 unless the column is defined with the            `NULL` attribute, in which case the default            is `NULL`.          

  ```
  CREATE TABLE t1 (
    ts TIMESTAMP ON UPDATE CURRENT_TIMESTAMP      -- default 0
  );
  CREATE TABLE t2 (
    ts TIMESTAMP NULL ON UPDATE CURRENT_TIMESTAMP -- default NULL
  );

  ```

​        It need not be the first        [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) column in a table that        is automatically initialized or updated to the current        timestamp. However, to specify automatic initialization or        updating for a different        [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) column, you must        suppress the automatic properties for the first one. Then, for        the other [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) column, the        rules for the `DEFAULT` and `ON        UPDATE` clauses are the same as for the first        [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) column, except that if        you omit both clauses, no automatic initialization or updating        occurs.      

​        To suppress automatic properties for the first        [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) column, do either of        the following:

- ​            Define the column with a `DEFAULT` clause            that specifies a constant default value.          
- ​            Specify the `NULL` attribute. This also            causes the column to permit `NULL` values,            which means that you cannot assign the current timestamp by            setting the column to `NULL`. Assigning            `NULL` sets the column to            `NULL`.

​        Consider these table definitions:      

```
CREATE TABLE t1 (
  ts1 TIMESTAMP DEFAULT 0,
  ts2 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                ON UPDATE CURRENT_TIMESTAMP);
CREATE TABLE t2 (
  ts1 TIMESTAMP NULL,
  ts2 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                ON UPDATE CURRENT_TIMESTAMP);
CREATE TABLE t3 (
  ts1 TIMESTAMP NULL DEFAULT 0,
  ts2 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                ON UPDATE CURRENT_TIMESTAMP);

```

​        The tables have these properties:

- ​            In each table definition, the first            [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) column has no            automatic initialization or updating.          
- ​            The tables differ in how the `ts1` column            handles `NULL` values. For            `t1`, `ts1` is            `NOT NULL` and assigning it a value of            `NULL` sets it to the current timestamp.            For `t2` and `t3`,            `ts1` permits `NULL` and            assigning it a value of `NULL` sets it to            `NULL`.          
- ​            `t2` and `t3` differ in            the default value for `ts1`. For            `t2`, `ts1` is defined to            permit `NULL`, so the default is also            `NULL` in the absence of an explicit            `DEFAULT` clause. For            `t3`, `ts1` permits            `NULL` but has an explicit default of 0.

#### TIMESTAMP Initialization and the NULL Attribute

​        By default, [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) columns are        `NOT NULL`, cannot contain        `NULL` values, and assigning        `NULL` assigns the current timestamp. To permit        a [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) column to contain        `NULL`, explicitly declare it with the        `NULL` attribute. In this case, the default        value also becomes `NULL` unless overridden        with a `DEFAULT` clause that specifies a        different default value. `DEFAULT NULL` can be        used to explicitly specify `NULL` as the        default value. (For a [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime)        column not declared with the `NULL` attribute,        `DEFAULT NULL` is invalid.) If a        [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) column permits        `NULL` values, assigning        `NULL` sets it to `NULL`, not        to the current timestamp.      

​        The following table contains several        [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) columns that permit        `NULL` values:      

```
CREATE TABLE t
(
  ts1 TIMESTAMP NULL DEFAULT NULL,
  ts2 TIMESTAMP NULL DEFAULT 0,
  ts3 TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP
);

```

​        A [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) column that permits        `NULL` values does *not*        take on the current timestamp at insert time except under one of        the following conditions:

- ​            Its default value is defined as            [`CURRENT_TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-timestamp) and no            value is specified for the column          
- ​            [`CURRENT_TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-timestamp) or any of            its synonyms such as [`NOW()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_now) is            explicitly inserted into the column

​        In other words, a [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime)        column defined to permit `NULL` values        auto-initializes only if its definition includes        `DEFAULT CURRENT_TIMESTAMP`:      

```
CREATE TABLE t (ts TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP);

```

​        If the [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) column permits        `NULL` values but its definition does not        include `DEFAULT CURRENT_TIMESTAMP`, you must        explicitly insert a value corresponding to the current date and        time. Suppose that tables `t1` and        `t2` have these definitions:      

```
CREATE TABLE t1 (ts TIMESTAMP NULL DEFAULT '0000-00-00 00:00:00');
CREATE TABLE t2 (ts TIMESTAMP NULL DEFAULT NULL);

```

​        To set the [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) column in        either table to the current timestamp at insert time, explicitly        assign it that value. For example:      

```
INSERT INTO t2 VALUES (CURRENT_TIMESTAMP);
INSERT INTO t1 VALUES (NOW());

```

### 11.3.6 Fractional Seconds in Time Values

​        A trailing fractional seconds part is permissible for temporal        values in contexts such as literal values, and in the arguments        to or return values from some temporal functions. Example:      

```
mysql> SELECT MICROSECOND('2010-12-10 14:12:09.019473');
+-------------------------------------------+
| MICROSECOND('2010-12-10 14:12:09.019473') |
+-------------------------------------------+
|                                     19473 |
+-------------------------------------------+

```

​        However, when MySQL stores a value into a column of any temporal        data type, it discards any fractional part and does not store        it.

### 11.3.7 Conversion Between Date and Time Types

​        To some extent, you can convert a value from one temporal type        to another. However, there may be some alteration of the value        or loss of information. In all cases, conversion between        temporal types is subject to the range of valid values for the        resulting type. For example, although        [`DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime),        [`DATETIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime), and        [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) values all can be        specified using the same set of formats, the types do not all        have the same range of values.        [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) values cannot be        earlier than `1970` UTC or later than        `'2038-01-19 03:14:07'` UTC. This means that a        date such as `'1968-01-01'`, while valid as a        [`DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) or        [`DATETIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) value, is not valid as a        [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) value and is converted        to `0`.      

​        Conversion of [`DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) values:

- ​            Conversion to a [`DATETIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) or            [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) value adds a time            part of `'00:00:00'` because the            [`DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) value contains no time            information.          
- ​            Conversion to a [`TIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#time) value is            not useful; the result is `'00:00:00'`.

​        Conversion of [`DATETIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) and        [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) values:

- ​            Conversion to a [`DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) value            discards the time part because the            [`DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) type contains no time            information.          
- ​            Conversion to a [`TIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#time) value            discards the date part because the            [`TIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#time) type contains no date            information.

​        Conversion of [`TIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#time) values:      

​        MySQL converts a time value to a date or date-and-time value by        parsing the string value of the time as a date or date-and-time.        This is unlikely to be useful. For example,        `'23:12:31'` interpreted as a date becomes        `'2023-12-31'`. Time values not valid as dates        become `'0000-00-00'` or        `NULL`.      

​        Explicit conversion can be used to override implicit conversion.        For example, in comparison of        [`DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) and        [`DATETIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) values, the        [`DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) value is coerced to the        [`DATETIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) type by adding a time        part of `'00:00:00'`. To perform the comparison        by ignoring the time part of the        [`DATETIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) value instead, use the        [`CAST()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_cast) function in the following        way:      

```
date_col = CAST(datetime_col AS DATE)

```

​        Conversion of [`TIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#time) or        [`DATETIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) values to numeric form        (for example, by adding `+0`) results in a        double-precision value with a microseconds part of        `.000000`:      

```
mysql> SELECT CURTIME(), CURTIME()+0;
+-----------+---------------+
| CURTIME() | CURTIME()+0   |
+-----------+---------------+
| 10:41:36  | 104136.000000 |
+-----------+---------------+
mysql> SELECT NOW(), NOW()+0;
+---------------------+-----------------------+
| NOW()               | NOW()+0               |
+---------------------+-----------------------+
| 2007-11-30 10:41:47 | 20071130104147.000000 |
+---------------------+-----------------------+

```

### 11.3.8 Two-Digit Years in Dates

​        Date values with two-digit years are ambiguous because the        century is unknown. Such values must be interpreted into        four-digit form because MySQL stores years internally using four        digits.      

​        For [`DATETIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime),        [`DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime), and        [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) types, MySQL interprets        dates specified with ambiguous year values using these rules:

- ​            Year values in the range `00-69` are            converted to `2000-2069`.          
- ​            Year values in the range `70-99` are            converted to `1970-1999`.

​        For `YEAR`, the rules are the same, with this        exception: A numeric `00` inserted into        `YEAR(4)` results in `0000`        rather than `2000`. To specify zero for        `YEAR(4)` and have it be interpreted as        `2000`, specify it as a string        `'0'` or `'00'`.      

​        Remember that these rules are only heuristics that provide        reasonable guesses as to what your data values mean. If the        rules used by MySQL do not produce the values you require, you        must provide unambiguous input containing four-digit year        values.      

​        `ORDER BY` properly sorts        [`YEAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) values that have two-digit        years.      

​        Some functions like [`MIN()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_min) and        [`MAX()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_max) convert a        [`YEAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) to a number. This means that        a value with a two-digit year does not work properly with these        functions. The fix in this case is to convert the        [`YEAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) to four-digit year format.

## 11.4 String Types

- [11.4.1 The CHAR and VARCHAR Types](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char)
- [11.4.2 The BINARY and VARBINARY Types](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary)
- [11.4.3 The BLOB and TEXT Types](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob)
- [11.4.4 The ENUM Type](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum)
- [11.4.5 The SET Type](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#set)

​      The string types are [`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),      [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),      [`BINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary),      [`VARBINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary),      [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob),      [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob),      [`ENUM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum), and      [`SET`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#set). This section describes how      these types work and how to use them in your queries. For string      type storage requirements, see      [Section 11.7, “Data Type Storage Requirements”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#storage-requirements).

### 11.4.1 The CHAR and VARCHAR Types

​        The `CHAR` and `VARCHAR` types        are similar, but differ in the way they are stored and        retrieved. They also differ in maximum length and in whether        trailing spaces are retained.      

​        The `CHAR` and `VARCHAR` types        are declared with a length that indicates the maximum number of        characters you want to store. For example,        `CHAR(30)` can hold up to 30 characters.      

​        The length of a `CHAR` column is fixed to the        length that you declare when you create the table. The length        can be any value from 0 to 255. When `CHAR`        values are stored, they are right-padded with spaces to the        specified length. When `CHAR` values are        retrieved, trailing spaces are removed unless the        [`PAD_CHAR_TO_FULL_LENGTH`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_pad_char_to_full_length) SQL        mode is enabled.      

​        Values in `VARCHAR` columns are variable-length        strings. The length can be specified as a value from 0 to        65,535. The effective maximum length of a        `VARCHAR` is subject to the maximum row size        (65,535 bytes, which is shared among all columns) and the        character set used. See [Section C.10.4, “Limits on Table Column Count and Row Size”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/restrictions.html#column-count-limit).      

​        In contrast to `CHAR`,        `VARCHAR` values are stored as a 1-byte or        2-byte length prefix plus data. The length prefix indicates the        number of bytes in the value. A column uses one length byte if        values require no more than 255 bytes, two length bytes if        values may require more than 255 bytes.      

​        If strict SQL mode is not enabled and you assign a value to a        `CHAR` or `VARCHAR` column        that exceeds the column's maximum length, the value is truncated        to fit and a warning is generated. For truncation of nonspace        characters, you can cause an error to occur (rather than a        warning) and suppress insertion of the value by using strict SQL        mode. See [Section 5.1.8, “Server SQL Modes”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sql-mode).      

​        For `VARCHAR` columns, trailing spaces in        excess of the column length are truncated prior to insertion and        a warning is generated, regardless of the SQL mode in use. For        `CHAR` columns, truncation of excess trailing        spaces from inserted values is performed silently regardless of        the SQL mode.      

​        `VARCHAR` values are not padded when they are        stored. Trailing spaces are retained when values are stored and        retrieved, in conformance with standard SQL.      

​        The following table illustrates the differences between        `CHAR` and `VARCHAR` by        showing the result of storing various string values into        `CHAR(4)` and `VARCHAR(4)`        columns (assuming that the column uses a single-byte character        set such as `latin1`).

| Value        | `CHAR(4)` | Storage Required | `VARCHAR(4)` | Storage Required |
| ------------ | --------- | ---------------- | ------------ | ---------------- |
| `''`         | `'    '`  | 4 bytes          | `''`         | 1 byte           |
| `'ab'`       | `'ab  '`  | 4 bytes          | `'ab'`       | 3 bytes          |
| `'abcd'`     | `'abcd'`  | 4 bytes          | `'abcd'`     | 5 bytes          |
| `'abcdefgh'` | `'abcd'`  | 4 bytes          | `'abcd'`     | 5 bytes          |

​        The values shown as stored in the last row of the table apply        *only when not using strict mode*; if MySQL        is running in strict mode, values that exceed the column length        are *not stored*, and an error results.      

​        `InnoDB` encodes fixed-length fields greater        than or equal to 768 bytes in length as variable-length fields,        which can be stored off-page. For example, a        `CHAR(255)` column can exceed 768 bytes if the        maximum byte length of the character set is greater than 3, as        it is with `utf8mb4`.      

​        If a given value is stored into the `CHAR(4)`        and `VARCHAR(4)` columns, the values retrieved        from the columns are not always the same because trailing spaces        are removed from `CHAR` columns upon retrieval.        The following example illustrates this difference:      

```
mysql> CREATE TABLE vc (v VARCHAR(4), c CHAR(4));
Query OK, 0 rows affected (0.01 sec)

mysql> INSERT INTO vc VALUES ('ab  ', 'ab  ');
Query OK, 1 row affected (0.00 sec)

mysql> SELECT CONCAT('(', v, ')'), CONCAT('(', c, ')') FROM vc;
+---------------------+---------------------+
| CONCAT('(', v, ')') | CONCAT('(', c, ')') |
+---------------------+---------------------+
| (ab  )              | (ab)                |
+---------------------+---------------------+
1 row in set (0.06 sec)

```

​        Values in `CHAR` and `VARCHAR`        columns are sorted and compared according to the character set        collation assigned to the column.      

​        All MySQL collations are of type PAD SPACE. This means that all        `CHAR`, `VARCHAR`, and        `TEXT` values are compared without regard to        any trailing spaces. “Comparison” in this context        does not include the [`LIKE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#operator_like)        pattern-matching operator, for which trailing spaces are        significant. For example:      

```
mysql> CREATE TABLE names (myname CHAR(10));
Query OK, 0 rows affected (0.03 sec)

mysql> INSERT INTO names VALUES ('Monty');
Query OK, 1 row affected (0.00 sec)

mysql> SELECT myname = 'Monty', myname = 'Monty  ' FROM names;
+------------------+--------------------+
| myname = 'Monty' | myname = 'Monty  ' |
+------------------+--------------------+
|                1 |                  1 |
+------------------+--------------------+
1 row in set (0.00 sec)

mysql> SELECT myname LIKE 'Monty', myname LIKE 'Monty  ' FROM names;
+---------------------+-----------------------+
| myname LIKE 'Monty' | myname LIKE 'Monty  ' |
+---------------------+-----------------------+
|                   1 |                     0 |
+---------------------+-----------------------+
1 row in set (0.00 sec)

```

​        This is true for all MySQL versions, and is not affected by the        server SQL mode.

Note

​          For more information about MySQL character sets and          collations, see [Section 10.1, “Character Set Support”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/globalization.html#charset). For additional          information about storage requirements, see          [Section 11.7, “Data Type Storage Requirements”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#storage-requirements).

​        For those cases where trailing pad characters are stripped or        comparisons ignore them, if a column has an index that requires        unique values, inserting into the column values that differ only        in number of trailing pad characters will result in a        duplicate-key error. For example, if a table contains        `'a'`, an attempt to store        `'a '` causes a duplicate-key error.

### 11.4.2 The BINARY and VARBINARY Types

​        The `BINARY` and `VARBINARY`        types are similar to [`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) and        [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char), except that they contain        binary strings rather than nonbinary strings. That is, they        contain byte strings rather than character strings. This means        they have the `binary` character set and        collation, and comparison and sorting are based on the numeric        values of the bytes in the values.      

​        The permissible maximum length is the same for        `BINARY` and `VARBINARY` as it        is for [`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) and        [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char), except that the length        for `BINARY` and `VARBINARY`        is a length in bytes rather than in characters.      

​        The `BINARY` and `VARBINARY`        data types are distinct from the `CHAR BINARY`        and `VARCHAR BINARY` data types. For the latter        types, the `BINARY` attribute does not cause        the column to be treated as a binary string column. Instead, it        causes the binary (`_bin`) collation for the        column character set to be used, and the column itself contains        nonbinary character strings rather than binary byte strings. For        example, `CHAR(5) BINARY` is treated as        `CHAR(5) CHARACTER SET latin1 COLLATE        latin1_bin`, assuming that the default character set is        `latin1`. This differs from        `BINARY(5)`, which stores 5-bytes binary        strings that have the `binary` character set        and collation. For information about differences between binary        strings and binary collations for nonbinary strings, see        [Section 10.1.8.5, “The binary Collation Compared to _bin Collations”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/globalization.html#charset-binary-collations).      

​        If strict SQL mode is not enabled and you assign a value to a        `BINARY` or `VARBINARY` column        that exceeds the column's maximum length, the value is truncated        to fit and a warning is generated. For cases of truncation, you        can cause an error to occur (rather than a warning) and suppress        insertion of the value by using strict SQL mode. See        [Section 5.1.8, “Server SQL Modes”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sql-mode).      

​        When `BINARY` values are stored, they are        right-padded with the pad value to the specified length. The pad        value is `0x00` (the zero byte). Values are        right-padded with `0x00` on insert, and no        trailing bytes are removed on select. All bytes are significant        in comparisons, including `ORDER BY` and        `DISTINCT` operations. `0x00`        bytes and spaces are different in comparisons, with        `0x00` < space.      

​        Example: For a `BINARY(3)` column,        `'a '` becomes        `'a \0'` when inserted.        `'a\0'` becomes `'a\0\0'` when        inserted. Both inserted values remain unchanged when selected.      

​        For `VARBINARY`, there is no padding on insert        and no bytes are stripped on select. All bytes are significant        in comparisons, including `ORDER BY` and        `DISTINCT` operations. `0x00`        bytes and spaces are different in comparisons, with        `0x00` < space.      

​        For those cases where trailing pad bytes are stripped or        comparisons ignore them, if a column has an index that requires        unique values, inserting into the column values that differ only        in number of trailing pad bytes will result in a duplicate-key        error. For example, if a table contains `'a'`,        an attempt to store `'a\0'` causes a        duplicate-key error.      

​        You should consider the preceding padding and stripping        characteristics carefully if you plan to use the        `BINARY` data type for storing binary data and        you require that the value retrieved be exactly the same as the        value stored. The following example illustrates how        `0x00`-padding of `BINARY`        values affects column value comparisons:      

```
mysql> CREATE TABLE t (c BINARY(3));
Query OK, 0 rows affected (0.01 sec)

mysql> INSERT INTO t SET c = 'a';
Query OK, 1 row affected (0.01 sec)

mysql> SELECT HEX(c), c = 'a', c = 'a\0\0' from t;
+--------+---------+-------------+
| HEX(c) | c = 'a' | c = 'a\0\0' |
+--------+---------+-------------+
| 610000 |       0 |           1 |
+--------+---------+-------------+
1 row in set (0.09 sec)

```

​        If the value retrieved must be the same as the value specified        for storage with no padding, it might be preferable to use        `VARBINARY` or one of the        [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) data types instead.

### 11.4.3 The BLOB and TEXT Types

​        A `BLOB` is a binary large object that can hold        a variable amount of data. The four `BLOB`        types are `TINYBLOB`, `BLOB`,        `MEDIUMBLOB`, and `LONGBLOB`.        These differ only in the maximum length of the values they can        hold. The four `TEXT` types are        `TINYTEXT`, `TEXT`,        `MEDIUMTEXT`, and `LONGTEXT`.        These correspond to the four `BLOB` types and        have the same maximum lengths and storage requirements. See        [Section 11.7, “Data Type Storage Requirements”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#storage-requirements).      

​        `BLOB` values are treated as binary strings        (byte strings). They have the `binary`        character set and collation, and comparison and sorting are        based on the numeric values of the bytes in column values.        `TEXT` values are treated as nonbinary strings        (character strings). They have a character set other than        `binary`, and values are sorted and compared        based on the collation of the character set.      

​        If strict SQL mode is not enabled and you assign a value to a        `BLOB` or `TEXT` column that        exceeds the column's maximum length, the value is truncated to        fit and a warning is generated. For truncation of nonspace        characters, you can cause an error to occur (rather than a        warning) and suppress insertion of the value by using strict SQL        mode. See [Section 5.1.8, “Server SQL Modes”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sql-mode).      

​        Truncation of excess trailing spaces from values to be inserted        into [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) columns always        generates a warning, regardless of the SQL mode.      

​        For `TEXT` and `BLOB` columns,        there is no padding on insert and no bytes are stripped on        select.      

​        If a `TEXT` column is indexed, index entry        comparisons are space-padded at the end. This means that, if the        index requires unique values, duplicate-key errors will occur        for values that differ only in the number of trailing spaces.        For example, if a table contains `'a'`, an        attempt to store `'a '` causes a        duplicate-key error. This is not true for        `BLOB` columns.      

​        In most respects, you can regard a `BLOB`        column as a [`VARBINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary) column that        can be as large as you like. Similarly, you can regard a        `TEXT` column as a        [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) column.        `BLOB` and `TEXT` differ from        [`VARBINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary) and        [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) in the following ways:

- ​            For indexes on `BLOB` and            `TEXT` columns, you must specify an index            prefix length. For [`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) and            [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char), a prefix length is            optional. See [Section 8.3.4, “Column Indexes”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/optimization.html#column-indexes).          
- ​                                                `BLOB` and `TEXT` columns            cannot have `DEFAULT` values.

​        If you use the `BINARY` attribute with a        `TEXT` data type, the column is assigned the        binary (`_bin`) collation of the column        character set.      

​        `LONG` and `LONG VARCHAR` map        to the `MEDIUMTEXT` data type. This is a        compatibility feature.      

​        MySQL Connector/ODBC defines `BLOB` values as        `LONGVARBINARY` and `TEXT`        values as `LONGVARCHAR`.      

​        Because `BLOB` and `TEXT`        values can be extremely long, you might encounter some        constraints in using them:

- ​            Only the first            [`max_sort_length`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_max_sort_length) bytes of            the column are used when sorting. The default value of            [`max_sort_length`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_max_sort_length) is 1024.            You can make more bytes significant in sorting or grouping            by increasing the value of            [`max_sort_length`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_max_sort_length) at server            startup or runtime. Any client can change the value of its            session [`max_sort_length`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_max_sort_length)            variable:          

  ```
  mysql> SET max_sort_length = 2000;
  mysql> SELECT id, comment FROM t
      -> ORDER BY comment;

  ```

- ​            Instances of `BLOB` or            `TEXT` columns in the result of a query            that is processed using a temporary table causes the server            to use a table on disk rather than in memory because the            `MEMORY` storage engine does not support            those data types (see            [Section 8.4.4, “Internal Temporary Table Use in MySQL”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/optimization.html#internal-temporary-tables)). Use of disk            incurs a performance penalty, so include            `BLOB` or `TEXT` columns            in the query result only if they are really needed. For            example, avoid using            [`SELECT *`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select),            which selects all columns.          

- ​            The maximum size of a `BLOB` or            `TEXT` object is determined by its type,            but the largest value you actually can transmit between the            client and server is determined by the amount of available            memory and the size of the communications buffers. You can            change the message buffer size by changing the value of the            [`max_allowed_packet`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_max_allowed_packet)            variable, but you must do so for both the server and your            client program. For example, both [**mysql**](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/programs.html#mysql)            and [**mysqldump**](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/programs.html#mysqldump) enable you to change the            client-side            [`max_allowed_packet`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_max_allowed_packet) value.            See [Section 5.1.1, “Configuring the Server”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#server-configuration),            [Section 4.5.1, “**mysql** — The MySQL Command-Line Tool”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/programs.html#mysql), and [Section 4.5.4, “**mysqldump** — A Database Backup Program”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/programs.html#mysqldump).            You may also want to compare the packet sizes and the size            of the data objects you are storing with the storage            requirements, see [Section 11.7, “Data Type Storage Requirements”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#storage-requirements)

​        Each `BLOB` or `TEXT` value is        represented internally by a separately allocated object. This is        in contrast to all other data types, for which storage is        allocated once per column when the table is opened.      

​        In some cases, it may be desirable to store binary data such as        media files in `BLOB` or        `TEXT` columns. You may find MySQL's string        handling functions useful for working with such data. See        [Section 12.5, “String Functions”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#string-functions). For security and other        reasons, it is usually preferable to do so using application        code rather than giving application users the        [`FILE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_file) privilege. You can discuss        specifics for various languages and platforms in the MySQL        Forums (<http://forums.mysql.com/>).

### 11.4.4 The ENUM Type

​        An `ENUM` is a string object with a value        chosen from a list of permitted values that are enumerated        explicitly in the column specification at table creation time.        It has these advantages:

- ​            Compact data storage in situations where a column has a            limited set of possible values. The strings you specify as            input values are automatically encoded as numbers. See            [Section 11.7, “Data Type Storage Requirements”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#storage-requirements) for the storage            requirements for `ENUM` types.          
- ​            Readable queries and output. The numbers are translated back            to the corresponding strings in query results.

​        and these potential issues to consider:

- ​            If you make enumeration values that look like numbers, it is            easy to mix up the literal values with their internal index            numbers, as explained in [Enumeration Limitations](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum-limits).          
- ​            Using `ENUM` columns in `ORDER            BY` clauses requires extra care, as explained in            [Enumeration Sorting](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum-sorting).


- [Creating and Using ENUM Columns](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum-using)
- [Index Values for Enumeration Literals](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum-indexes)
- [Handling of Enumeration Literals](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum-literals)
- [Empty or NULL Enumeration Values](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum-nulls)
- [Enumeration Sorting](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum-sorting)
- [Enumeration Limitations](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum-limits)

#### Creating and Using ENUM Columns

​          An enumeration value must be a quoted string literal. For          example, you can create a table with an          `ENUM` column like this:        

```
CREATE TABLE shirts (
    name VARCHAR(40),
    size ENUM('x-small', 'small', 'medium', 'large', 'x-large')
);
INSERT INTO shirts (name, size) VALUES ('dress shirt','large'), ('t-shirt','medium'),
  ('polo shirt','small');
SELECT name, size FROM shirts WHERE size = 'medium';
+---------+--------+
| name    | size   |
+---------+--------+
| t-shirt | medium |
+---------+--------+
UPDATE shirts SET size = 'small' WHERE size = 'large';
COMMIT;

```

​          Inserting 1 million rows into this table with a value of          `'medium'` would require 1 million bytes of          storage, as opposed to 6 million bytes if you stored the          actual string `'medium'` in a          `VARCHAR` column.

#### Index Values for Enumeration Literals

​          Each enumeration value has an index:

- ​              The elements listed in the column specification are              assigned index numbers, beginning with 1.            

- ​              The index value of the empty string error value is 0. This              means that you can use the following              [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement to find              rows into which invalid `ENUM` values              were assigned:            

  ```
  mysql> SELECT * FROM tbl_name WHERE enum_col=0;

  ```

- ​              The index of the `NULL` value is              `NULL`.            

- ​              The term “index” here refers to a position              within the list of enumeration values. It has nothing to              do with table indexes.

​          For example, a column specified as `ENUM('Mercury',          'Venus', 'Earth')` can have any of the values shown          here. The index of each value is also shown.

| Value       | Index  |
| ----------- | ------ |
| `NULL`      | `NULL` |
| `''`        | 0      |
| `'Mercury'` | 1      |
| `'Venus'`   | 2      |
| `'Earth'`   | 3      |

​          An [`ENUM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum) column can have a          maximum of 65,535 distinct elements. (The practical limit is          less than 3000.) A table can have no more than 255 unique          element list definitions among its          [`ENUM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum) and          [`SET`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#set) columns considered as a          group. For more information on these limits, see          [Section C.10.5, “Limits Imposed by .frm File Structure”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/restrictions.html#limits-frm-file).        

​          If you retrieve an `ENUM` value in a numeric          context, the column value's index is returned. For example,          you can retrieve numeric values from an          `ENUM` column like this:        

```
mysql> SELECT enum_col+0 FROM tbl_name;

```

​          Functions such as [`SUM()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_sum) or          [`AVG()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_avg) that expect a numeric          argument cast the argument to a number if necessary. For          `ENUM` values, the index number is used in          the calculation.

#### Handling of Enumeration Literals

​          Trailing spaces are automatically deleted from          `ENUM` member values in the table definition          when a table is created.        

​          When retrieved, values stored into an `ENUM`          column are displayed using the lettercase that was used in the          column definition. Note that `ENUM` columns          can be assigned a character set and collation. For binary or          case-sensitive collations, lettercase is taken into account          when assigning values to the column.        

​          If you store a number into an `ENUM` column,          the number is treated as the index into the possible values,          and the value stored is the enumeration member with that          index. (However, this does *not* work with          [`LOAD DATA`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#load-data), which treats all          input as strings.) If the numeric value is quoted, it is still          interpreted as an index if there is no matching string in the          list of enumeration values. For these reasons, it is not          advisable to define an `ENUM` column with          enumeration values that look like numbers, because this can          easily become confusing. For example, the following column has          enumeration members with string values of          `'0'`, `'1'`, and          `'2'`, but numeric index values of          `1`, `2`, and          `3`:        

```
numbers ENUM('0','1','2')

```

​          If you store `2`, it is interpreted as an          index value, and becomes `'1'` (the value          with index 2). If you store `'2'`, it matches          an enumeration value, so it is stored as          `'2'`. If you store `'3'`,          it does not match any enumeration value, so it is treated as          an index and becomes `'2'` (the value with          index 3).        

```
mysql> INSERT INTO t (numbers) VALUES(2),('2'),('3');
mysql> SELECT * FROM t;
+---------+
| numbers |
+---------+
| 1       |
| 2       |
| 2       |
+---------+

```

​          To determine all possible values for an          `ENUM` column, use          [`SHOW COLUMNS          FROM *tbl_name* LIKE          '*enum_col*'`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-columns) and parse the          `ENUM` definition in the          `Type` column of the output.        

​          In the C API, `ENUM` values are returned as          strings. For information about using result set metadata to          distinguish them from other strings, see          [Section 23.8.5, “C API Data Structures”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/connectors-apis.html#c-api-data-structures).

#### Empty or NULL Enumeration Values

​          An enumeration value can also be the empty string          (`''`) or `NULL` under          certain circumstances:

- ​              If you insert an invalid value into an              `ENUM` (that is, a string not present in              the list of permitted values), the empty string is              inserted instead as a special error value. This string can              be distinguished from a “normal” empty string              by the fact that this string has the numeric value 0. See              [Index Values for Enumeration Literals](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum-indexes) for details about the              numeric indexes for the enumeration values.            

  ​              If strict SQL mode is enabled, attempts to insert invalid              `ENUM` values result in an error.            

- ​              If an `ENUM` column is declared to permit              `NULL`, the `NULL` value              is a valid value for the column, and the default value is              `NULL`. If an `ENUM`              column is declared `NOT NULL`, its              default value is the first element of the list of              permitted values.

#### Enumeration Sorting

​          `ENUM` values are sorted based on their index          numbers, which depend on the order in which the enumeration          members were listed in the column specification. For example,          `'b'` sorts before `'a'` for          `ENUM('b', 'a')`. The empty string sorts          before nonempty strings, and `NULL` values          sort before all other enumeration values.        

​          To prevent unexpected results when using the `ORDER          BY` clause on an `ENUM` column, use          one of these techniques:

- ​              Specify the `ENUM` list in alphabetic              order.            
- ​              Make sure that the column is sorted lexically rather than              by index number by coding `ORDER BY              CAST(*col* AS CHAR)` or              `ORDER BY              CONCAT(*col*)`.

#### Enumeration Limitations

​          An enumeration value cannot be an expression, even one that          evaluates to a string value.        

​          For example, this [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table)          statement does *not* work because the          `CONCAT` function cannot be used to construct          an enumeration value:        

```
CREATE TABLE sizes (
    size ENUM('small', CONCAT('med','ium'), 'large')
);

```

​          You also cannot employ a user variable as an enumeration          value. This pair of statements do *not*          work:        

```
SET @mysize = 'medium';

CREATE TABLE sizes (
    size ENUM('small', @mysize, 'large')
);

```

​          We strongly recommend that you do *not* use          numbers as enumeration values, because it does not save on          storage over the appropriate          [`TINYINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) or          [`SMALLINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) type, and it is easy          to mix up the strings and the underlying number values (which          might not be the same) if you quote the          `ENUM` values incorrectly. If you do use a          number as an enumeration value, always enclose it in quotation          marks. If the quotation marks are omitted, the number is          regarded as an index. See [Handling of Enumeration Literals](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum-literals) to          see how even a quoted number could be mistakenly used as a          numeric index value.        

​          Duplicate values in the definition cause a warning, or an          error if strict SQL mode is enabled.

### 11.4.5 The SET Type

​        A `SET` is a string object that can have zero        or more values, each of which must be chosen from a list of        permitted values specified when the table is created.        `SET` column values that consist of multiple        set members are specified with members separated by commas        (`,`). A consequence of this is that        `SET` member values should not themselves        contain commas.      

​        For example, a column specified as `SET('one', 'two')        NOT NULL` can have any of these values:      

```
''
'one'
'two'
'one,two'

```

​        A [`SET`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#set) column can have a maximum        of 64 distinct members. A table can have no more than 255 unique        element list definitions among its        [`ENUM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum) and        [`SET`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#set) columns considered as a        group. For more information on this limit, see        [Section C.10.5, “Limits Imposed by .frm File Structure”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/restrictions.html#limits-frm-file).      

​        Duplicate values in the definition cause a warning, or an error        if strict SQL mode is enabled.      

​        Trailing spaces are automatically deleted from        `SET` member values in the table definition        when a table is created.      

​        When retrieved, values stored in a `SET` column        are displayed using the lettercase that was used in the column        definition. Note that `SET` columns can be        assigned a character set and collation. For binary or        case-sensitive collations, lettercase is taken into account when        assigning values to the column.      

​        MySQL stores `SET` values numerically, with the        low-order bit of the stored value corresponding to the first set        member. If you retrieve a `SET` value in a        numeric context, the value retrieved has bits set corresponding        to the set members that make up the column value. For example,        you can retrieve numeric values from a `SET`        column like this:      

```
mysql> SELECT set_col+0 FROM tbl_name;

```

​        If a number is stored into a `SET` column, the        bits that are set in the binary representation of the number        determine the set members in the column value. For a column        specified as `SET('a','b','c','d')`, the        members have the following decimal and binary values.

| `SET` Member | Decimal Value | Binary Value |
| ------------ | ------------- | ------------ |
| `'a'`        | `1`           | `0001`       |
| `'b'`        | `2`           | `0010`       |
| `'c'`        | `4`           | `0100`       |
| `'d'`        | `8`           | `1000`       |

​        If you assign a value of `9` to this column,        that is `1001` in binary, so the first and        fourth `SET` value members        `'a'` and `'d'` are selected        and the resulting value is `'a,d'`.      

​        For a value containing more than one `SET`        element, it does not matter what order the elements are listed        in when you insert the value. It also does not matter how many        times a given element is listed in the value. When the value is        retrieved later, each element in the value appears once, with        elements listed according to the order in which they were        specified at table creation time. For example, suppose that a        column is specified as `SET('a','b','c','d')`:      

```
mysql> CREATE TABLE myset (col SET('a', 'b', 'c', 'd'));

```

​        If you insert the values `'a,d'`,        `'d,a'`, `'a,d,d'`,        `'a,d,a'`, and `'d,a,d'`:      

```
mysql> INSERT INTO myset (col) VALUES 
-> ('a,d'), ('d,a'), ('a,d,a'), ('a,d,d'), ('d,a,d');
Query OK, 5 rows affected (0.01 sec)
Records: 5  Duplicates: 0  Warnings: 0

```

​        Then all these values appear as `'a,d'` when        retrieved:      

```
mysql> SELECT col FROM myset;
+------+
| col  |
+------+
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
+------+
5 rows in set (0.04 sec)

```

​        If you set a `SET` column to an unsupported        value, the value is ignored and a warning is issued:      

```
mysql> INSERT INTO myset (col) VALUES ('a,d,d,s');
Query OK, 1 row affected, 1 warning (0.03 sec)

mysql> SHOW WARNINGS;
+---------+------+------------------------------------------+
| Level   | Code | Message                                  |
+---------+------+------------------------------------------+
| Warning | 1265 | Data truncated for column 'col' at row 1 |
+---------+------+------------------------------------------+
1 row in set (0.04 sec)

mysql> SELECT col FROM myset;
+------+
| col  |
+------+
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
+------+
6 rows in set (0.01 sec)

```

​        If strict SQL mode is enabled, attempts to insert invalid        `SET` values result in an error.      

​        `SET` values are sorted numerically.        `NULL` values sort before        non-`NULL` `SET` values.      

​        Functions such as [`SUM()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_sum) or        [`AVG()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_avg) that expect a numeric        argument cast the argument to a number if necessary. For        `SET` values, the cast operation causes the        numeric value to be used.      

​        Normally, you search for `SET` values using the        [`FIND_IN_SET()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_find-in-set) function or the        [`LIKE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#operator_like) operator:      

```
mysql> SELECT * FROM tbl_name WHERE FIND_IN_SET('value',set_col)>0;
mysql> SELECT * FROM tbl_name WHERE set_col LIKE '%value%';

```

​        The first statement finds rows where        *set_col* contains the        *value* set member. The second is        similar, but not the same: It finds rows where        *set_col* contains        *value* anywhere, even as a substring        of another set member.      

​        The following statements also are permitted:      

```
mysql> SELECT * FROM tbl_name WHERE set_col & 1;
mysql> SELECT * FROM tbl_name WHERE set_col = 'val1,val2';

```

​        The first of these statements looks for values containing the        first set member. The second looks for an exact match. Be        careful with comparisons of the second type. Comparing set        values to        `'*val1*,*val2*'`        returns different results than comparing values to        `'*val2*,*val1*'`.        You should specify the values in the same order they are listed        in the column definition.      

​        To determine all possible values for a `SET`        column, use `SHOW COLUMNS FROM        *tbl_name* LIKE        *set_col*` and parse the        `SET` definition in the `Type`        column of the output.      

​        In the C API, `SET` values are returned as        strings. For information about using result set metadata to        distinguish them from other strings, see        [Section 23.8.5, “C API Data Structures”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/connectors-apis.html#c-api-data-structures).

## 11.5 Spatial Data Types

- [11.5.1 Spatial Data Types](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#spatial-type-overview)
- [11.5.2 The OpenGIS Geometry Model](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#opengis-geometry-model)
- [11.5.3 Supported Spatial Data Formats](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#gis-data-formats)
- [11.5.4 Creating Spatial Columns](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#creating-spatial-columns)
- [11.5.5 Populating Spatial Columns](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#populating-spatial-columns)
- [11.5.6 Fetching Spatial Data](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fetching-spatial-data)
- [11.5.7 Optimizing Spatial Analysis](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#optimizing-spatial-analysis)
- [11.5.8 Creating Spatial Indexes](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#creating-spatial-indexes)
- [11.5.9 Using Spatial Indexes](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#using-spatial-indexes)

​      The Open Geospatial Consortium (OGC) is an international      consortium of more than 250 companies, agencies, and universities      participating in the development of publicly available conceptual      solutions that can be useful with all kinds of applications that      manage spatial data.    

​      The Open Geospatial Consortium publishes the      *OpenGIS® Implementation Standard for Geographic      information - Simple feature access - Part 2: SQL      option*, a document that proposes several conceptual      ways for extending an SQL RDBMS to support spatial data. This      specification is available from the OGC Web site at      <http://www.opengeospatial.org/standards/sfs>.    

​      Following the OGC specification, MySQL implements spatial      extensions as a subset of the **SQL with      Geometry Types** environment. This term refers to an SQL      environment that has been extended with a set of geometry types. A      geometry-valued SQL column is implemented as a column that has a      geometry type. The specification describes a set of SQL geometry      types, as well as functions on those types to create and analyze      geometry values.    

​      MySQL spatial extensions enable the generation, storage, and      analysis of geographic features:

- ​          Data types for representing spatial values        
- ​          Functions for manipulating spatial values        
- ​          Spatial indexing for improved access times to spatial columns

​      The spatial data types and functions are available for      [`MyISAM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#myisam-storage-engine),      [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html),      [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html), and      [`ARCHIVE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#archive-storage-engine) tables. For indexing spatial      columns, `MyISAM` supports both      `SPATIAL` and non-`SPATIAL`      indexes. The other storage engines support      non-`SPATIAL` indexes, as described in      [Section 13.1.13, “CREATE INDEX Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-index).    

​      A **geographic feature** is anything      in the world that has a location. A feature can be:

- ​          An entity. For example, a mountain, a pond, a city.        
- ​          A space. For example, town district, the tropics.        
- ​          A definable location. For example, a crossroad, as a          particular place where two streets intersect.

​      Some documents use the term **geospatial      feature** to refer to geographic features.    

​      **Geometry** is another word that      denotes a geographic feature. Originally the word      **geometry** meant measurement of the      earth. Another meaning comes from cartography, referring to the      geometric features that cartographers use to map the world.    

​      The discussion here considers these terms synonymous:      **geographic feature**,      **geospatial feature**,      **feature**, or      **geometry**. The term most commonly      used is **geometry**, defined as      *a point or an aggregate of points representing anything      in the world that has a location*.    

​      The following material covers these topics:

- ​          The spatial data types implemented in MySQL model        
- ​          The basis of the spatial extensions in the OpenGIS geometry          model        
- ​          Data formats for representing spatial data        
- ​          How to use spatial data in MySQL        
- ​          Use of indexing for spatial data        
- ​          MySQL differences from the OpenGIS specification

​      For information about functions that operate on spatial data, see      [Section 12.15, “Spatial Analysis Functions”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#spatial-analysis-functions).

### MySQL GIS Conformance and Compatibility

​      MySQL does not implement the following GIS features:

- ​          Additional Metadata Views        

  ​          OpenGIS specifications propose several additional metadata          views. For example, a system view named          `GEOMETRY_COLUMNS` contains a description of          geometry columns, one row for each geometry column in the          database.        

- ​          The OpenGIS function [`Length()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_length)          on `LineString` and          `MultiLineString` should be called in MySQL          as [`GLength()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_glength)        

  ​          The problem is that there is an existing SQL function          [`Length()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_length) that calculates the          length of string values, and sometimes it is not possible to          distinguish whether the function is called in a textual or          spatial context.

### Additional Resources

- ​          The Open Geospatial Consortium publishes the          *OpenGIS® Implementation Standard for Geographic          information - Simple feature access - Part 2: SQL          option*, a document that proposes several          conceptual ways for extending an SQL RDBMS to support spatial          data. The Open Geospatial Consortium (OGC) maintains a Web          site at <http://www.opengeospatial.org/>. The          specification is available there at          <http://www.opengeospatial.org/standards/sfs>. It          contains additional information relevant to the material here.        
- ​          If you have questions or concerns about the use of the spatial          extensions to MySQL, you can discuss them in the GIS forum:          <http://forums.mysql.com/list.php?23>.

### 11.5.1 Spatial Data Types

​        MySQL has spatial data types that correspond to OpenGIS classes.        The basis for these types is described in        [Section 11.5.2, “The OpenGIS Geometry Model”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#opengis-geometry-model).      

​        Some spatial data types hold single geometry values:

- ​            `GEOMETRY`          
- ​            `POINT`          
- ​            `LINESTRING`          
- ​            `POLYGON`

​        `GEOMETRY` can store geometry values of any        type. The other single-value types (`POINT`,        `LINESTRING`, and `POLYGON`)        restrict their values to a particular geometry type.      

​        The other spatial data types hold collections of values:

- ​            `MULTIPOINT`          
- ​            `MULTILINESTRING`          
- ​            `MULTIPOLYGON`          
- ​            `GEOMETRYCOLLECTION`

​        `GEOMETRYCOLLECTION` can store a collection of        objects of any type. The other collection types        (`MULTIPOINT`,        `MULTILINESTRING`,        `MULTIPOLYGON`, and        `GEOMETRYCOLLECTION`) restrict collection        members to those having a particular geometry type.      

​        Example: To create a table named `geom` that        has a column named `g` that can store values of        any geometry type, use this statement:      

```
CREATE TABLE geom (g GEOMETRY);

```

​        `SPATIAL` indexes can be created on        `NOT NULL` spatial columns, so if you plan to        index the column, declare it `NOT NULL`:      

```
CREATE TABLE geom (g GEOMETRY NOT NULL);

```

​        For other examples showing how to use spatial data types in        MySQL, see [Section 11.5.4, “Creating Spatial Columns”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#creating-spatial-columns).

### 11.5.2 The OpenGIS Geometry Model

- [11.5.2.1 The Geometry Class Hierarchy](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#gis-geometry-class-hierarchy)
- [11.5.2.2 Geometry Class](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#gis-class-geometry)
- [11.5.2.3 Point Class](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#gis-class-point)
- [11.5.2.4 Curve Class](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#gis-class-curve)
- [11.5.2.5 LineString Class](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#gis-class-linestring)
- [11.5.2.6 Surface Class](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#gis-class-surface)
- [11.5.2.7 Polygon Class](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#gis-class-polygon)
- [11.5.2.8 GeometryCollection Class](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#gis-class-geometrycollection)
- [11.5.2.9 MultiPoint Class](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#gis-class-multipoint)
- [11.5.2.10 MultiCurve Class](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#gis-class-multicurve)
- [11.5.2.11 MultiLineString Class](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#gis-class-multilinestring)
- [11.5.2.12 MultiSurface Class](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#gis-class-multisurface)
- [11.5.2.13 MultiPolygon Class](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#gis-class-multipolygon)

​        The set of geometry types proposed by OGC's        **SQL with Geometry Types**        environment is based on the **OpenGIS        Geometry Model**. In this model, each geometric object        has the following general properties:

- ​            It is associated with a spatial reference system, which            describes the coordinate space in which the object is            defined.          
- ​            It belongs to some geometry class.

#### 11.5.2.1 The Geometry Class Hierarchy

​          The geometry classes define a hierarchy as follows:

- ​              `Geometry` (noninstantiable)
  - ​                  `Point` (instantiable)                
  - ​                  `Curve` (noninstantiable)
    - ​                      `LineString` (instantiable)
      - ​                          `Line`                        
      - ​                          `LinearRing`
  - ​                  `Surface` (noninstantiable)
    - ​                      `Polygon` (instantiable)
  - ​                  `GeometryCollection` (instantiable)
    - ​                      `MultiPoint` (instantiable)                    
    - ​                      `MultiCurve` (noninstantiable)
      - ​                          `MultiLineString`                          (instantiable)
    - ​                      `MultiSurface` (noninstantiable)
      - ​                          `MultiPolygon` (instantiable)

​          It is not possible to create objects in noninstantiable          classes. It is possible to create objects in instantiable          classes. All classes have properties, and instantiable classes          may also have assertions (rules that define valid class          instances).        

​          `Geometry` is the base class. It is an          abstract class. The instantiable subclasses of          `Geometry` are restricted to zero-, one-, and          two-dimensional geometric objects that exist in          two-dimensional coordinate space. All instantiable geometry          classes are defined so that valid instances of a geometry          class are topologically closed (that is, all defined          geometries include their boundary).        

​          The base `Geometry` class has subclasses for          `Point`, `Curve`,          `Surface`, and          `GeometryCollection`:

- ​              `Point` represents zero-dimensional              objects.            
- ​              `Curve` represents one-dimensional              objects, and has subclass `LineString`,              with sub-subclasses `Line` and              `LinearRing`.            
- ​              `Surface` is designed for two-dimensional              objects and has subclass `Polygon`.            
- ​              `GeometryCollection` has specialized              zero-, one-, and two-dimensional collection classes named              `MultiPoint`,              `MultiLineString`, and              `MultiPolygon` for modeling geometries              corresponding to collections of `Points`,              `LineStrings`, and              `Polygons`, respectively.              `MultiCurve` and              `MultiSurface` are introduced as abstract              superclasses that generalize the collection interfaces to              handle `Curves` and              `Surfaces`.

​          `Geometry`, `Curve`,          `Surface`, `MultiCurve`, and          `MultiSurface` are defined as noninstantiable          classes. They define a common set of methods for their          subclasses and are included for extensibility.        

​          `Point`, `LineString`,          `Polygon`,          `GeometryCollection`,          `MultiPoint`,          `MultiLineString`, and          `MultiPolygon` are instantiable classes.

#### 11.5.2.2 Geometry Class

​          `Geometry` is the root class of the          hierarchy. It is a noninstantiable class but has a number of          properties, described in the following list, that are common          to all geometry values created from any of the          `Geometry` subclasses. Particular subclasses          have their own specific properties, described later.        

​          **Geometry Properties**        

​          A geometry value has the following properties:

- ​              Its **type**. Each geometry              belongs to one of the instantiable classes in the              hierarchy.            

- ​              Its **SRID**, or spatial              reference identifier. This value identifies the geometry's              associated spatial reference system that describes the              coordinate space in which the geometry object is defined.            

  ​              In MySQL, the SRID value is an integer associated with the              geometry value. The maximum usable SRID value is              232−1. If a larger value              is given, only the lower 32 bits are used. All              computations are done assuming SRID 0, regardless of the              actual SRID value. SRID 0 represents an infinite flat              Cartesian plane with no units assigned to its axes.            

- ​              Its **coordinates** in its              spatial reference system, represented as double-precision              (8-byte) numbers. All nonempty geometries include at least              one pair of (X,Y) coordinates. Empty geometries contain no              coordinates.            

  ​              Coordinates are related to the SRID. For example, in              different coordinate systems, the distance between two              objects may differ even when objects have the same              coordinates, because the distance on the              **planar** coordinate system              and the distance on the              **geodetic** system              (coordinates on the Earth's surface) are different things.            

- ​              Its **interior**,              **boundary**, and              **exterior**.            

  ​              Every geometry occupies some position in space. The              exterior of a geometry is all space not occupied by the              geometry. The interior is the space occupied by the              geometry. The boundary is the interface between the              geometry's interior and exterior.            

- ​              Its **MBR** (minimum bounding              rectangle), or envelope. This is the bounding geometry,              formed by the minimum and maximum (X,Y) coordinates:            

  ```
  ((MINX MINY, MAXX MINY, MAXX MAXY, MINX MAXY, MINX MINY))

  ```

- ​              Whether the value is              **simple** or              **nonsimple**. Geometry              values of types (`LineString`,              `MultiPoint`,              `MultiLineString`) are either simple or              nonsimple. Each type determines its own assertions for              being simple or nonsimple.            

- ​              Whether the value is              **closed** or              **not closed**. Geometry              values of types (`LineString`,              `MultiString`) are either closed or not              closed. Each type determines its own assertions for being              closed or not closed.            

- ​              Whether the value is              **empty** or              **nonempty** A geometry is              empty if it does not have any points. Exterior, interior,              and boundary of an empty geometry are not defined (that              is, they are represented by a `NULL`              value). An empty geometry is defined to be always simple              and has an area of 0.            

- ​              Its **dimension**. A geometry              can have a dimension of −1, 0, 1, or 2:

  - ​                  −1 for an empty geometry.                
  - ​                  0 for a geometry with no length and no area.                
  - ​                  1 for a geometry with nonzero length and zero area.                
  - ​                  2 for a geometry with nonzero area.

  ​              `Point` objects have a dimension of zero.              `LineString` objects have a dimension of              1. `Polygon` objects have a dimension of              2. The dimensions of `MultiPoint`,              `MultiLineString`, and              `MultiPolygon` objects are the same as              the dimensions of the elements they consist of.

#### 11.5.2.3 Point Class

​          A `Point` is a geometry that represents a          single location in coordinate space.        

​          **Point          Examples**

- ​              Imagine a large-scale map of the world with many cities. A              `Point` object could represent each city.            
- ​              On a city map, a `Point` object could              represent a bus stop.

​          **Point          Properties**

- ​              X-coordinate value.            
- ​              Y-coordinate value.            
- ​              `Point` is defined as a zero-dimensional              geometry.            
- ​              The boundary of a `Point` is the empty              set.

#### 11.5.2.4 Curve Class

​          A `Curve` is a one-dimensional geometry,          usually represented by a sequence of points. Particular          subclasses of `Curve` define the type of          interpolation between points. `Curve` is a          noninstantiable class.        

​          **Curve          Properties**

- ​              A `Curve` has the coordinates of its              points.            
- ​              A `Curve` is defined as a one-dimensional              geometry.            
- ​              A `Curve` is simple if it does not pass              through the same point twice, with the exception that a              curve can still be simple if the start and end points are              the same.            
- ​              A `Curve` is closed if its start point is              equal to its endpoint.            
- ​              The boundary of a closed `Curve` is              empty.            
- ​              The boundary of a nonclosed `Curve`              consists of its two endpoints.            
- ​              A `Curve` that is simple and closed is a              `LinearRing`.

#### 11.5.2.5 LineString Class

​          A `LineString` is a `Curve`          with linear interpolation between points.        

​          **LineString          Examples**

- ​              On a world map, `LineString` objects              could represent rivers.            
- ​              In a city map, `LineString` objects could              represent streets.

​          **LineString          Properties**

- ​              A `LineString` has coordinates of              segments, defined by each consecutive pair of points.            
- ​              A `LineString` is a              `Line` if it consists of exactly two              points.            
- ​              A `LineString` is a              `LinearRing` if it is both closed and              simple.

#### 11.5.2.6 Surface Class

​          A `Surface` is a two-dimensional geometry. It          is a noninstantiable class. Its only instantiable subclass is          `Polygon`.        

​          **Surface          Properties**

- ​              A `Surface` is defined as a              two-dimensional geometry.            
- ​              The OpenGIS specification defines a simple              `Surface` as a geometry that consists of              a single “patch” that is associated with a              single exterior boundary and zero or more interior              boundaries.            
- ​              The boundary of a simple `Surface` is the              set of closed curves corresponding to its exterior and              interior boundaries.

#### 11.5.2.7 Polygon Class

​          A `Polygon` is a planar          `Surface` representing a multisided geometry.          It is defined by a single exterior boundary and zero or more          interior boundaries, where each interior boundary defines a          hole in the `Polygon`.        

​          **Polygon          Examples**

- ​              On a region map, `Polygon` objects could              represent forests, districts, and so on.

​          **Polygon          Assertions**

- ​              The boundary of a `Polygon` consists of a              set of `LinearRing` objects (that is,              `LineString` objects that are both simple              and closed) that make up its exterior and interior              boundaries.            
- ​              A `Polygon` has no rings that cross. The              rings in the boundary of a `Polygon` may              intersect at a `Point`, but only as a              tangent.            
- ​              A `Polygon` has no lines, spikes, or              punctures.            
- ​              A `Polygon` has an interior that is a              connected point set.            
- ​              A `Polygon` may have holes. The exterior              of a `Polygon` with holes is not              connected. Each hole defines a connected component of the              exterior.

​          The preceding assertions make a `Polygon` a          simple geometry.

#### 11.5.2.8 GeometryCollection Class

​          A `GeometryCollection` is a geometry that is          a collection of one or more geometries of any class.        

​          All the elements in a `GeometryCollection`          must be in the same spatial reference system (that is, in the          same coordinate system). There are no other constraints on the          elements of a `GeometryCollection`, although          the subclasses of `GeometryCollection`          described in the following sections may restrict membership.          Restrictions may be based on:

- ​              Element type (for example, a `MultiPoint`              may contain only `Point` elements)            
- ​              Dimension            
- ​              Constraints on the degree of spatial overlap between              elements

#### 11.5.2.9 MultiPoint Class

​          A `MultiPoint` is a geometry collection          composed of `Point` elements. The points are          not connected or ordered in any way.        

​          **MultiPoint          Examples**

- ​              On a world map, a `MultiPoint` could              represent a chain of small islands.            
- ​              On a city map, a `MultiPoint` could              represent the outlets for a ticket office.

​          **MultiPoint          Properties**

- ​              A `MultiPoint` is a zero-dimensional              geometry.            
- ​              A `MultiPoint` is simple if no two of its              `Point` values are equal (have identical              coordinate values).            
- ​              The boundary of a `MultiPoint` is the              empty set.

#### 11.5.2.10 MultiCurve Class

​          A `MultiCurve` is a geometry collection          composed of `Curve` elements.          `MultiCurve` is a noninstantiable class.        

​          **MultiCurve          Properties**

- ​              A `MultiCurve` is a one-dimensional              geometry.            
- ​              A `MultiCurve` is simple if and only if              all of its elements are simple; the only intersections              between any two elements occur at points that are on the              boundaries of both elements.            
- ​              A `MultiCurve` boundary is obtained by              applying the “mod 2 union rule” (also known              as the “odd-even rule”): A point is in the              boundary of a `MultiCurve` if it is in              the boundaries of an odd number of              `Curve` elements.            
- ​              A `MultiCurve` is closed if all of its              elements are closed.            
- ​              The boundary of a closed `MultiCurve` is              always empty.

#### 11.5.2.11 MultiLineString Class

​          A `MultiLineString` is a          `MultiCurve` geometry collection composed of          `LineString` elements.        

​          **MultiLineString          Examples**

- ​              On a region map, a `MultiLineString`              could represent a river system or a highway system.

#### 11.5.2.12 MultiSurface Class

​          A `MultiSurface` is a geometry collection          composed of surface elements. `MultiSurface`          is a noninstantiable class. Its only instantiable subclass is          `MultiPolygon`.        

​          **MultiSurface          Assertions**

- ​              Surfaces within a `MultiSurface` have no              interiors that intersect.            
- ​              Surfaces within a `MultiSurface` have              boundaries that intersect at most at a finite number of              points.

#### 11.5.2.13 MultiPolygon Class

​          A `MultiPolygon` is a          `MultiSurface` object composed of          `Polygon` elements.        

​          **MultiPolygon          Examples**

- ​              On a region map, a `MultiPolygon` could              represent a system of lakes.

​          **MultiPolygon          Assertions**

- ​              A `MultiPolygon` has no two              `Polygon` elements with interiors that              intersect.            
- ​              A `MultiPolygon` has no two              `Polygon` elements that cross (crossing              is also forbidden by the previous assertion), or that              touch at an infinite number of points.            
- ​              A `MultiPolygon` may not have cut lines,              spikes, or punctures. A `MultiPolygon` is              a regular, closed point set.            
- ​              A `MultiPolygon` that has more than one              `Polygon` has an interior that is not              connected. The number of connected components of the              interior of a `MultiPolygon` is equal to              the number of `Polygon` values in the              `MultiPolygon`.

​          **MultiPolygon          Properties**

- ​              A `MultiPolygon` is a two-dimensional              geometry.            
- ​              A `MultiPolygon` boundary is a set of              closed curves (`LineString` values)              corresponding to the boundaries of its              `Polygon` elements.            
- ​              Each `Curve` in the boundary of the              `MultiPolygon` is in the boundary of              exactly one `Polygon` element.            
- ​              Every `Curve` in the boundary of an              `Polygon` element is in the boundary of              the `MultiPolygon`.

### 11.5.3 Supported Spatial Data Formats

​        Two standard spatial data formats are used to represent geometry        objects in queries:

- ​            Well-Known Text (WKT) format          
- ​            Well-Known Binary (WKB) format

​        Internally, MySQL stores geometry values in a format that is not        identical to either WKT or WKB format. (Internal format is like        WKB but with an initial 4 bytes to indicate the SRID.)      

​        There are functions available to convert between different data        formats; see [Section 12.15.6, “Geometry Format Conversion Functions”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#gis-format-conversion-functions).      

​        The following sections describe the spatial data formats MySQL        uses:

- [Well-Known Text (WKT) Format](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#gis-wkt-format)
- [Well-Known Binary (WKB) Format](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#gis-wkb-format)
- [Internal Geometry Storage Format](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#gis-internal-format)

#### Well-Known Text (WKT) Format

​          The Well-Known Text (WKT) representation of geometry values is          designed for exchanging geometry data in ASCII form. The          OpenGIS specification provides a Backus-Naur grammar that          specifies the formal production rules for writing WKT values          (see [Section 11.5, “Spatial Data Types”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#spatial-types)).        

​          Examples of WKT representations of geometry objects:

- ​              A `Point`:            

  ```
  POINT(15 20)

  ```

  ​              The point coordinates are specified with no separating              comma. This differs from the syntax for the SQL              [`Point()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_point) function, which              requires a comma between the coordinates. Take care to use              the syntax appropriate to the context of a given spatial              operation. For example, the following statements both use              [`X()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_x) to extract the              X-coordinate from a `Point` object. The              first produces the object directly using the              [`Point()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_point) function. The              second uses a WKT representation converted to a              `Point` with              [`GeomFromText()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_geomfromtext).            

  ```
  mysql> SELECT X(Point(15, 20));
  +------------------+
  | X(POINT(15, 20)) |
  +------------------+
  |               15 |
  +------------------+

  mysql> SELECT X(GeomFromText('POINT(15 20)'));
  +---------------------------------+
  | X(GeomFromText('POINT(15 20)')) |
  +---------------------------------+
  |                              15 |
  +---------------------------------+

  ```

- ​              A `LineString` with four points:            

  ```
  LINESTRING(0 0, 10 10, 20 25, 50 60)

  ```

  ​              The point coordinate pairs are separated by commas.            

- ​              A `Polygon` with one exterior ring and              one interior ring:            

  ```
  POLYGON((0 0,10 0,10 10,0 10,0 0),(5 5,7 5,7 7,5 7, 5 5))

  ```

- ​              A `MultiPoint` with three              `Point` values:            

  ```
  MULTIPOINT(0 0, 20 20, 60 60)

  ```

- ​              A `MultiLineString` with two              `LineString` values:            

  ```
  MULTILINESTRING((10 10, 20 20), (15 15, 30 15))

  ```

- ​              A `MultiPolygon` with two              `Polygon` values:            

  ```
  MULTIPOLYGON(((0 0,10 0,10 10,0 10,0 0)),((5 5,7 5,7 7,5 7, 5 5)))

  ```

- ​              A `GeometryCollection` consisting of two              `Point` values and one              `LineString`:            

  ```
  GEOMETRYCOLLECTION(POINT(10 10), POINT(30 30), LINESTRING(15 15, 20 20))

  ```

#### Well-Known Binary (WKB) Format

​          The Well-Known Binary (WKB) representation of geometric values          is used for exchanging geometry data as binary streams          represented by [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) values          containing geometric WKB information. This format is defined          by the OpenGIS specification (see          [Section 11.5, “Spatial Data Types”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#spatial-types)). It is also defined in the          ISO *SQL/MM Part 3: Spatial* standard.        

​          WKB uses 1-byte unsigned integers, 4-byte unsigned integers,          and 8-byte double-precision numbers (IEEE 754 format). A byte          is eight bits.        

​          For example, a WKB value that corresponds to `POINT(1          -1)` consists of this sequence of 21 bytes, each          represented by two hexadecimal digits:        

```
0101000000000000000000F03F000000000000F0BF

```

​          The sequence consists of the components shown in the following          table.

**Table 11.1 WKB Components Example**

| Component    | Size    | Value              |
| ------------ | ------- | ------------------ |
| Byte order   | 1 byte  | `01`               |
| WKB type     | 4 bytes | `01000000`         |
| X coordinate | 8 bytes | `000000000000F03F` |
| Y coordinate | 8 bytes | `000000000000F0BF` |

​          Component representation is as follows:

- ​              The byte order indicator is either 1 or 0 to signify              little-endian or big-endian storage. The little-endian and              big-endian byte orders are also known as Network Data              Representation (NDR) and External Data Representation              (XDR), respectively.            
- ​              The WKB type is a code that indicates the geometry type.              MySQL uses values from 1 through 7 to indicate              `Point`, `LineString`,              `Polygon`, `MultiPoint`,              `MultiLineString`,              `MultiPolygon`, and              `GeometryCollection`.            
- ​              A `Point` value has X and Y coordinates,              each represented as a double-precision value.

​          WKB values for more complex geometry values have more complex          data structures, as detailed in the OpenGIS specification.

#### Internal Geometry Storage Format

​          MySQL stores geometry values using 4 bytes to indicate the          SRID followed by the WKB representation of the value. For a          description of WKB format, see          [Well-Known Binary (WKB) Format](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#gis-wkb-format).        

​          For the WKB part, these MySQL-specific considerations apply:

- ​              The byte-order indicator byte is 1 because MySQL stores              geometries as little-ending values.            
- ​              MySQL supports geometry types of `Point`,              `LineString`, `Polygon`,              `MultiPoint`,              `MultiLineString`,              `MultiPolygon`, and              `GeometryCollection`. Other geometry              types are not supported.

​          The [`LENGTH()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_length) function returns          the space in bytes required for value storage. Example:        

```
mysql> SET @g = GeomFromText('POINT(1 -1)');
mysql> SELECT LENGTH(@g);
+------------+
| LENGTH(@g) |
+------------+
|         25 |
+------------+
mysql> SELECT HEX(@g);
+----------------------------------------------------+
| HEX(@g)                                            |
+----------------------------------------------------+
| 000000000101000000000000000000F03F000000000000F0BF |
+----------------------------------------------------+

```

​          The value length is 25 bytes, made up of these components (as          can be seen from the hexadecimal value):

- ​              4 bytes for integer SRID (0)            
- ​              1 byte for integer byte order (1 = little-endian)            
- ​              4 bytes for integer type information (1 =              `Point`)            
- ​              8 bytes for double-precision X coordinate (1)            
- ​              8 bytes for double-precision Y coordinate (−1)

### 11.5.4 Creating Spatial Columns

​        MySQL provides a standard way of creating spatial columns for        geometry types, for example, with [`CREATE        TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) or [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table).        Spatial columns are supported for        [`MyISAM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#myisam-storage-engine),        [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html),        [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html), and        [`ARCHIVE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#archive-storage-engine) tables. See also the notes        about spatial indexes under        [Section 11.5.8, “Creating Spatial Indexes”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#creating-spatial-indexes).

- ​            Use the [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table)            statement to create a table with a spatial column:          

  ```
  CREATE TABLE geom (g GEOMETRY);

  ```

- ​            Use the [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) statement            to add or drop a spatial column to or from an existing            table:          

  ```
  ALTER TABLE geom ADD pt POINT;
  ALTER TABLE geom DROP pt;

  ```

### 11.5.5 Populating Spatial Columns

​        After you have created spatial columns, you can populate them        with spatial data.      

​        Values should be stored in internal geometry format, but you can        convert them to that format from either Well-Known Text (WKT) or        Well-Known Binary (WKB) format. The following examples        demonstrate how to insert geometry values into a table by        converting WKT values to internal geometry format:

- ​            Perform the conversion directly in the            [`INSERT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert) statement:          

  ```
  INSERT INTO geom VALUES (GeomFromText('POINT(1 1)'));

  SET @g = 'POINT(1 1)';
  INSERT INTO geom VALUES (GeomFromText(@g));

  ```

- ​            Perform the conversion prior to the            [`INSERT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert):          

  ```
  SET @g = GeomFromText('POINT(1 1)');
  INSERT INTO geom VALUES (@g);

  ```

​        The following examples insert more complex geometries into the        table:      

```
SET @g = 'LINESTRING(0 0,1 1,2 2)';
INSERT INTO geom VALUES (GeomFromText(@g));

SET @g = 'POLYGON((0 0,10 0,10 10,0 10,0 0),(5 5,7 5,7 7,5 7, 5 5))';
INSERT INTO geom VALUES (GeomFromText(@g));

SET @g =
'GEOMETRYCOLLECTION(POINT(1 1),LINESTRING(0 0,1 1,2 2,3 3,4 4))';
INSERT INTO geom VALUES (GeomFromText(@g));

```

​        The preceding examples use        [`GeomFromText()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_geomfromtext) to create geometry        values. You can also use type-specific functions:      

```
SET @g = 'POINT(1 1)';
INSERT INTO geom VALUES (PointFromText(@g));

SET @g = 'LINESTRING(0 0,1 1,2 2)';
INSERT INTO geom VALUES (LineStringFromText(@g));

SET @g = 'POLYGON((0 0,10 0,10 10,0 10,0 0),(5 5,7 5,7 7,5 7, 5 5))';
INSERT INTO geom VALUES (PolygonFromText(@g));

SET @g =
'GEOMETRYCOLLECTION(POINT(1 1),LINESTRING(0 0,1 1,2 2,3 3,4 4))';
INSERT INTO geom VALUES (GeomCollFromText(@g));

```

​        A client application program that wants to use WKB        representations of geometry values is responsible for sending        correctly formed WKB in queries to the server. There are several        ways to satisfy this requirement. For example:

- ​            Inserting a `POINT(1 1)` value with hex            literal syntax:          

  ```
  INSERT INTO geom VALUES
  (GeomFromWKB(X'0101000000000000000000F03F000000000000F03F'));

  ```

- ​            An ODBC application can send a WKB representation, binding            it to a placeholder using an argument of            [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) type:          

  ```
  INSERT INTO geom VALUES (GeomFromWKB(?))

  ```

  ​            Other programming interfaces may support a similar            placeholder mechanism.          

- ​            In a C program, you can escape a binary value using            [`mysql_real_escape_string()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/connectors-apis.html#mysql-real-escape-string)            and include the result in a query string that is sent to the            server. See [Section 23.8.7.53, “mysql_real_escape_string()”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/connectors-apis.html#mysql-real-escape-string).

### 11.5.6 Fetching Spatial Data

​        Geometry values stored in a table can be fetched in internal        format. You can also convert them to WKT or WKB format.

- ​            Fetching spatial data in internal format:          

  ​            Fetching geometry values using internal format can be useful            in table-to-table transfers:          

  ```
  CREATE TABLE geom2 (g GEOMETRY) SELECT g FROM geom;

  ```

- ​            Fetching spatial data in WKT format:          

  ​            The [`AsText()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_astext) function            converts a geometry from internal format to a WKT string.          

  ```
  SELECT AsText(g) FROM geom;

  ```

- ​            Fetching spatial data in WKB format:          

  ​            The [`AsBinary()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_asbinary) function            converts a geometry from internal format to a            [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) containing the WKB            value.          

  ```
  SELECT AsBinary(g) FROM geom;

  ```

### 11.5.7 Optimizing Spatial Analysis

​        For [`MyISAM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#myisam-storage-engine) tables, search        operations in columns containing spatial data can be optimized        using `SPATIAL` indexes. The most typical        operations are:

- ​            Point queries that search for all objects that contain a            given point          
- ​            Region queries that search for all objects that overlap a            given region

​        MySQL uses **R-Trees with quadratic        splitting** for `SPATIAL` indexes on        spatial columns. A `SPATIAL` index is built        using the minimum bounding rectangle (MBR) of a geometry. For        most geometries, the MBR is a minimum rectangle that surrounds        the geometries. For a horizontal or a vertical linestring, the        MBR is a rectangle degenerated into the linestring. For a point,        the MBR is a rectangle degenerated into the point.      

​        It is also possible to create normal indexes on spatial columns.        In a non-`SPATIAL` index, you must declare a        prefix for any spatial column except for        `POINT` columns.      

​        `MyISAM` supports both        `SPATIAL` and non-`SPATIAL`        indexes. Other storage engines support        non-`SPATIAL` indexes, as described in        [Section 13.1.13, “CREATE INDEX Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-index).

### 11.5.8 Creating Spatial Indexes

​        For `MyISAM` tables, MySQL can create spatial        indexes using syntax similar to that for creating regular        indexes, but using the `SPATIAL` keyword.        Columns in spatial indexes must be declared `NOT        NULL`. The following examples demonstrate how to create        spatial indexes:

- ​            With [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table):          

  ```
  CREATE TABLE geom (g GEOMETRY NOT NULL, SPATIAL INDEX(g)) ENGINE=MyISAM;

  ```

- ​            With [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table):          

  ```
  CREATE TABLE geom (g GEOMETRY NOT NULL) ENGINE=MyISAM;
  ALTER TABLE geom ADD SPATIAL INDEX(g);

  ```

- ​            With [`CREATE INDEX`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-index):          

  ```
  CREATE TABLE geom (g GEOMETRY NOT NULL) ENGINE=MyISAM;
  CREATE SPATIAL INDEX g ON geom (g);

  ```

​        `SPATIAL INDEX` creates an R-tree index. For        storage engines that support nonspatial indexing of spatial        columns, the engine creates a B-tree index. A B-tree index on        spatial values is useful for exact-value lookups, but not for        range scans.      

​        For more information on indexing spatial columns, see        [Section 13.1.13, “CREATE INDEX Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-index).      

​        To drop spatial indexes, use [`ALTER        TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) or [`DROP INDEX`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-index):

- ​            With [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table):          

  ```
  ALTER TABLE geom DROP INDEX g;

  ```

- ​            With [`DROP INDEX`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-index):          

  ```
  DROP INDEX g ON geom;

  ```

​        Example: Suppose that a table `geom` contains        more than 32,000 geometries, which are stored in the column        `g` of type `GEOMETRY`. The        table also has an `AUTO_INCREMENT` column        `fid` for storing object ID values.      

```
mysql> DESCRIBE geom;
+-------+----------+------+-----+---------+----------------+
| Field | Type     | Null | Key | Default | Extra          |
+-------+----------+------+-----+---------+----------------+
| fid   | int(11)  |      | PRI | NULL    | auto_increment |
| g     | geometry |      |     |         |                |
+-------+----------+------+-----+---------+----------------+
2 rows in set (0.00 sec)

mysql> SELECT COUNT(*) FROM geom;
+----------+
| count(*) |
+----------+
|    32376 |
+----------+
1 row in set (0.00 sec)

```

​        To add a spatial index on the column `g`, use        this statement:      

```
mysql> ALTER TABLE geom ADD SPATIAL INDEX(g) ENGINE=MyISAM;
Query OK, 32376 rows affected (4.05 sec)
Records: 32376  Duplicates: 0  Warnings: 0

```

### 11.5.9 Using Spatial Indexes

​        The optimizer investigates whether available spatial indexes can        be involved in the search for queries that use a function such        as [`MBRContains()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_mbrcontains) or        [`MBRWithin()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_mbrwithin) in the        `WHERE` clause. The following query finds all        objects that are in the given rectangle:      

```
mysql> SET @poly =
    -> 'Polygon((30000 15000,
                 31000 15000,
                 31000 16000,
                 30000 16000,
                 30000 15000))';
mysql> SELECT fid,AsText(g) FROM geom WHERE
    -> MBRContains(GeomFromText(@poly),g);
+-----+---------------------------------------------------------------+
| fid | AsText(g)                                                     |
+-----+---------------------------------------------------------------+
|  21 | LINESTRING(30350.4 15828.8,30350.6 15845,30333.8 15845,30 ... |
|  22 | LINESTRING(30350.6 15871.4,30350.6 15887.8,30334 15887.8, ... |
|  23 | LINESTRING(30350.6 15914.2,30350.6 15930.4,30334 15930.4, ... |
|  24 | LINESTRING(30290.2 15823,30290.2 15839.4,30273.4 15839.4, ... |
|  25 | LINESTRING(30291.4 15866.2,30291.6 15882.4,30274.8 15882. ... |
|  26 | LINESTRING(30291.6 15918.2,30291.6 15934.4,30275 15934.4, ... |
| 249 | LINESTRING(30337.8 15938.6,30337.8 15946.8,30320.4 15946. ... |
|   1 | LINESTRING(30250.4 15129.2,30248.8 15138.4,30238.2 15136. ... |
|   2 | LINESTRING(30220.2 15122.8,30217.2 15137.8,30207.6 15136, ... |
|   3 | LINESTRING(30179 15114.4,30176.6 15129.4,30167 15128,3016 ... |
|   4 | LINESTRING(30155.2 15121.4,30140.4 15118.6,30142 15109,30 ... |
|   5 | LINESTRING(30192.4 15085,30177.6 15082.2,30179.2 15072.4, ... |
|   6 | LINESTRING(30244 15087,30229 15086.2,30229.4 15076.4,3024 ... |
|   7 | LINESTRING(30200.6 15059.4,30185.6 15058.6,30186 15048.8, ... |
|  10 | LINESTRING(30179.6 15017.8,30181 15002.8,30190.8 15003.6, ... |
|  11 | LINESTRING(30154.2 15000.4,30168.6 15004.8,30166 15014.2, ... |
|  13 | LINESTRING(30105 15065.8,30108.4 15050.8,30118 15053,3011 ... |
| 154 | LINESTRING(30276.2 15143.8,30261.4 15141,30263 15131.4,30 ... |
| 155 | LINESTRING(30269.8 15084,30269.4 15093.4,30258.6 15093,30 ... |
| 157 | LINESTRING(30128.2 15011,30113.2 15010.2,30113.6 15000.4, ... |
+-----+---------------------------------------------------------------+
20 rows in set (0.00 sec)

```

​        Use [`EXPLAIN`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#explain) to check the way this        query is executed:      

```
mysql> SET @poly =
    -> 'Polygon((30000 15000,
                 31000 15000,
                 31000 16000,
                 30000 16000,
                 30000 15000))';
mysql> EXPLAIN SELECT fid,AsText(g) FROM geom WHERE
    -> MBRContains(GeomFromText(@poly),g)\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: geom
         type: range
possible_keys: g
          key: g
      key_len: 32
          ref: NULL
         rows: 50
        Extra: Using where
1 row in set (0.00 sec)

```

​        Check what would happen without a spatial index:      

```
mysql> SET @poly =
    -> 'Polygon((30000 15000,
                 31000 15000,
                 31000 16000,
                 30000 16000,
                 30000 15000))';
mysql> EXPLAIN SELECT fid,AsText(g) FROM g IGNORE INDEX (g) WHERE
    -> MBRContains(GeomFromText(@poly),g)\G
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: geom
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 32376
        Extra: Using where
1 row in set (0.00 sec)

```

​        Executing the [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement        without the spatial index yields the same result but causes the        execution time to rise from 0.00 seconds to 0.46 seconds:      

```
mysql> SET @poly =
    -> 'Polygon((30000 15000,
                 31000 15000,
                 31000 16000,
                 30000 16000,
                 30000 15000))';
mysql> SELECT fid,AsText(g) FROM geom IGNORE INDEX (g) WHERE
    -> MBRContains(GeomFromText(@poly),g);
+-----+---------------------------------------------------------------+
| fid | AsText(g)                                                     |
+-----+---------------------------------------------------------------+
|   1 | LINESTRING(30250.4 15129.2,30248.8 15138.4,30238.2 15136. ... |
|   2 | LINESTRING(30220.2 15122.8,30217.2 15137.8,30207.6 15136, ... |
|   3 | LINESTRING(30179 15114.4,30176.6 15129.4,30167 15128,3016 ... |
|   4 | LINESTRING(30155.2 15121.4,30140.4 15118.6,30142 15109,30 ... |
|   5 | LINESTRING(30192.4 15085,30177.6 15082.2,30179.2 15072.4, ... |
|   6 | LINESTRING(30244 15087,30229 15086.2,30229.4 15076.4,3024 ... |
|   7 | LINESTRING(30200.6 15059.4,30185.6 15058.6,30186 15048.8, ... |
|  10 | LINESTRING(30179.6 15017.8,30181 15002.8,30190.8 15003.6, ... |
|  11 | LINESTRING(30154.2 15000.4,30168.6 15004.8,30166 15014.2, ... |
|  13 | LINESTRING(30105 15065.8,30108.4 15050.8,30118 15053,3011 ... |
|  21 | LINESTRING(30350.4 15828.8,30350.6 15845,30333.8 15845,30 ... |
|  22 | LINESTRING(30350.6 15871.4,30350.6 15887.8,30334 15887.8, ... |
|  23 | LINESTRING(30350.6 15914.2,30350.6 15930.4,30334 15930.4, ... |
|  24 | LINESTRING(30290.2 15823,30290.2 15839.4,30273.4 15839.4, ... |
|  25 | LINESTRING(30291.4 15866.2,30291.6 15882.4,30274.8 15882. ... |
|  26 | LINESTRING(30291.6 15918.2,30291.6 15934.4,30275 15934.4, ... |
| 154 | LINESTRING(30276.2 15143.8,30261.4 15141,30263 15131.4,30 ... |
| 155 | LINESTRING(30269.8 15084,30269.4 15093.4,30258.6 15093,30 ... |
| 157 | LINESTRING(30128.2 15011,30113.2 15010.2,30113.6 15000.4, ... |
| 249 | LINESTRING(30337.8 15938.6,30337.8 15946.8,30320.4 15946. ... |
+-----+---------------------------------------------------------------+
20 rows in set (0.46 sec)

```

## 11.6 Data Type Default Values

​      The `DEFAULT *value*`      clause in a data type specification indicates a default value for      a column. With one exception, the default value must be a      constant; it cannot be a function or an expression. This means,      for example, that you cannot set the default for a date column to      be the value of a function such as      [`NOW()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_now) or      [`CURRENT_DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-date). The exception is that      you can specify [`CURRENT_TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-timestamp)      as the default for a [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime)      column. See [Section 11.3.5, “Automatic Initialization and Updating for TIMESTAMP”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#timestamp-initialization).    

​      [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) and      [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) columns cannot be assigned a      default value.    

​      If a column definition includes no explicit      `DEFAULT` value, MySQL determines the default      value as follows:    

​      If the column can take `NULL` as a value, the      column is defined with an explicit `DEFAULT NULL`      clause.    

​      If the column cannot take `NULL` as the value,      MySQL defines the column with no explicit      `DEFAULT` clause. Exception: If the column is      defined as part of a `PRIMARY KEY` but not      explicitly as `NOT NULL`, MySQL creates it as a      `NOT NULL` column (because `PRIMARY      KEY` columns must be `NOT NULL`), but      also assigns it a `DEFAULT` clause using the      implicit default value. To prevent this, include an explicit      `NOT NULL` in the definition of any      `PRIMARY KEY` column.    

​      For data entry into a `NOT NULL` column that has      no explicit `DEFAULT` clause, if an      [`INSERT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert) or      [`REPLACE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#replace) statement includes no value      for the column, or an [`UPDATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#update)      statement sets the column to `NULL`, MySQL      handles the column according to the SQL mode in effect at the      time:

- ​          If strict SQL mode is enabled, an error occurs for          transactional tables and the statement is rolled back. For          nontransactional tables, an error occurs, but if this happens          for the second or subsequent row of a multiple-row statement,          the preceding rows will have been inserted.        
- ​          If strict mode is not enabled, MySQL sets the column to the          implicit default value for the column data type.

​      Suppose that a table `t` is defined as follows:    

```
CREATE TABLE t (i INT NOT NULL);

```

​      In this case, `i` has no explicit default, so in      strict mode each of the following statements produce an error and      no row is inserted. When not using strict mode, only the third      statement produces an error; the implicit default is inserted for      the first two statements, but the third fails because      [`DEFAULT(i)`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_default) cannot produce a value:    

```
INSERT INTO t VALUES();
INSERT INTO t VALUES(DEFAULT);
INSERT INTO t VALUES(DEFAULT(i));

```

​      See [Section 5.1.8, “Server SQL Modes”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sql-mode).    

​      For a given table, you can use the [`SHOW      CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-create-table) statement to see which columns have an      explicit `DEFAULT` clause.    

​      Implicit defaults are defined as follows:

- ​          For numeric types, the default is `0`, with          the exception that for integer or floating-point types          declared with the `AUTO_INCREMENT` attribute,          the default is the next value in the sequence.        
- ​          For date and time types other than          [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime), the default is the          appropriate “zero” value for the type. For the          first [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) column in a          table, the default value is the current date and time. See          [Section 11.3, “Date and Time Types”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#date-and-time-types).        
- ​          For string types other than          [`ENUM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum), the default value is the          empty string. For [`ENUM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum), the          default is the first enumeration value.

​      `SERIAL DEFAULT VALUE` in the definition of an      integer column is an alias for `NOT NULL AUTO_INCREMENT      UNIQUE`.

## 11.7 Data Type Storage Requirements

- [InnoDB Table Storage Requirements](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#data-types-storage-reqs-innodb)
- [NDBCLUSTER Table Storage Requirements](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#data-types-storage-reqs-ndb)
- [Numeric Type Storage Requirements](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#data-types-storage-reqs-numeric)
- [Date and Time Type Storage Requirements](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#data-types-storage-reqs-date-time)
- [String Type Storage Requirements](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#data-types-storage-reqs-strings)
- [Spatial Type Storage Requirements](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#data-types-storage-reqs-gis)

​      The storage requirements for data vary, according to the storage      engine being used for the table in question. Different storage      engines use different methods for recording the raw data and      different data types. In addition, some engines may compress the      information in a given row, either on a column or entire row      basis, making calculation of the storage requirements for a given      table or column structure.    

​      However, all storage engines must communicate and exchange      information on a given row within a table using the same      structure, and this information is consistent, irrespective of the      storage engine used to write the information to disk.    

​      This sections includes some guideliness and information for the      storage requirements for each data type supported by MySQL,      including details for the internal format and the sizes used by      storage engines that used a fixed size representation for      different types. Information is listed by category or storage      engine.    

​      The internal representation of a table has a maximum row size of      65,535 bytes, even if the storage engine is capable of supporting      larger rows. This figure excludes      [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) or      [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) columns, which contribute only      9 to 12 bytes toward this size. For      [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) and      [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) data, the information is      stored internally in a different area of memory than the row      buffer. Different storage engines handle the allocation and      storage of this data in different ways, according to the method      they use for handling the corresponding types. For more      information, see [Chapter 15, *Alternative Storage Engines*](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html), and      [Section C.10.4, “Limits on Table Column Count and Row Size”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/restrictions.html#column-count-limit).

### InnoDB Table Storage Requirements

​        See [Section 14.11.1.2, “The Physical Row Structure of an InnoDB Table”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#innodb-physical-record) for information        about storage requirements for `InnoDB` tables.

### NDBCLUSTER Table Storage Requirements

Important

​          For tables using the [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html)          storage engine, there is the factor of          4-byte alignment to be          taken into account when calculating storage requirements. This          means that all [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) data storage          is done in multiples of 4 bytes. Thus, a column value that          would take 15 bytes in a table using a storage engine other          than [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) requires 16 bytes in an          [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) table. This requirement          applies in addition to any other considerations that are          discussed in this section. For example, in          [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) tables, the          [`TINYINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types),          [`SMALLINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types),          [`MEDIUMINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types), and          [`INTEGER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types)          ([`INT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types)) column types each require          4 bytes storage per record due to the alignment factor.        

​          An exception to this rule is the          [`BIT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#bit-type) type, which is          *not* 4-byte aligned. In NDB Cluster          tables, a `BIT(*M*)`          column takes *M* bits of storage          space. However, if a table definition contains 1 or more          [`BIT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#bit-type) columns (up to 32          [`BIT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#bit-type) columns), then          [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) reserves 4 bytes (32          bits) per row for these. If a table definition contains more          than 32 [`BIT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#bit-type) columns (up to 64          such columns), then [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html)          reserves 8 bytes (that is, 64 bits) per row.        

​          In addition, while a `NULL` itself does not          require any storage space,          [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) reserves 4 bytes per          row if the table definition contains any columns defined as          `NULL`, up to 32 `NULL`          columns. (If an NDB Cluster table is defined with more than 32          `NULL` columns up to 64          `NULL` columns, then 8 bytes per row is          reserved.)

​        When calculating storage requirements for NDB Cluster tables,        you must also remember that every table using the        [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) storage engine requires        a primary key; if no primary key is defined by the user, then a        “hidden” primary key will be created by        [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html). This hidden primary key        consumes 31-35 bytes per table record.      

​        You may find the `ndb_size.pl` utility to be        useful for estimating [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) storage        requirements. This Perl script connects to a current MySQL        (non-Cluster) database and creates a report on how much space        that database would require if it used the        [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) storage engine. See        [Section 18.4.25, “**ndb_size.pl** — NDBCLUSTER Size Requirement Estimator”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html#mysql-cluster-programs-ndb-size-pl), for more        information.

### Numeric Type Storage Requirements

| Data Type                                | Storage Required                         |
| ---------------------------------------- | ---------------------------------------- |
| [`TINYINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) | 1 byte                                   |
| [`SMALLINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) | 2 bytes                                  |
| [`MEDIUMINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) | 3 bytes                                  |
| [`INT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types),                [`INTEGER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) | 4 bytes                                  |
| [`BIGINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) | 8 bytes                                  |
| `FLOAT(*p*)`                             | 4 bytes if 0 <= *p* <= 24, 8 bytes if 25                <= *p* <= 53 |
| [`FLOAT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types) | 4 bytes                                  |
| `DOUBLE [PRECISION]`,                [`REAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types) | 8 bytes                                  |
| `DECIMAL(*M*,*D*)`,`NUMERIC(*M*,*D*)`    | Varies; see following discussion         |
| `BIT(*M*)`                               | approximately (*M*+7)/8 bytes            |

​        Values for [`DECIMAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fixed-point-types) (and        [`NUMERIC`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fixed-point-types)) columns are represented        using a binary format that packs nine decimal (base 10) digits        into four bytes. Storage for the integer and fractional parts of        each value are determined separately. Each multiple of nine        digits requires four bytes, and the “leftover”        digits require some fraction of four bytes. The storage required        for excess digits is given by the following table.

| Leftover Digits | Number of Bytes |
| --------------- | --------------- |
| 0               | 0               |
| 1               | 1               |
| 2               | 1               |
| 3               | 2               |
| 4               | 2               |
| 5               | 3               |
| 6               | 3               |
| 7               | 4               |
| 8               | 4               |

### Date and Time Type Storage Requirements

| Data Type                                | Storage Required |
| ---------------------------------------- | ---------------- |
| [`DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) | 3 bytes          |
| [`TIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#time) | 3 bytes          |
| [`DATETIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) | 8 bytes          |
| [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) | 4 bytes          |
| [`YEAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#year) | 1 byte           |

​        For details about internal representation of temporal values,        see [MySQL        Internals: Important Algorithms and Structures](http://dev.mysql.com/doc/internals/en/algorithms.html).

### String Type Storage Requirements

​        In the following table, *M* represents        the declared column length in characters for nonbinary string        types and bytes for binary string types.        *L* represents the actual length in        bytes of a given string value.

| Data Type                                | Storage Required                         |
| ---------------------------------------- | ---------------------------------------- |
| `CHAR(*M*)`                              | *M* × *w* bytes,                0 `<= *M*                <=` 255, where *w*                is the number of bytes required for the maximum-length                character in the character set. See                [Section 14.11.1.2, “The Physical Row Structure of an InnoDB Table”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#innodb-physical-record) for information                about `CHAR` data type storage                requirements for `InnoDB` tables. |
| `BINARY(*M*)`                            | *M* bytes, 0 `<=                *M* <=` 255 |
| `VARCHAR(*M*)`,                `VARBINARY(*M*)` | *L* + 1 bytes if column values require 0                − 255 bytes, *L* + 2                bytes if values may require more than 255 bytes |
| [`TINYBLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob),                [`TINYTEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) | *L* + 1 bytes, where                *L* <                28 |
| [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob), [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) | *L* + 2 bytes, where                *L* <                216 |
| [`MEDIUMBLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob),                [`MEDIUMTEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) | *L* + 3 bytes, where                *L* <                224 |
| [`LONGBLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob),                [`LONGTEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) | *L* + 4 bytes, where                *L* <                232 |
| `ENUM('*value1*','*value2*',...)`        | 1 or 2 bytes, depending on the number of enumeration values (65,535                values maximum) |
| `SET('*value1*','*value2*',...)`         | 1, 2, 3, 4, or 8 bytes, depending on the number of set members (64members maximum) |

​        Variable-length string types are stored using a length prefix        plus data. The length prefix requires from one to four bytes        depending on the data type, and the value of the prefix is        *L* (the byte length of the string).        For example, storage for a        [`MEDIUMTEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) value requires        *L* bytes to store the value plus three        bytes to store the length of the value.      

​        To calculate the number of bytes used to store a particular        [`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),        [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char), or        [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) column value, you must take        into account the character set used for that column and whether        the value contains multibyte characters. In particular, when        using a `utf8` Unicode character set, you must        keep in mind that not all characters use the same number of        bytes. `utf8mb3` and `utf8mb4`        character sets can require up to three and four bytes per        character, respectively. For a breakdown of the storage used for        different categories of `utf8mb3` or        `utf8mb4` characters, see        [Section 10.1.9, “Unicode Support”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/globalization.html#charset-unicode).      

​        [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),        [`VARBINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary), and the        [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) and        [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) types are variable-length        types. For each, the storage requirements depend on these        factors:

- ​            The actual length of the column value          
- ​            The column's maximum possible length          
- ​            The character set used for the column, because some            character sets contain multibyte characters

​        For example, a `VARCHAR(255)` column can hold a        string with a maximum length of 255 characters. Assuming that        the column uses the `latin1` character set (one        byte per character), the actual storage required is the length        of the string (*L*), plus one byte to        record the length of the string. For the string        `'abcd'`, *L* is 4 and        the storage requirement is five bytes. If the same column is        instead declared to use the `ucs2` double-byte        character set, the storage requirement is 10 bytes: The length        of `'abcd'` is eight bytes and the column        requires two bytes to store lengths because the maximum length        is greater than 255 (up to 510 bytes).      

​        The effective maximum number of *bytes* that        can be stored in a [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) or        [`VARBINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary) column is subject to        the maximum row size of 65,535 bytes, which is shared among all        columns. For a [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) column        that stores multibyte characters, the effective maximum number        of *characters* is less. For example,        `utf8mb3` characters can require up to three        bytes per character, so a [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char)        column that uses the `utf8mb3` character set        can be declared to be a maximum of 21,844 characters. See        [Section C.10.4, “Limits on Table Column Count and Row Size”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/restrictions.html#column-count-limit).      

​        `InnoDB` encodes fixed-length fields greater        than or equal to 768 bytes in length as variable-length fields,        which can be stored off-page. For example, a        `CHAR(255)` column can exceed 768 bytes if the        maximum byte length of the character set is greater than 3, as        it is with `utf8mb4`.      

​        The [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) storage engine        supports variable-width columns. This means that a        [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) column in an NDB Cluster        table requires the same amount of storage as would any other        storage engine, with the exception that such values are 4-byte        aligned. Thus, the string `'abcd'` stored in a        `VARCHAR(50)` column using the        `latin1` character set requires 8 bytes (rather        than 5 bytes for the same column value in a        `MyISAM` table).      

​        [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) and        [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) columns are implemented        differently in the NDB Cluster storage engine, wherein each row        in a [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) column is made up of        two separate parts. One of these is of fixed size (256 bytes),        and is actually stored in the original table. The other consists        of any data in excess of 256 bytes, which is stored in a hidden        table. The rows in this second table are always 2,000 bytes        long. This means that the size of a        [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) column is 256 if        *size* <= 256 (where        *size* represents the size of the row);        otherwise, the size is 256 + *size* +        (2000 − (*size* − 256) %        2000).      

​        The size of an [`ENUM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum) object is        determined by the number of different enumeration values. One        byte is used for enumerations with up to 255 possible values.        Two bytes are used for enumerations having between 256 and        65,535 possible values. See [Section 11.4.4, “The ENUM Type”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum).      

​        The size of a [`SET`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#set) object is        determined by the number of different set members. If the set        size is *N*, the object occupies        `(*N*+7)/8` bytes,        rounded up to 1, 2, 3, 4, or 8 bytes. A        [`SET`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#set) can have a maximum of 64        members. See [Section 11.4.5, “The SET Type”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#set).

### Spatial Type Storage Requirements

​        MySQL stores geometry values using 4 bytes to indicate the SRID        followed by the WKB representation of the value. The        [`LENGTH()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_length) function returns the        space in bytes required for value storage.      

​        For descriptions of WKB and internal storage formats for spatial        values, see [Section 11.5.3, “Supported Spatial Data Formats”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#gis-data-formats).

## 11.8 Choosing the Right Type for a Column

​      For optimum storage, you should try to use the most precise type      in all cases. For example, if an integer column is used for values      in the range from `1` to      `99999`, `MEDIUMINT UNSIGNED` is      the best type. Of the types that represent all the required      values, this type uses the least amount of storage.    

​      All basic calculations (`+`,      `-`, `*`, and      `/`) with [`DECIMAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fixed-point-types)      columns are done with precision of 65 decimal (base 10) digits.      See [Section 11.1.1, “Numeric Type Overview”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#numeric-type-overview).    

​      If accuracy is not too important or if speed is the highest      priority, the [`DOUBLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types) type may be      good enough. For high precision, you can always convert to a      fixed-point type stored in a      [`BIGINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types). This enables you to do all      calculations with 64-bit integers and then convert results back to      floating-point values as necessary.    

​      `PROCEDURE ANALYSE` can be used to obtain      suggestions for optimal column data types. For more information,      see [Section 8.4.2.4, “Using PROCEDURE ANALYSE”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/optimization.html#procedure-analyse).

## 11.9 Using Data Types from Other Database Engines

​      To facilitate the use of code written for SQL implementations from      other vendors, MySQL maps data types as shown in the following      table. These mappings make it easier to import table definitions      from other database systems into MySQL.

| Other Vendor Type                        | MySQL Type                               |
| ---------------------------------------- | ---------------------------------------- |
| [`BOOL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) | [`TINYINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) |
| [`BOOLEAN`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) | [`TINYINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) |
| `CHARACTER VARYING(*M*)`                 | `VARCHAR(*M*)`                           |
| [`FIXED`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fixed-point-types) | [`DECIMAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fixed-point-types) |
| [`FLOAT4`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types) | [`FLOAT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types) |
| [`FLOAT8`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types) | [`DOUBLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#floating-point-types) |
| [`INT1`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) | [`TINYINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) |
| [`INT2`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) | [`SMALLINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) |
| [`INT3`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) | [`MEDIUMINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) |
| [`INT4`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) | [`INT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) |
| `INT8`                                   | [`BIGINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) |
| `LONG VARBINARY`                         | [`MEDIUMBLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) |
| `LONG VARCHAR`                           | [`MEDIUMTEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) |
| `LONG`                                   | [`MEDIUMTEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) |
| [`MIDDLEINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) | [`MEDIUMINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#integer-types) |
| [`NUMERIC`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fixed-point-types) | [`DECIMAL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#fixed-point-types) |

​      Data type mapping occurs at table creation time, after which the      original type specifications are discarded. If you create a table      with types used by other vendors and then issue a      `DESCRIBE *tbl_name*`      statement, MySQL reports the table structure using the equivalent      MySQL types. For example:    

```
mysql> CREATE TABLE t (a BOOL, b FLOAT8, c LONG VARCHAR, d NUMERIC);
Query OK, 0 rows affected (0.00 sec)

mysql> DESCRIBE t;
+-------+---------------+------+-----+---------+-------+
| Field | Type          | Null | Key | Default | Extra |
+-------+---------------+------+-----+---------+-------+
| a     | tinyint(1)    | YES  |     | NULL    |       |
| b     | double        | YES  |     | NULL    |       |
| c     | mediumtext    | YES  |     | NULL    |       |
| d     | decimal(10,0) | YES  |     | NULL    |       |
+-------+---------------+------+-----+---------+-------+
4 rows in set (0.01 sec)

```

------

| [Prev](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/globalization.html) | [Up](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#spatial-types) | [Next](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html) |
| ---------------------------------------- | ---------------------------------------- | ---------------------------------------- |
| Chapter 10 Globalization                 | [Home](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/index.html) | Chapter 12 Functions and Operators       |
