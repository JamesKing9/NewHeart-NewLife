## 13.1 Data Definition Statements

### 13.1.1 ALTER DATABASE Syntax

```mysql
ALTER {DATABASE | SCHEMA} [db_name]
    alter_specification ...
ALTER {DATABASE | SCHEMA} db_name
    UPGRADE DATA DIRECTORY NAME

alter_specification:
    [DEFAULT] CHARACTER SET [=] charset_name
  | [DEFAULT] COLLATE [=] collation_name

```

​     

`ALTER DATABASE` enables you to      change the overall characteristics of a database. These      characteristics are stored in the `db.opt` file      in the database directory. To use `ALTER  DATABASE`, you need the `ALTER` privilege on the database. `ALTER SCHEMA` is a synonym for `ALTER DATABASE`.    

The database name can be omitted from the first syntax, in which      case the statement applies to the default database.




#### National Language Characteristics

​The `CHARACTER SET` clause changes the default      database character set. The `COLLATE` clause      changes the default database collation. Section 10.1, “Character Set Support”,      discusses character set and collation names.       

​You can see what character sets and collations are available      using, respectively, the [`SHOW CHARACTER      SET`](file:///E:/github/refman-5.5-en.html-chapter/sql-syntax.html#show-character-set) and [`SHOW COLLATION`](file:///E:/github/refman-5.5-en.html-chapter/sql-syntax.html#show-collation)      statements. See [Section 13.7.5.4, “SHOW CHARACTER SET Syntax”](file:///E:/github/refman-5.5-en.html-chapter/sql-syntax.html#show-character-set), and      [Section 13.7.5.5, “SHOW COLLATION Syntax”](file:///E:/github/refman-5.5-en.html-chapter/sql-syntax.html#show-collation), for more information.        

If you change the default character set or collation for a      database, stored routines that use the database defaults must be      dropped and recreated so that they use the new defaults. (In a      stored routine, variables with character data types use the      database defaults if the character set or collation are not      specified explicitly. See [Section 13.1.15, “CREATE PROCEDURE and CREATE FUNCTION Syntax”](file:///E:/github/refman-5.5-en.html-chapter/sql-syntax.html#create-procedure).)



#### Upgrading from Versions Older than MySQL 5.1

 The syntax that includes the `UPGRADE DATA DIRECTORY      NAME` clause updates the name of the directory associated      with the database to use the encoding implemented in MySQL 5.1 for      mapping database names to database directory names (see      [Section 9.2.3, “Mapping of Identifiers to File Names”](file:///E:/github/refman-5.5-en.html-chapter/language-structure.html#identifier-mapping)). This clause is for use      under these conditions:

-   ​          It is intended when upgrading MySQL to 5.1 or later from older          versions.        
-   ​          It is intended to update a database directory name to the          current encoding format if the name contains special          characters that need encoding.        
-   ​          The statement is used by [**mysqlcheck**](file:///E:/github/refman-5.5-en.html-chapter/programs.html#mysqlcheck) (as          invoked by [**mysql_upgrade**](file:///E:/github/refman-5.5-en.html-chapter/programs.html#mysql-upgrade)).

​      

For example, if a database in MySQL 5.0 has the name      `a-b-c`, the name contains instances of the      `-` (dash) character. In MySQL 5.0, the database      directory is also named `a-b-c`, which is not      necessarily safe for all file systems. In MySQL 5.1 and later, the      same database name is encoded as `a@002db@002dc`      to produce a file system-neutral directory name.    

​      

When a MySQL installation is upgraded to MySQL 5.1 or later from      an older version,the server displays a name such as      `a-b-c` (which is in the old format) as      `#mysql50#a-b-c`, and you must refer to the name      using the `#mysql50#` prefix. Use      `UPGRADE DATA DIRECTORY NAME` in this case to      explicitly tell the server to re-encode the database directory      name to the current encoding format:    

```
ALTER DATABASE `#mysql50#a-b-c` UPGRADE DATA DIRECTORY NAME;

```

​      

After executing this statement, you can refer to the database as      `a-b-c` without the special      `#mysql50#` prefix.



### 13.1.2 ALTER EVENT Syntax

```
ALTER
    [DEFINER = { user | CURRENT_USER }]
    EVENT event_name
    [ON SCHEDULE schedule]
    [ON COMPLETION [NOT] PRESERVE]
    [RENAME TO new_event_name]
    [ENABLE | DISABLE | DISABLE ON SLAVE]
    [COMMENT 'string']
    [DO event_body]

```

The [`ALTER EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-event) statement changes      one or more of the characteristics of an existing event without      the need to drop and recreate it. The syntax for each of the      `DEFINER`, `ON SCHEDULE`,      `ON COMPLETION`, `COMMENT`,      `ENABLE` / `DISABLE`, and      [`DO`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#do) clauses is exactly the same as      when used with [`CREATE EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-event). (See      [Section 13.1.11, “CREATE EVENT Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-event).)    

Any user can alter an event defined on a database for which that      user has the [`EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_event) privilege. When      a user executes a successful [`ALTER      EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-event) statement, that user becomes the definer for the      affected event.    

`ALTER EVENT`works only with an      existing event:    

```mysql
mysql> ALTER EVENT no_such_event 
     >     ON SCHEDULE 
     >       EVERY '2:3' DAY_HOUR;
ERROR 1517 (HY000): Unknown event 'no_such_event'
```

​      In each of the following examples, assume that the event named      `myevent` is defined as shown here:    

```
CREATE EVENT myevent
    ON SCHEDULE
      EVERY 6 HOUR
    COMMENT 'A sample comment.'
    DO
      UPDATE myschema.mytable SET mycol = mycol + 1;

```

​      The following statement changes the schedule for      `myevent` from once every six hours starting      immediately to once every twelve hours, starting four hours from      the time the statement is run:    

```
ALTER EVENT myevent
    ON SCHEDULE
      EVERY 12 HOUR
    STARTS CURRENT_TIMESTAMP + INTERVAL 4 HOUR;

```

​      It is possible to change multiple characteristics of an event in a      single statement. This example changes the SQL statement executed      by `myevent` to one that deletes all records from      `mytable`; it also changes the schedule for the      event such that it executes once, one day after this      [`ALTER EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-event) statement is run.    

```
ALTER EVENT myevent
    ON SCHEDULE
      AT CURRENT_TIMESTAMP + INTERVAL 1 DAY
    DO
      TRUNCATE TABLE myschema.mytable;

```

​      Specify the options in an [`ALTER      EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-event) statement only for those characteristics that you      want to change; omitted options keep their existing values. This      includes any default values for [`CREATE      EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-event) such as `ENABLE`.    

​      To disable `myevent`, use this      [`ALTER EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-event) statement:    

```
ALTER EVENT myevent
    DISABLE;

```

​      The `ON SCHEDULE` clause may use expressions      involving built-in MySQL functions and user variables to obtain      any of the *timestamp* or      *interval* values which it contains. You      cannot use stored routines or user-defined functions in such      expressions, and you cannot use any table references; however, you      can use `SELECT FROM DUAL`. This is true for both      [`ALTER EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-event) and      [`CREATE EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-event) statements. References      to stored routines, user-defined functions, and tables in such      cases are specifically not permitted, and fail with an error (see      Bug #22830).    

​      Although an [`ALTER EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-event) statement      that contains another [`ALTER EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-event)      statement in its [`DO`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#do) clause appears      to succeed, when the server attempts to execute the resulting      scheduled event, the execution fails with an error.    

​      To rename an event, use the [`ALTER      EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-event) statement's `RENAME TO` clause.      This statement renames the event `myevent` to      `yourevent`:    

```
ALTER EVENT myevent
    RENAME TO yourevent;

```

​      You can also move an event to a different database using      `ALTER EVENT ... RENAME TO ...` and      `*db_name.event_name*`      notation, as shown here:    

```
ALTER EVENT olddb.myevent
    RENAME TO newdb.myevent;

```

​      To execute the previous statement, the user executing it must have      the [`EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_event) privilege on both the      `olddb` and `newdb` databases.

Note

​        There is no `RENAME EVENT` statement.

​      The value `DISABLE ON SLAVE` is used on a      replication slave instead of `ENABLE` or      `DISABLE` to indicate an event that was created      on the master and replicated to the slave, but that is not      executed on the slave. Normally, `DISABLE ON      SLAVE` is set automatically as required; however, there      are some circumstances under which you may want or need to change      it manually. See [Section 17.4.1.15, “Replication of Invoked Features”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/replication.html#replication-features-invoked),      for more information.

### 13.1.3 ALTER FUNCTION Syntax

```
ALTER FUNCTION func_name [characteristic ...]

characteristic:
    COMMENT 'string'
  | LANGUAGE SQL
  | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
  | SQL SECURITY { DEFINER | INVOKER }

```

​      This statement can be used to change the characteristics of a      stored function. More than one change may be specified in an      [`ALTER FUNCTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-function) statement. However,      you cannot change the parameters or body of a stored function      using this statement; to make such changes, you must drop and      re-create the function using [`DROP      FUNCTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-function) and [`CREATE      FUNCTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-function).    

​      You must have the [`ALTER ROUTINE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_alter-routine)      privilege for the function. (That privilege is granted      automatically to the function creator.) If binary logging is      enabled, the [`ALTER FUNCTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-function)      statement might also require the      [`SUPER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_super) privilege, as described in      [Section 20.7, “Binary Logging of Stored Programs”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/stored-programs-views.html#stored-programs-logging).

### 13.1.4 ALTER LOGFILE GROUP Syntax

```
ALTER LOGFILE GROUP logfile_group
    ADD UNDOFILE 'file_name'
    [INITIAL_SIZE [=] size]
    [WAIT]
    ENGINE [=] engine_name

```

​      This statement adds an `UNDO` file named      '*file_name*' to an existing log file      group *logfile_group*. An      [`ALTER LOGFILE GROUP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-logfile-group) statement has      one and only one `ADD UNDOFILE` clause. No      `DROP UNDOFILE` clause is currently supported.

Note

​        All NDB Cluster Disk Data objects share the same namespace. This        means that *each Disk Data object* must be        uniquely named (and not merely each Disk Data object of a given        type). For example, you cannot have a tablespace and an undo log        file with the same name, or an undo log file and a data file        with the same name.

​      The optional `INITIAL_SIZE` parameter sets the      `UNDO` file's initial size in bytes; if not      specified, the initial size defaults to 134217728 (128 MB). Prior      to MySQL NDB Cluster 7.2.14, this value was required to be      specified using digits (Bug #13116514, Bug #16104705, Bug #62858);      in MySQL NDB Cluster 7.2.14 and later, you may optionally follow      *size* with a one-letter abbreviation for      an order of magnitude, similar to those used in      `my.cnf`. Generally, this is one of the letters      `M` (megabytes) or `G`      (gigabytes).    

​      On 32-bit systems, the maximum supported value for      `INITIAL_SIZE` is 4294967296 (4 GB). (Bug #29186)    

​      The minimum allowed value for `INITIAL_SIZE` is      1048576 (1 MB). (Bug #29574)

Note

​        `WAIT` is parsed but otherwise ignored. This        keyword currently has no effect, and is intended for future        expansion.

​      The `ENGINE` parameter (required) determines the      storage engine which is used by this log file group, with      *engine_name* being the name of the      storage engine. Currently, the only accepted values for      *engine_name* are      “[`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html)” and      “[`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html)”. The two values      are equivalent.    

​      Here is an example, which assumes that the log file group      `lg_3` has already been created using      [`CREATE LOGFILE GROUP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-logfile-group) (see      [Section 13.1.14, “CREATE LOGFILE GROUP Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-logfile-group)):    

```
ALTER LOGFILE GROUP lg_3
    ADD UNDOFILE 'undo_10.dat'
    INITIAL_SIZE=32M
    ENGINE=NDBCLUSTER;

```

​      When [`ALTER LOGFILE GROUP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-logfile-group) is used      with `ENGINE = NDBCLUSTER` (alternatively,      `ENGINE = NDB`), an `UNDO` log      file is created on each NDB Cluster data node. You can verify that      the `UNDO` files were created and obtain      information about them by querying the      [`INFORMATION_SCHEMA.FILES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/information-schema.html#files-table) table. For      example:    

```
mysql> SELECT FILE_NAME, LOGFILE_GROUP_NUMBER, EXTRA
    -> FROM INFORMATION_SCHEMA.FILES
    -> WHERE LOGFILE_GROUP_NAME = 'lg_3';
+-------------+----------------------+----------------+
| FILE_NAME   | LOGFILE_GROUP_NUMBER | EXTRA          |
+-------------+----------------------+----------------+
| newdata.dat |                    0 | CLUSTER_NODE=3 |
| newdata.dat |                    0 | CLUSTER_NODE=4 |
| undo_10.dat |                   11 | CLUSTER_NODE=3 |
| undo_10.dat |                   11 | CLUSTER_NODE=4 |
+-------------+----------------------+----------------+
4 rows in set (0.01 sec)

```

​      (See [Section 21.29.1, “The INFORMATION_SCHEMA FILES Table”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/information-schema.html#files-table).)    

​      Memory used for `UNDO_BUFFER_SIZE` comes from the      global pool whose size is determined by the value of the      [`SharedGlobalMemory`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html#ndbparam-ndbd-sharedglobalmemory) data      node configuration parameter. This includes any default value      implied for this option by the setting of the      [`InitialLogFileGroup`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html#ndbparam-ndbd-initiallogfilegroup) data      node configuration parameter.    

​      [`ALTER LOGFILE GROUP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-logfile-group) is useful only      with Disk Data storage for NDB Cluster. For more information, see      [Section 18.5.12, “NDB Cluster Disk Data Tables”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html#mysql-cluster-disk-data).

### 13.1.5 ALTER PROCEDURE Syntax

```
ALTER PROCEDURE proc_name [characteristic ...]

characteristic:
    COMMENT 'string'
  | LANGUAGE SQL
  | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
  | SQL SECURITY { DEFINER | INVOKER }

```

​      This statement can be used to change the characteristics of a      stored procedure. More than one change may be specified in an      [`ALTER PROCEDURE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-procedure) statement. However,      you cannot change the parameters or body of a stored procedure      using this statement; to make such changes, you must drop and      re-create the procedure using [`DROP      PROCEDURE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-procedure) and [`CREATE      PROCEDURE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-procedure).    

​      You must have the [`ALTER ROUTINE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_alter-routine)      privilege for the procedure. By default, that privilege is granted      automatically to the procedure creator. This behavior can be      changed by disabling the      [`automatic_sp_privileges`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_automatic_sp_privileges) system      variable. See [Section 20.2.2, “Stored Routines and MySQL Privileges”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/stored-programs-views.html#stored-routines-privileges).

### 13.1.6 ALTER SERVER Syntax

```mysql
ALTER SERVER  server_name
    OPTIONS (option [, option] ...)
```

Alters the server information for      `*server_name*`,      adjusting any of the options permitted in the      [`CREATE SERVER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-server) statement. The      corresponding fields in the `mysql.servers` table      are updated accordingly. This statement requires the      [`SUPER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_super) privilege.    

​      For example, to update the `USER` option:    

```
ALTER SERVER s OPTIONS (USER 'sally');
```

​      `ALTER SERVER` causes an implicit commit. See      [Section 13.3.3, “Statements That Cause an Implicit Commit”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#implicit-commit).    

​      `ALTER SERVER` is not written to the binary log,      regardless of the logging format that is in use.

### 13.1.7 ALTER TABLE Syntax

```sql
ALTER [ONLINE|OFFLINE] [IGNORE] TABLE tbl_name
    [alter_specification [, alter_specification] ...]
    [partition_options]

alter_specification:
    table_options
  | ADD [COLUMN] col_name column_definition
        [FIRST | AFTER col_name]
  | ADD [COLUMN] (col_name column_definition,...)
  | ADD {INDEX|KEY} [index_name]
        [index_type] (index_col_name,...) [index_option] ...
  | ADD [CONSTRAINT [symbol]] PRIMARY KEY
        [index_type] (index_col_name,...) [index_option] ...
  | ADD [CONSTRAINT [symbol]]
        UNIQUE [INDEX|KEY] [index_name]
        [index_type] (index_col_name,...) [index_option] ...
  | ADD FULLTEXT [INDEX|KEY] [index_name]
        (index_col_name,...) [index_option] ...
  | ADD SPATIAL [INDEX|KEY] [index_name]
        (index_col_name,...) [index_option] ...
  | ADD [CONSTRAINT [symbol]]
        FOREIGN KEY [index_name] (index_col_name,...)
        reference_definition
  | ALTER [COLUMN] col_name {SET DEFAULT literal | DROP DEFAULT}
  | CHANGE [COLUMN] old_col_name new_col_name column_definition
        [FIRST|AFTER col_name]
  | [DEFAULT] CHARACTER SET [=] charset_name [COLLATE [=] collation_name]
  | CONVERT TO CHARACTER SET charset_name [COLLATE collation_name]
  | {DISABLE|ENABLE} KEYS
  | {DISCARD|IMPORT} TABLESPACE
  | DROP [COLUMN] col_name
  | DROP {INDEX|KEY} index_name
  | DROP PRIMARY KEY
  | DROP FOREIGN KEY fk_symbol
  | FORCE
  | MODIFY [COLUMN] col_name column_definition
        [FIRST | AFTER col_name]
  | ORDER BY col_name [, col_name] ...
  | RENAME [TO|AS] new_tbl_name
  | ADD PARTITION (partition_definition)
  | DROP PARTITION partition_names
  | TRUNCATE PARTITION {partition_names | ALL}
  | COALESCE PARTITION number
  | REORGANIZE PARTITION [partition_names INTO (partition_definitions)]
  | ANALYZE PARTITION {partition_names | ALL}
  | CHECK PARTITION {partition_names | ALL}
  | OPTIMIZE PARTITION {partition_names | ALL}
  | REBUILD PARTITION {partition_names | ALL}
  | REPAIR PARTITION {partition_names | ALL}
  | PARTITION BY partitioning_expression
  | REMOVE PARTITIONING

index_col_name:
    col_name [(length)] [ASC | DESC]

index_type:
    USING {BTREE | HASH}

index_option:
    KEY_BLOCK_SIZE [=] value
  | index_type
  | WITH PARSER parser_name
  | COMMENT 'string'

table_options:
    table_option [[,] table_option] ...

table_option:
    AUTO_INCREMENT [=] value
  | AVG_ROW_LENGTH [=] value
  | [DEFAULT] CHARACTER SET [=] charset_name
  | CHECKSUM [=] {0 | 1}
  | [DEFAULT] COLLATE [=] collation_name
  | COMMENT [=] 'string'
  | CONNECTION [=] 'connect_string'
  | {DATA|INDEX} DIRECTORY [=] 'absolute path to directory'
  | DELAY_KEY_WRITE [=] {0 | 1}
  | ENGINE [=] engine_name
  | INSERT_METHOD [=] { NO | FIRST | LAST }
  | KEY_BLOCK_SIZE [=] value
  | MAX_ROWS [=] value
  | MIN_ROWS [=] value
  | PACK_KEYS [=] {0 | 1 | DEFAULT}
  | PASSWORD [=] 'string'
  | ROW_FORMAT [=] {DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT}
  | TABLESPACE tablespace_name [STORAGE {DISK|MEMORY|DEFAULT}]
  | UNION [=] (tbl_name[,tbl_name]...)

```

​`ALTER TABLE` changes the structure      of a table. For example, you can add or delete columns, create or      destroy indexes, change the type of existing columns, or rename      columns or the table itself. You can also change characteristics      such as the storage engine used for the table or the table      comment.

- To use `ALTER TABLE`, you need `ALTER`, `CREATE`, and          [`INSERT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_insert) privileges for the          table. Renaming a table requires          [`ALTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_alter) and          [`DROP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_drop) on the old table,          [`ALTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_alter),          [`CREATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_create), and          [`INSERT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_insert) on the new table.        

- Following the table name, specify the alterations to be made.          If none are given, [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table)          does nothing.        

- The syntax for many of the permissible alterations is similar          to clauses of the [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table)          statement. *column_definition*          clauses use the same syntax for `ADD` and          `CHANGE` as for [`CREATE          TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table). For more information, see          [Section 13.1.17, “CREATE TABLE Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table).        

- The word `COLUMN` is optional and can be          omitted.        

- Multiple `ADD`, `ALTER`,          `DROP`, and `CHANGE` clauses          are permitted in a single [`ALTER          TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) statement, separated by commas. This is a          MySQL extension to standard SQL, which permits only one of          each clause per [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table)          statement. For example, to drop multiple columns in a single          statement, do this:        

  ```sql
  ALTER TABLE t2 DROP COLUMN c, DROP COLUMN d;

  ```

- If a storage engine does not support an attempted          [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) operation, a          warning may result. Such warnings can be displayed with          [`SHOW WARNINGS`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-warnings). See          [Section 13.7.5.41, “SHOW WARNINGS Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-warnings). For information on          troubleshooting [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table),          see [Section B.5.6.1, “Problems with ALTER TABLE”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/error-handling.html#alter-table-problems).        

- For usage examples, see          [Section 13.1.7.3, “ALTER TABLE Examples”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table-examples).        

- With the [`mysql_info()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/connectors-apis.html#mysql-info) C API          function, you can find out how many rows were copied by          [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table), and (when          `IGNORE` is used) how many rows were deleted          due to duplication of unique key values. See          [Section 23.8.7.35, “mysql_info()”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/connectors-apis.html#mysql-info).

  ​

There are several additional aspects to the `ALTER      TABLE` statement, described under the following topics in      this section:

- [Table Options](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table-options)
- [Performance, Storage, and Concurrency Considerations](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table-performance)
- [Adding and Dropping Columns](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table-add-drop-column)
- [Renaming, Redefining, and Reordering Columns](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table-redefine-column)
- [Primary Keys and Indexes](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table-index)
- [Foreign Keys](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table-foreign-key)
- [Changing the Character Set](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table-character-set)
- [Discarding and Importing InnoDB Tablespaces](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table-discard-import)
- [Row Order for MyISAM Tables](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table-row-order)
- [Partitioning Options](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table-partition-options)

#### Table Options

​      *table_options* signifies table options      of the kind that can be used in the [`CREATE      TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) statement, such as `ENGINE`,      `AUTO_INCREMENT`,      `AVG_ROW_LENGTH`, `MAX_ROWS`, or      `ROW_FORMAT`.    

​      For descriptions of all table options, see      [Section 13.1.17, “CREATE TABLE Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table). However,      [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) ignores `DATA      DIRECTORY` and `INDEX DIRECTORY` when      given as table options. [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table)      permits them only as partitioning options, and, as of MySQL      5.5.54, requires that you have the `FILE`      privilege.    

​      Use of table options with [`ALTER      TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) provides a convenient way of altering single table      characteristics. For example:

- ​          If `t1` is currently not an          `InnoDB` table, this statement changes its          storage engine to `InnoDB`:        

  ```
  ALTER TABLE t1 ENGINE = InnoDB;

  ```

  - ​              See [Section 14.11.1.4, “Converting Tables from MyISAM to InnoDB”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#converting-tables-to-innodb) for              considerations when switching tables to the              `InnoDB` storage engine.            
  - ​              When you specify an `ENGINE` clause,              [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) rebuilds the              table. This is true even if the table already has the              specified storage engine.            
  - ​              You can also use `ALTER TABLE              *tbl_name* FORCE` to              perform a “null” alter operation that              rebuilds the table.            
  - ​              The outcome of attempting to change the storage engine of              a table is affected by whether the desired storage engine              is available and the setting of the              [`NO_ENGINE_SUBSTITUTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_no_engine_substitution)              SQL mode, as described in [Section 5.1.8, “Server SQL Modes”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sql-mode).            
  - ​              To prevent inadvertent loss of data,              [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) cannot be used              to change the storage engine of a table to              `MERGE` or `BLACKHOLE`.

- ​          To change the `InnoDB` table to use          compressed row-storage format:        

  ```
  ALTER TABLE t1 ROW_FORMAT = COMPRESSED;

  ```

- ​          To reset the current auto-increment value:        

  ```
  ALTER TABLE t1 AUTO_INCREMENT = 13;

  ```

  ​          You cannot reset the counter to a value less than or equal to          any that have already been used. For          `MyISAM`, if the value is less than or equal          to the maximum value currently in the          `AUTO_INCREMENT` column, the value is reset          to the current maximum plus one. For          `InnoDB`, *if the value is less than          the current maximum value in the column, no error occurs and          the current sequence value is not changed.*        

- ​          To change the default table character set:        

  ```
  ALTER TABLE t1 CHARACTER SET = utf8;

  ```

  ​          See also [Changing the Character Set](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table-character-set).        

- ​          To add (or change) a table comment:        

  ```
  ALTER TABLE t1 COMMENT = 'New table comment';

  ```

​      To verify that the table options were changed as intended, use      [`SHOW CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-create-table), or query the      [`INFORMATION_SCHEMA.TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/information-schema.html#tables-table) table.

#### Performance, Storage, and Concurrency Considerations

​      Some [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) operations can be      performed in place without making a temporary copy of the table.      In-place operations tend to be very fast.    

​      Other [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) operations      perform the alteration on a temporary copy of the table, which can      require more time, particularly for large tables.    

​      In-place [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) operations      that do not require creating a temporary copy of the original      table include:

- ​          For `ALTER TABLE *tbl_name*          RENAME TO *new_tbl_name*`          without any other options, MySQL renames files that correspond          to the table *tbl_name* without          making a copy. (You can also use the          [`RENAME TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#rename-table) statement to          rename tables. See [Section 13.1.32, “RENAME TABLE Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#rename-table).) Privileges          granted specifically for the renamed table are not migrated to          the new name. They must be changed manually.        
- ​          Alterations that modify only table metadata and not table data          are immediate because the server only needs to alter the table          `.frm` file, not touch table contents. The          following changes are made in this way:
  - ​              Renaming a column, except for the              [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html) storage engine.            
  - ​              Changing the default value of a column (except for              [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) tables; see              [Limitations              of `NDBCLUSTER` online              operations](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table-online-limitations)).            
  - ​              Changing the definition of an              [`ENUM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum) or              [`SET`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#set) column by adding new              enumeration or set members to the *end*              of the list of valid member values, as long as the storage              size of the data type does not change. For example, adding              a member to a [`SET`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#set) column              that has 8 members changes the required storage per value              from 1 byte to 2 bytes; this requires a table copy. Adding              members in the middle of the list causes renumbering of              existing members, which requires a table copy.
- ​          Renaming an index, except for          [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html).        
- ​          Adding or dropping an index, for          [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html) and          [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html). See          [Section 14.16, “InnoDB Fast Index Creation”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#innodb-create-index).        
- ​          For [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) tables, operations          that add and drop indexes on variable-width columns occur          online, without table copying and without blocking concurrent          DML actions for most of their duration. See          [Section 13.1.7.2, “ALTER TABLE Online Operations in NDB Cluster 7.2”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table-online-operations).

​      [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) operations that are      **not** performed in place make a      temporary copy of the original table. MySQL waits for other      operations that are modifying the table, then proceeds. It      incorporates the alteration into the copy, deletes the original      table, and renames the new one. While [`ALTER      TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) is executing, the original table is readable by      other sessions (with the exception noted shortly). Updates and      writes to the table that begin after the      [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) operation begins are      stalled until the new table is ready, then are automatically      redirected to the new table without any failed updates. The      temporary copy of the original table is created in the database      directory of the new table. This can differ from the database      directory of the original table for [`ALTER      TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) operations that rename the table to a different      database.    

​      The exception referred to earlier is that      [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) blocks reads (not just      writes) at the point where it is ready to install a new version of      the table `.frm` file, discard the old file,      and clear outdated table structures from the table and table      definition caches. At this point, it must acquire an exclusive      lock. To do so, it waits for current readers to finish, and blocks      new reads (and writes).    

​      For `MyISAM` tables, you can speed up index      re-creation (the slowest part of the alteration process) by      setting the      [`myisam_sort_buffer_size`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_myisam_sort_buffer_size) system      variable to a high value.    

​      For `InnoDB` tables, a table-copying      [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) operation on table that      resides in a shared tablespace such as the      [system tablespace](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/glossary.html#glos_system_tablespace)      can increase the amount of space used by the tablespace. Such      operations require as much additional space as the data in the      table plus indexes. For a table that resides in a shared      tablespace, the additional space used during a table-copying      [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) operation is not      released back to the operating system as it is for a table that      resides in a      [file-per-table](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/glossary.html#glos_file_per_table)      tablespace.    

​      To force use of the table-copy method for an `ALTER      TABLE` operation that would otherwise not use it, set the      [`old_alter_table`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_old_alter_table) system variable      to `ON`.    

​      `ALTER TABLE` with `ADD      PARTITION`, `DROP PARTITION`,      `COALESCE PARTITION`, `REBUILD      PARTITION`, or `REORGANIZE PARTITION`      does not create temporary tables (except when used with      [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) tables); however, these      operations can and do create temporary partition files.    

​      `ADD` or `DROP` operations for      `RANGE` or `LIST` partitions are      immediate operations or nearly so. `ADD` or      `COALESCE` operations for `HASH`      or `KEY` partitions copy data between all      partitions, unless `LINEAR HASH` or      `LINEAR KEY` was used; this is effectively the      same as creating a new table, although the `ADD`      or `COALESCE` operation is performed partition by      partition. `REORGANIZE` operations copy only      changed partitions and do not touch unchanged ones.

Note

​        Pending [`INSERT DELAYED`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert-delayed) statements        are lost if a table is write locked and        [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) is used to modify the        table structure.

#### Adding and Dropping Columns

​      Use `ADD` to add new columns to a table, and      `DROP` to remove existing columns.    

​      `DROP *col_name*` is a      MySQL extension to standard SQL.    

​      To add a column at a specific position within a table row, use      `FIRST` or `AFTER      *col_name*`. The default is to      add the column last.    

​      If a table contains only one column, the column cannot be dropped.      If what you intend is to remove the table, use the      [`DROP TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-table) statement instead.    

​      If columns are dropped from a table, the columns are also removed      from any index of which they are a part. If all columns that make      up an index are dropped, the index is dropped as well.

#### Renaming, Redefining, and Reordering Columns

​      The `CHANGE`, `MODIFY`, and      `ALTER` clauses enable the names and definitions      of existing columns to be altered. They have these comparative      characteristics:

- ​          `CHANGE`:
  - ​              Can rename a column and change its definition, or both.            
  - ​              Has more capability than `MODIFY`, but at              the expense of convenience for some operations.              `CHANGE` requires naming the column twice              if not renaming it.            
  - ​              With `FIRST` or `AFTER`,              can reorder columns.
- ​          `MODIFY`:
  - ​              Can change a column definition but not its name.            
  - ​              More convenient than `CHANGE` to change a              column definition without renaming it.            
  - ​              With `FIRST` or `AFTER`,              can reorder columns.
- ​          `ALTER`: Used only to change a column default          value.

​      `CHANGE` is a MySQL extension to standard SQL.      `MODIFY` is a MySQL extension for Oracle      compatibility.    

​      To alter a column to change both its name and definition, use      `CHANGE`, specifying the old and new names and      the new definition. For example, to rename an `INT NOT      NULL` column from `a` to      `b` and change its definition to use the      `BIGINT` data type while retaining the      `NOT NULL` attribute, do this:    

```
ALTER TABLE t1 CHANGE a b BIGINT NOT NULL;

```

​      To change a column definition but not its name, use      `CHANGE` or `MODIFY`. With      `CHANGE`, the syntax requires two column names,      so you must specify the same name twice to leave the name      unchanged. For example, to change the definition of column      `b`, do this:    

```
ALTER TABLE t1 CHANGE b b INT NOT NULL;

```

​      `MODIFY` is more convenient to change the      definition without changing the name because it requires the      column name only once:    

```
ALTER TABLE t1 MODIFY b INT NOT NULL;

```

​      To change a column name but not its definition, use      `CHANGE`. The syntax requires a column      definition, so to leave the definition unchanged, you must      respecify the definition the column currently has. For example, to      rename an `INT NOT NULL` column from      `b` to `a`, do this:    

```
ALTER TABLE t1 CHANGE b a INT NOT NULL;

```

​      For column definition changes using `CHANGE` or      `MODIFY`, the definition must include the data      type and all attributes that should apply to the new column, other      than index attributes such as `PRIMARY KEY` or      `UNIQUE`. Attributes present in the original      definition but not specified for the new definition are not      carried forward. Suppose that a column `col1` is      defined as `INT UNSIGNED DEFAULT 1 COMMENT 'my      column'` and you modify the column as follows, intending      to change only `INT` to      `BIGINT`:    

```
ALTER TABLE t1 MODIFY col1 BIGINT;

```

​      That statement changes the data type from `INT`      to `BIGINT`, but it also drops the      `UNSIGNED`, `DEFAULT`, and      `COMMENT` attributes. To retain them, the      statement must include them explicitly:    

```
ALTER TABLE t1 MODIFY col1 BIGINT UNSIGNED DEFAULT 1 COMMENT 'my column';

```

​      For data type changes using `CHANGE` or      `MODIFY`, MySQL tries to convert existing column      values to the new type as well as possible.

Warning

​        This conversion may result in alteration of data. For example,        if you shorten a string column, values may be truncated. To        prevent the operation from succeeding if conversions to the new        data type would result in loss of data, enable strict SQL mode        before using [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) (see        [Section 5.1.8, “Server SQL Modes”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sql-mode)).

​      If you use `CHANGE` or `MODIFY`      to shorten a column for which an index exists on the column, and      the resulting column length is less than the index length, MySQL      shortens the index automatically.    

​      For columns renamed by `CHANGE`, MySQL      automatically renames these references to the renamed column:

- ​          Indexes that refer to the old column, including indexes and          disabled `MyISAM` indexes.

​      For columns renamed by `CHANGE`, MySQL does not      automatically rename these references to the renamed column:

- ​          Foreign keys that refer to the old column.        
- ​          Partition expressions that refer to the renamed column. You          must use `CHANGE` to redefine such          expressions in the same [`ALTER          TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) statement as the one that renames the column.        
- ​          Views and stored programs that refer to the renamed column.          You must manually alter the definition of these objects to          refer to the new column name.

​      To reorder columns within a table, use `FIRST`      and `AFTER` in `CHANGE` or      `MODIFY` operations.    

​      `ALTER ... SET DEFAULT` or `ALTER ...      DROP DEFAULT` specify a new default value for a column or      remove the old default value, respectively. If the old default is      removed and the column can be `NULL`, the new      default is `NULL`. If the column cannot be      `NULL`, MySQL assigns a default value as      described in [Section 11.6, “Data Type Default Values”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#data-type-defaults).

#### Primary Keys and Indexes

​      `DROP PRIMARY KEY` drops the      [primary key](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/glossary.html#glos_primary_key). If there is      no primary key, an error occurs. For information about the      performance characteristics of primary keys, especially for      `InnoDB` tables, see      [Section 8.3.2, “Primary Key Optimization”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/optimization.html#primary-key-optimization).    

​      If you add a `UNIQUE INDEX` or `PRIMARY      KEY` to a table, MySQL stores it before any nonunique      index to permit detection of duplicate keys as early as possible.    

​      `IGNORE` is a MySQL extension to standard SQL. It      controls how [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) works if      there are duplicates on unique keys in the new table or if      warnings occur when strict mode is enabled. If      `IGNORE` is not specified, the copy is aborted      and rolled back if duplicate-key errors occur. If      `IGNORE` is specified, only one row is used of      rows with duplicates on a unique key. The other conflicting rows      are deleted. Incorrect values are truncated to the closest      matching acceptable value.

Note

​        Due to a bug related to        [Fast Index        Creation](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/glossary.html#glos_fast_index_creation) (Bug #40344), `ALTER IGNORE TABLE ...        ADD UNIQUE INDEX` does not delete duplicate rows. The        `IGNORE` keyword is ignored. If any duplicate        rows exist, the operation fails with a Duplicate        entry error. A workaround is to set        [`old_alter_table=1`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_old_alter_table) prior to        running an `ALTER IGNORE TABLE ... ADD UNIQUE        INDEX` statement.      

```
SET SESSION old_alter_table=1

```

​      [`DROP INDEX`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-index) removes an index. This      is a MySQL extension to standard SQL. See      [Section 13.1.24, “DROP INDEX Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-index). To determine index names, use      `SHOW INDEX FROM      *tbl_name*`.    

​      Some storage engines permit you to specify an index type when      creating an index. The syntax for the      *index_type* specifier is `USING      *type_name*`. For details about      `USING`, see [Section 13.1.13, “CREATE INDEX Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-index). The      preferred position is after the column list. Support for use of      the option before the column list will be removed in a future      MySQL release.    

​      *index_option* values specify additional      options for an index. For details about permissible      *index_option* values, see      [Section 13.1.13, “CREATE INDEX Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-index).    

​      If you use [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) on a      `MyISAM` table, all nonunique indexes are created      in a separate batch (as for [`REPAIR      TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#repair-table)). This should make [`ALTER      TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) much faster when you have many indexes.    

​      For `MyISAM` tables, key updating can be      controlled explicitly. Use `ALTER TABLE ... DISABLE      KEYS` to tell MySQL to stop updating nonunique indexes.      Then use `ALTER TABLE ... ENABLE KEYS` to      re-create missing indexes. `MyISAM` does this      with a special algorithm that is much faster than inserting keys      one by one, so disabling keys before performing bulk insert      operations should give a considerable speedup. Using      `ALTER TABLE ... DISABLE KEYS` requires the      [`INDEX`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_index) privilege in addition to the      privileges mentioned earlier.    

​      While the nonunique indexes are disabled, they are ignored for      statements such as [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) and      [`EXPLAIN`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#explain) that otherwise would use      them.    

​      After an [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) statement, it      may be necessary to run [`ANALYZE      TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#analyze-table) to update index cardinality information. See      [Section 13.7.5.23, “SHOW INDEX Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-index).

#### Foreign Keys

​      If [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) for an      `InnoDB` table results in changes to column      values (for example, because a column is truncated),      `InnoDB`'s `FOREIGN KEY`      constraint checks do not notice possible violations caused by      changing the values.    

​      The `FOREIGN KEY` and      `REFERENCES` clauses are supported by the      `InnoDB` storage engine, which implements      `ADD [CONSTRAINT [*symbol*]]      FOREIGN KEY [*index_name*] (...)      REFERENCES ... (...)`. See      [Section 14.11.1.6, “InnoDB and FOREIGN KEY Constraints”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#innodb-foreign-key-constraints). For other      storage engines, the clauses are parsed but ignored. The      `CHECK` clause is parsed but ignored by all      storage engines. See [Section 13.1.17, “CREATE TABLE Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table). The reason      for accepting but ignoring syntax clauses is for compatibility, to      make it easier to port code from other SQL servers, and to run      applications that create tables with references. See      [Section 1.7.2, “MySQL Differences from Standard SQL”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/introduction.html#differences-from-ansi).    

​      For [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table), unlike      [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table), `ADD FOREIGN      KEY` ignores *index_name* if      given and uses an automatically generated foreign key name. As a      workaround, include the `CONSTRAINT` clause to      specify the foreign key name:    

```
ADD CONSTRAINT name FOREIGN KEY (....) ...

```

Important

​        MySQL silently ignores inline `REFERENCES`        specifications, where the references are defined as part of the        column specification. MySQL accepts only        `REFERENCES` clauses defined as part of a        separate `FOREIGN KEY` specification.

Note

​        Partitioned `InnoDB` tables do not support        foreign keys. For more information, see        [Section 19.5.2, “Partitioning Limitations Relating to Storage Engines”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/partitioning.html#partitioning-limitations-storage-engines).

​      `InnoDB` supports the use of      [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) to drop foreign keys:    

```
ALTER TABLE tbl_name DROP FOREIGN KEY fk_symbol;

```

​      Adding and dropping a foreign key in separate clauses of a single      [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) statement may be      problematic in some cases and is therefore unsupported. Use      separate statements for each operation.    

​      `ALTER TABLE *tbl_name* RENAME      *new_tbl_name*` changes      internally generated foreign key constraint names and user-defined      foreign key constraint names that contain the string      “*tbl_name*_ibfk_” to      reflect the new table name. `InnoDB` interprets      foreign key constraint names that contain the string      “*tbl_name*_ibfk_” as      internally generated names.

#### Changing the Character Set

​            To change the table default character set and all character      columns ([`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),      [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),      [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob)) to a new character set, use a      statement like this:    

```
ALTER TABLE tbl_name
CONVERT TO CHARACTER SET charset_name [COLLATE collation_name];

```

​      The statement also changes the collation of all character columns.      If you specify no `COLLATE` clause to indicate      which collation to use, the statement uses default collation for      the character set. If this collation is inappropriate for the      intended table use (for example, if it would change from a      case-sensitive collation to a case-insensitive collation), specify      a collation explicitly.    

​      For a column that has a data type of      [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) or one of the      [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) types, `CONVERT TO      CHARACTER SET` changes the data type as necessary to      ensure that the new column is long enough to store as many      characters as the original column. For example, a      [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) column has two length bytes,      which store the byte-length of values in the column, up to a      maximum of 65,535. For a `latin1`      [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) column, each character      requires a single byte, so the column can store up to 65,535      characters. If the column is converted to `utf8`,      each character might require up to three bytes, for a maximum      possible length of 3 × 65,535 = 196,605 bytes. That length      does not fit in a [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) column's      length bytes, so MySQL converts the data type to      [`MEDIUMTEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob), which is the smallest      string type for which the length bytes can record a value of      196,605. Similarly, a [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char)      column might be converted to      [`MEDIUMTEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob).    

​      To avoid data type changes of the type just described, do not use      `CONVERT TO CHARACTER SET`. Instead, use      `MODIFY` to change individual columns. For      example:    

```
ALTER TABLE t MODIFY latin1_text_col TEXT CHARACTER SET utf8;
ALTER TABLE t MODIFY latin1_varchar_col VARCHAR(M) CHARACTER SET utf8;

```

​      If you specify `CONVERT TO CHARACTER SET binary`,      the [`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),      [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char), and      [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) columns are converted to their      corresponding binary string types      ([`BINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary),      [`VARBINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary),      [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob)). This means that the columns      no longer will have a character set attribute and a subsequent      `CONVERT TO` operation will not apply to them.    

​      If *charset_name* is      `DEFAULT`, the database character set is used.

Warning

​        The `CONVERT TO` operation converts column        values between the original and named character sets. This is        *not* what you want if you have a column in        one character set (like `latin1`) but the        stored values actually use some other, incompatible character        set (like `utf8`). In this case, you have to do        the following for each such column:      

```
ALTER TABLE t1 CHANGE c1 c1 BLOB;
ALTER TABLE t1 CHANGE c1 c1 TEXT CHARACTER SET utf8;

```

​        The reason this works is that there is no conversion when you        convert to or from [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) columns.

​      To change only the *default* character set for      a table, use this statement:    

```
ALTER TABLE tbl_name DEFAULT CHARACTER SET charset_name;

```

​      The word `DEFAULT` is optional. The default      character set is the character set that is used if you do not      specify the character set for columns that you add to a table      later (for example, with `ALTER TABLE ... ADD      column`).    

​      When the [`foreign_key_checks`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_foreign_key_checks)      system variable is enabled, which is the default setting,      character set conversion is not permitted on tables that include a      character string column used in a foreign key constraint. The      workaround is to disable      [`foreign_key_checks`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_foreign_key_checks) before      performing the character set conversion. You must perform the      conversion on both tables involved in the foreign key constraint      before re-enabling      [`foreign_key_checks`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_foreign_key_checks). If you      re-enable [`foreign_key_checks`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_foreign_key_checks)      after converting only one of the tables, an `ON DELETE      CASCADE` or `ON UPDATE CASCADE`      operation could corrupt data in the referencing table due to      implicit conversion that occurs during these operations (Bug      #45290, Bug #74816).

#### Discarding and Importing InnoDB Tablespaces

​      For an `InnoDB` table that is created with its      own tablespace in an `.ibd` file, that file can      be discarded and imported. To discard the      `.ibd` file, use this statement:    

```
ALTER TABLE tbl_name DISCARD TABLESPACE;

```

​      This deletes the current `.ibd` file, so be      sure that you have a backup first. Attempting to access the table      while the tablespace file is discarded results in an error.    

​      To import the backup `.ibd` file back into the      table, copy it into the database directory, and then issue this      statement:    

```
ALTER TABLE tbl_name IMPORT TABLESPACE;

```

​      The tablespace file must have been created on the server into      which it is imported later.

Note

​        The [`ALTER TABLE ...        IMPORT TABLESPACE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) feature does not enforce foreign key        constraints on imported data.

​      See [Section 14.10.4, “InnoDB File-Per-Table Tablespaces”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#innodb-multiple-tablespaces).

#### Row Order for MyISAM Tables

​      `ORDER BY` enables you to create the new table      with the rows in a specific order. This option is useful primarily      when you know that you query the rows in a certain order most of      the time. By using this option after major changes to the table,      you might be able to get higher performance. In some cases, it      might make sorting easier for MySQL if the table is in order by      the column that you want to order it by later.

Note

​        The table does not remain in the specified order after inserts        and deletes.

​      `ORDER BY` syntax permits one or more column      names to be specified for sorting, each of which optionally can be      followed by `ASC` or `DESC` to      indicate ascending or descending sort order, respectively. The      default is ascending order. Only column names are permitted as      sort criteria; arbitrary expressions are not permitted. This      clause should be given last after any other clauses.    

​      `ORDER BY` does not make sense for      `InnoDB` tables because `InnoDB`      always orders table rows according to the      [clustered index](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/glossary.html#glos_clustered_index).    

​      When used on a partitioned table, `ALTER TABLE ... ORDER      BY` orders rows within each partition only.

#### Partitioning Options

​      *partition_options* signifies options      that can be used with partitioned tables for repartitioning, to      add, drop, discard, merge, and split partitions, and to perform      partitioning maintenance.    

​      It is possible for an [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table)      statement to contain a `PARTITION BY` or      `REMOVE PARTITIONING` clause in an addition to      other alter specifications, but the `PARTITION      BY` or `REMOVE PARTITIONING` clause must      be specified last after any other specifications. The `ADD      PARTITION`, `DROP PARTITION`,      `COALESCE PARTITION`, `REORGANIZE      PARTITION`, `ANALYZE PARTITION`,      `CHECK PARTITION`, and `REPAIR      PARTITION` options cannot be combined with other alter      specifications in a single `ALTER TABLE`, since      the options just listed act on individual partitions.    

​      For a list of partition options and a description of each, see      [Section 13.1.17, “CREATE TABLE Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table). For additional information, see      [Section 13.1.7.1, “ALTER TABLE Partition Operations”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table-partition-operations).

#### 13.1.7.1 ALTER TABLE Partition Operations

​        Partitioning-related clauses for [`ALTER        TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) can be used with partitioned tables for        repartitioning, to add, drop, discard, merge, and split        partitions, and to perform partitioning maintenance.

- ​            Simply using a *partition_options*            clause with [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) on a            partitioned table repartitions the table according to the            partitioning scheme defined by the            *partition_options*. This clause            always begins with `PARTITION BY`, and            follows the same syntax and other rules as apply to the            *partition_options* clause for            [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) (for more            detailed information, see [Section 13.1.17, “CREATE TABLE Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table)),            and can also be used to partition an existing table that is            not already partitioned. For example, consider a            (nonpartitioned) table defined as shown here:          

  ```
  CREATE TABLE t1 (
      id INT,
      year_col INT
  );

  ```

  ​            This table can be partitioned by `HASH`,            using the `id` column as the partitioning            key, into 8 partitions by means of this statement:          

  ```
  ALTER TABLE t1
      PARTITION BY HASH(id)
      PARTITIONS 8;

  ```

  ​            MySQL 5.5.31 and later supports an            `ALGORITHM` option with            `[SUB]PARTITION BY [LINEAR] KEY`.            `ALGORITHM=1` causes the server to use the            same key-hashing functions as MySQL 5.1 when computing the            placement of rows in partitions;            `ALGORITHM=2` means that the server employs            the key-hashing functions implemented and used by default            for new `KEY` partitioned tables in MySQL            5.5 and later. (Partitioned tables created with the            key-hashing functions employed in MySQL 5.5 and later cannot            be used by a MySQL 5.1 server.) Not specifying the option            has the same effect as using `ALGORITHM=2`.            This option is intended for use chiefly when upgrading or            downgrading `[LINEAR] KEY` partitioned            tables between MySQL 5.1 and later MySQL versions, or for            creating tables partitioned by `KEY` or            `LINEAR KEY` on a MySQL 5.5 or later server            which can be used on a MySQL 5.1 server.          

  ​            To upgrade a `KEY` partitioned table that            was created in MySQL 5.1, first execute            [`SHOW CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-create-table) and note            the exact columns and number of partitions shown. Now            execute an `ALTER TABLE` statement using            exactly the same column list and number of partitions as in            the `CREATE TABLE` statement, while adding            `ALGORITHM=2` immediately following the            `PARTITION BY` keywords. (You should also            include the `LINEAR` keyword if it was used            for the original table definition.) An example from a            session in the [**mysql**](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/programs.html#mysql) client is shown            here:          

  ```
  mysql> SHOW CREATE TABLE p\G
  *************************** 1. row ***************************
         Table: p
  Create Table: CREATE TABLE `p` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `cd` datetime NOT NULL,
    PRIMARY KEY (`id`)
  ) ENGINE=InnoDB DEFAULT CHARSET=latin1
  /*!50100 PARTITION BY LINEAR KEY (id)
  PARTITIONS 32 */
  1 row in set (0.00 sec)

  mysql> ALTER TABLE p PARTITION BY LINEAR KEY ALGORITHM=2 (id) PARTITIONS 32;
  Query OK, 0 rows affected (5.34 sec)
  Records: 0  Duplicates: 0  Warnings: 0

  mysql> SHOW CREATE TABLE p\G
  *************************** 1. row ***************************
         Table: p
  Create Table: CREATE TABLE `p` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `cd` datetime NOT NULL,
    PRIMARY KEY (`id`)
  ) ENGINE=InnoDB DEFAULT CHARSET=latin1
  /*!50100 PARTITION BY LINEAR KEY (id)
  PARTITIONS 32 */
  1 row in set (0.00 sec)

  ```

  ​            Downgrading a table created using the default key-hashing            used in MySQL 5.5 and later to enable its use by a MySQL 5.1            server is similar, except in this case you should use            `ALGORITHM=1` to force the table's            partitions to be rebuilt using the MySQL 5.1 key-hashing            functions. It is recommended that you not do this except            when necessary for compatibility with a MySQL 5.1 server, as            the improved `KEY` hashing functions used            by default in MySQL 5.5 and later provide fixes for a number            of issues found in the older implementation.

  Note

  ​              A table upgraded by means of `ALTER TABLE ...              PARTITION BY ALGORITHM=2 [LINEAR] KEY ...` can no              longer be used by a MySQL 5.1 server. (Such a table would              need to be downgraded with `ALTER TABLE ...              PARTITION BY ALGORITHM=1 [LINEAR] KEY ...` before              it could be used again by a MySQL 5.1 server.)

  ​            The table that results from using an `ALTER TABLE            ... PARTITION BY` statement must follow the same            rules as one created using `CREATE TABLE ...            PARTITION BY`. This includes the rules governing            the relationship between any unique keys (including any            primary key) that the table might have, and the column or            columns used in the partitioning expression, as discussed in            [Section 19.5.1, “Partitioning Keys, Primary Keys, and Unique Keys”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/partitioning.html#partitioning-limitations-partitioning-keys-unique-keys).            The `CREATE TABLE ... PARTITION BY` rules            for specifying the number of partitions also apply to            `ALTER TABLE ... PARTITION BY`.          

  ​            The *partition_definition* clause            for `ALTER TABLE ADD PARTITION` supports            the same options as the clause of the same name for the            [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) statement. (See            [Section 13.1.17, “CREATE TABLE Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table), for the syntax and            description.) Suppose that you have the partitioned table            created as shown here:          

  ```
  CREATE TABLE t1 (
      id INT,
      year_col INT
  )
  PARTITION BY RANGE (year_col) (
      PARTITION p0 VALUES LESS THAN (1991),
      PARTITION p1 VALUES LESS THAN (1995),
      PARTITION p2 VALUES LESS THAN (1999)
  );

  ```

  ​            You can add a new partition `p3` to this            table for storing values less than `2002`            as follows:          

  ```
  ALTER TABLE t1 ADD PARTITION (PARTITION p3 VALUES LESS THAN (2002));

  ```

  ​            `DROP PARTITION` can be used to drop one or            more `RANGE` or `LIST`            partitions. This statement cannot be used with            `HASH` or `KEY`            partitions; instead, use `COALESCE            PARTITION` (see below). Any data that was stored in            the dropped partitions named in the            *partition_names* list is            discarded. For example, given the table            `t1` defined previously, you can drop the            partitions named `p0` and            `p1` as shown here:          

  ```
  ALTER TABLE t1 DROP PARTITION p0, p1;

  ```

  Note

  ​              `DROP PARTITION` does not work with              tables that use the              [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) storage engine.              See [Section 19.3.1, “Management of RANGE and LIST Partitions”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/partitioning.html#partitioning-management-range-list),              and [Section 18.1.6, “Known Limitations of NDB Cluster”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html#mysql-cluster-limitations).

  ​            `ADD PARTITION` and `DROP            PARTITION` do not currently support `IF            [NOT] EXISTS`.          

  ​            Renames of partitioned tables are supported. You can rename            individual partitions indirectly using `ALTER TABLE            ... REORGANIZE PARTITION`; however, this operation            copies the partition's data.          

  ​            To delete rows from selected partitions, use the            `TRUNCATE PARTITION` option. This option            takes a list of one or more comma-separated partition names.            For example, consider the table `t1` as            defined here:          

  ```
  CREATE TABLE t1 (
      id INT,
      year_col INT
  )
  PARTITION BY RANGE (year_col) (
      PARTITION p0 VALUES LESS THAN (1991),
      PARTITION p1 VALUES LESS THAN (1995),
      PARTITION p2 VALUES LESS THAN (1999),
      PARTITION p3 VALUES LESS THAN (2003),
      PARTITION p4 VALUES LESS THAN (2007)
  );

  ```

  ​            To delete all rows from partition `p0`, use            the following statement:          

  ```
  ALTER TABLE t1 TRUNCATE PARTITION p0;

  ```

  ​            The statement just shown has the same effect as the            following [`DELETE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#delete) statement:          

  ```
  DELETE FROM t1 WHERE year_col < 1991;

  ```

  ​            When truncating multiple partitions, the partitions do not            have to be contiguous: This can greatly simplify delete            operations on partitioned tables that would otherwise            require very complex `WHERE` conditions if            done with [`DELETE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#delete) statements.            For example, this statement deletes all rows from partitions            `p1` and `p3`:          

  ```
  ALTER TABLE t1 TRUNCATE PARTITION p1, p3;

  ```

  ​            An equivalent [`DELETE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#delete)            statement is shown here:          

  ```
  DELETE FROM t1 WHERE
      (year_col >= 1991 AND year_col < 1995)
      OR
      (year_col >= 2003 AND year_col < 2007);

  ```

  ​            If you use the `ALL` keyword in place of            the list of partition names, the statement acts on all table            partitions.          

  ​            `TRUNCATE PARTITION` merely deletes rows;            it does not alter the definition of the table itself, or of            any of its partitions.

  Note

  ​              `TRUNCATE PARTITION` does not work with              subpartitions.

  ​            To verify that the rows were dropped, check the            `INFORMATION_SCHEMA.PARTITIONS` table,            using a query such as this one:          

  ```
  SELECT PARTITION_NAME, TABLE_ROWS
      FROM INFORMATION_SCHEMA.PARTITIONS
      WHERE TABLE_NAME = 't1';

  ```

  ​            `TRUNCATE PARTITION` is supported only for            partitioned tables that use the            [`MyISAM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#myisam-storage-engine),            [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html), or            [`MEMORY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#memory-storage-engine) storage engine. It also            works on [`BLACKHOLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#blackhole-storage-engine) tables (but            has no effect). It is not supported for            [`ARCHIVE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#archive-storage-engine) tables.          

  ​            `COALESCE PARTITION` can be used with a            table that is partitioned by `HASH` or            `KEY` to reduce the number of partitions by            *number*. Suppose that you have            created table `t2` as follows:          

  ```
  CREATE TABLE t2 (
      name VARCHAR (30),
      started DATE
  )
  PARTITION BY HASH( YEAR(started) )
  PARTITIONS 6;

  ```

  ​            To reduce the number of partitions used by            `t2` from 6 to 4, use the following            statement:          

  ```
  ALTER TABLE t2 COALESCE PARTITION 2;

  ```

  ​            The data contained in the last            *number* partitions will be merged            into the remaining partitions. In this case, partitions 4            and 5 will be merged into the first 4 partitions (the            partitions numbered 0, 1, 2, and 3).          

  ​            To change some but not all the partitions used by a            partitioned table, you can use `REORGANIZE            PARTITION`. This statement can be used in several            ways:

  - ​                To merge a set of partitions into a single partition.                This is done by naming several partitions in the                *partition_names* list and                supplying a single definition for                *partition_definition*.              

  - ​                To split an existing partition into several partitions.                Accomplish this by naming a single partition for                *partition_names* and providing                multiple                *partition_definitions*.              

  - ​                To change the ranges for a subset of partitions defined                using `VALUES LESS THAN` or the value                lists for a subset of partitions defined using                `VALUES IN`.              

  - ​                This statement may also be used without the                `*partition_names* INTO                (*partition_definitions*)`                option on tables that are automatically partitioned                using `HASH` partitioning to force                redistribution of data. (Currently, only                [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) tables are                automatically partitioned in this way.) This is useful                in NDB Cluster where, after you have added new NDB                Cluster data nodes online to an existing NDB Cluster,                you wish to redistribute existing NDB Cluster table data                to the new data nodes. In such cases, you should invoke                the statement with the `ONLINE` option;                in other words, as shown here:              

    ```
    ALTER ONLINE TABLE table REORGANIZE PARTITION;

    ```

    ​                You cannot perform other DDL concurrently with online                table reorganization—that is, no other DDL                statements can be issued while an `ALTER ONLINE                TABLE ... REORGANIZE PARTITION` statement is                executing. For more information about adding NDB Cluster                data nodes online, see                [Section 18.5.13, “Adding NDB Cluster Data Nodes Online”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html#mysql-cluster-online-add-node).              

    ​                `ALTER ONLINE TABLE ... REORGANIZE                PARTITION` does not work with tables which were                created using the `MAX_ROWS` option,                because it uses the constant `MAX_ROWS`                value specified in the original                [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) statement to                determine the number of partitions required, so no new                partitions are created. Beginning with MySQL NDB Cluster                7.2.6, you can use `ALTER ONLINE TABLE ...                MAX_ROWS=*rows*` to                increase the maximum number of rows for such a table; in                this case, `ALTER ONLINE TABLE ... REORGANIZE                PARTITION` is not needed (and causes an error                if executed). The value of                *rows* must be greater than the                value specified for `MAX_ROWS` in the                original `CREATE TABLE` statement for                this to work.              

    ​                Attempting to use `REORGANIZE                PARTITION` without the                `*partition_names* INTO                (*partition_definitions*)`                option on explicitly partitioned tables results in the                error REORGANIZE PARTITION without parameters                can only be used on auto-partitioned tables using HASH                partitioning.

  Note

  ​              For partitions that have not been explicitly named, MySQL              automatically provides the default names              `p0`, `p1`,              `p2`, and so on. The same is true with              regard to subpartitions.

  ​            For more detailed information about and examples of            `ALTER TABLE ... REORGANIZE PARTITION`            statements, see            [Section 19.3.1, “Management of RANGE and LIST Partitions”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/partitioning.html#partitioning-management-range-list).          

- ​            Several options provide partition maintenance and repair            functionality analogous to that implemented for            nonpartitioned tables by statements such as            [`CHECK TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#check-table) and            [`REPAIR TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#repair-table) (which are also            supported for partitioned tables; for more information, see            [Section 13.7.2, “Table Maintenance Statements”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#table-maintenance-sql)). These include            `ANALYZE PARTITION`, `CHECK            PARTITION`, `OPTIMIZE PARTITION`,            `REBUILD PARTITION`, and `REPAIR            PARTITION`. Each of these options takes a            *partition_names* clause consisting            of one or more names of partitions, separated by commas. The            partitions must already exist in the table to be altered.            You can also use the `ALL` keyword in place            of *partition_names*, in which case            the statement acts on all table partitions. For more            information and examples, see            [Section 19.3.3, “Maintenance of Partitions”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/partitioning.html#partitioning-maintenance).          

  ​            Prior to MySQL 5.5.30, it was not safe to execute multiple            concurrent `REBUILD TABLE` operations on            partitioned tables, whether on the same or different tables.            (Bug #14589559, Bug #66645)          

  ​            Some MySQL storage engines, such as            [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html), do not support            per-partition optimization. For a partitioned table using            such a storage engine, `ALTER TABLE ... OPTIMIZE            PARTITION` rebuilds the entire table. This is a            known issue. Beginning with MySQL 5.5.30, running this            statement on such a table causes the entire table to rebuilt            and analyzed, and an appropriate warning to be issued. (Bug            #11751825, Bug #42822)          

  ​            To work around this problem, use the statements            `ALTER TABLE ... REBUILD PARTITION` and            `ALTER TABLE ... ANALYZE PARTITION`            instead.          

  ​            The `ANALYZE PARTITION`, `CHECK            PARTITION`, `OPTIMIZE PARTITION`,            and `REPAIR PARTITION` options are not            permitted for tables which are not partitioned.          

- ​            `REMOVE PARTITIONING` enables you to remove            a table's partitioning without otherwise affecting the table            or its data. This option can be combined with other            [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) options such as            those used to add, drop, or rename columns or indexes.          

- ​            Using the `ENGINE` option with            [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) changes the            storage engine used by the table without affecting the            partitioning.

​        It is possible for an [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table)        statement to contain a `PARTITION BY` or        `REMOVE PARTITIONING` clause in an addition to        other alter specifications, but the `PARTITION        BY` or `REMOVE PARTITIONING` clause        must be specified last after any other specifications.      

​        The `ADD PARTITION`, `DROP        PARTITION`, `COALESCE PARTITION`,        `REORGANIZE PARTITION`, `ANALYZE        PARTITION`, `CHECK PARTITION`, and        `REPAIR PARTITION` options cannot be combined        with other alter specifications in a single `ALTER        TABLE`, since the options just listed act on individual        partitions. For more information, see        [Section 13.1.7.1, “ALTER TABLE Partition Operations”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table-partition-operations).      

​        Only a single instance of any one of the following options can        be used in a given [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table)        statement: `PARTITION BY`, `ADD        PARTITION`, `DROP PARTITION`,        `TRUNCATE PARTITION`, `REORGANIZE        PARTITION`, or `COALESCE PARTITION`,        `ANALYZE PARTITION`, `CHECK        PARTITION`, `OPTIMIZE PARTITION`,        `REBUILD PARTITION`, `REMOVE        PARTITIONING`.      

​        For example, the following two statements are invalid:      

```
ALTER TABLE t1 ANALYZE PARTITION p1, ANALYZE PARTITION p2;

ALTER TABLE t1 ANALYZE PARTITION p1, CHECK PARTITION p2;

```

​        In the first case, you can analyze partitions        `p1` and `p2` of table        `t1` concurrently using a single statement with        a single `ANALYZE PARTITION` option that lists        both of the partitions to be analyzed, like this:      

```
ALTER TABLE t1 ANALYZE PARTITION p1, p2;

```

​        In the second case, it is not possible to perform        `ANALYZE` and `CHECK`        operations on different partitions of the same table        concurrently. Instead, you must issue two separate statements,        like this:      

```
ALTER TABLE t1 ANALYZE PARTITION p1;
ALTER TABLE t1 CHECK PARTITION p2;

```

​        `ANALYZE`, `CHECK`,        `OPTIMIZE`, `REBUILD`,        `REPAIR`, and `TRUNCATE`        operations are not supported for subpartitions.

#### 13.1.7.2 ALTER TABLE Online Operations in NDB Cluster 7.2

​        Operations that add and drop indexes on variable-width columns        of [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) tables occur online.        Online operations are noncopying; that is, they do not require        that indexes be re-created. They do not lock the table being        altered from access by other API nodes in an NDB Cluster (but        see *Limitations* later in this section).        Such operations do not require single user mode for        [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) table alterations made        in a cluster with multiple API nodes; transactions can continue        uninterrupted during online DDL operations.      

​        The `ONLINE` keyword can be used to perform        online `ADD COLUMN`, `ADD        INDEX` (including `CREATE INDEX`        statements), and `DROP INDEX` operations on        [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) tables. Online renaming        of [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) tables is also        supported.      

​        The `ONLINE` and `OFFLINE`        keywords are supported only in NDB Cluster. For standard MySQL        Server 5.5 releases:

- ​            The server determines automatically whether an `ADD            INDEX` or `DROP INDEX` operation            can be (and is) performed online or offline; if the column            is of a variable-width data type, the operation is performed            online. It is not possible to override the server behavior            in this regard.          
- ​            Attempting to use the `ONLINE` or            `OFFLINE` keyword in an            [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table),            [`CREATE INDEX`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-index), or            [`DROP INDEX`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-index) statement results            in an error.

​        Currently you cannot add disk-based columns to        [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) tables online. This        means that, if you wish to add an in-memory column to an        [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) table that uses a        table-level `STORAGE DISK` option, you must        declare the new column as using memory-based storage explicitly.        For example—assuming that you have already created        tablespace `ts1`—suppose that you create        table `t1` as follows:      

```
mysql> CREATE TABLE t1 (
     >     c1 INT NOT NULL PRIMARY KEY,
     >     c2 VARCHAR(30)
     >     )
     >     TABLESPACE ts1 STORAGE DISK
     >     ENGINE NDBCLUSTER;
Query OK, 0 rows affected (1.73 sec)
Records: 0  Duplicates: 0  Warnings: 0

```

​        You can add a new in-memory column to this table online as shown        here:      

```
mysql> ALTER ONLINE TABLE t1 ADD COLUMN c3 INT COLUMN_FORMAT DYNAMIC STORAGE MEMORY;
Query OK, 0 rows affected (1.25 sec)
Records: 0  Duplicates: 0  Warnings: 0

```

​        This statement fails if the `STORAGE MEMORY`        option is omitted:      

```
mysql> ALTER ONLINE TABLE t1 ADD COLUMN c3 INT COLUMN_FORMAT DYNAMIC;
ERROR 1235 (42000): This version of MySQL doesn't yet support
'ALTER ONLINE TABLE t1 ADD COLUMN c3 INT COLUMN_FORMAT DYNAMIC'

```

​        If you omit the `COLUMN_FORMAT DYNAMIC` option,        the dynamic column format is employed automatically, but a        warning is issued, as shown here:      

```
mysql> ALTER ONLINE TABLE t1 ADD COLUMN c3 INT STORAGE MEMORY;
Query OK, 0 rows affected, 1 warning (1.17 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> SHOW WARNINGS;
+---------+------+---------------------------------------------------------------+
| Level   | Code | Message                                                       |
+---------+------+---------------------------------------------------------------+
| Warning | 1478 | Converted FIXED field to DYNAMIC to enable on-line ADD COLUMN |
+---------+------+---------------------------------------------------------------+
1 row in set (0.00 sec)

mysql> SHOW CREATE TABLE t1\G
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `c1` int(11) NOT NULL,
  `c2` varchar(30) DEFAULT NULL,
  `c3` int(11) /*!50120 STORAGE MEMORY */ /*!50120 COLUMN_FORMAT DYNAMIC */ DEFAULT NULL,
  `t4` int(11) /*!50120 STORAGE MEMORY */ DEFAULT NULL,
  PRIMARY KEY (`c1`)
) /*!50100 TABLESPACE ts_1 STORAGE DISK */ ENGINE=ndbcluster DEFAULT CHARSET=latin1
1 row in set (0.03 sec)

```

Note

​          The `STORAGE` and          `COLUMN_FORMAT` keywords are supported only          in NDB Cluster; in any other version of MySQL, attempting to          use either of these keywords in a [`CREATE          TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) or [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table)          statement results in an error.

​        It is also possible to use the statement `ALTER ONLINE        TABLE ... REORGANIZE PARTITION` with no        `*partition_names* INTO        (*partition_definitions*)`        option on [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) tables. This can be        used to redistribute NDB Cluster data among new data nodes that        have been added to the cluster online. This does        *not* perform any defragmentation, which        requires an [`OPTIMIZE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#optimize-table) or        null [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) statement. For        more information, see        [Section 18.5.13, “Adding NDB Cluster Data Nodes Online”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html#mysql-cluster-online-add-node).

##### Limitations of NDBCLUSTER online operations

​        Online `DROP COLUMN` operations are not        supported.      

​        Online [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table),        [`CREATE INDEX`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-index), or        [`DROP INDEX`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-index) statements that add        columns or add or drop indexes are subject to the following        limitations:

- ​            A given online [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table)            can use only one of `ADD COLUMN`,            `ADD INDEX`, or `DROP            INDEX`. One or more columns can be added online in            a single statement; only one index may be created or dropped            online in a single statement.          
- ​            An `ALTER TABLE` statement that performs a            rename while using the `ONLINE` or            `OFFLINE` keyword cannot perform any other            operations, including but not limited to `ADD            COLUMN`, `ADD INDEX`, or            `DROP INDEX`. Beginning with MySQL NDB            Cluster 7.2.11, such statements are specifically disallowed,            and fail with            [`ER_NOT_SUPPORTED_YET`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/error-handling.html#error_er_not_supported_yet). (Bug            #16021021)          
- ​            The table being altered is not locked with respect to API            nodes other than the one on which an online            [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) `ADD            COLUMN`, `ADD INDEX`, or            `DROP INDEX` operation (or            [`CREATE INDEX`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-index) or            [`DROP INDEX`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-index) statement) is run.            However, the table is locked against any other operations            originating on the *same* API node while            the online operation is being executed.          
- ​            The table to be altered must have an explicit primary key;            the hidden primary key created by the            [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) storage engine is not            sufficient for this purpose.          
- ​            The storage engine used by the table cannot be changed            online.          
- ​            When used with NDB Cluster Disk Data tables, it is not            possible to change the storage type (`DISK`            or `MEMORY`) of a column online. This            means, that when you add or drop an index in such a way that            the operation would be performed online, and you want the            storage type of the column or columns to be changed, you            must use the `OFFLINE` keyword in the            statement that adds or drops the index.

​        Columns to be added online cannot use the        [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) or        [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) type, and must meet the        following criteria:

- ​            The columns must be dynamic; that is, it must be possible to            create them using `COLUMN_FORMAT DYNAMIC`.            If you omit the `COLUMN_FORMAT DYNAMIC`            option, the dynamic column format is employed automatically.          

- ​            The columns must permit `NULL` values and            not have any explicit default value other than            `NULL`. Columns added online are            automatically created as `DEFAULT NULL`, as            can be seen here:          

  ```
  mysql> CREATE TABLE t1 (
       >     c1 INT NOT NULL AUTO_INCREMENT PRIMARY KEY
       >     ) ENGINE=NDB;
  Query OK, 0 rows affected (1.44 sec)

  mysql> ALTER ONLINE TABLE t1
       >     ADD COLUMN c2 INT,
       >     ADD COLUMN c3 INT;
  Query OK, 0 rows affected, 2 warnings (0.93 sec)

  mysql> SHOW CREATE TABLE t1\G
  *************************** 1. row ***************************
         Table: t1
  Create Table: CREATE TABLE `t1` (
    `c1` int(11) NOT NULL AUTO_INCREMENT,
    `c2` int(11) DEFAULT NULL,
    `c3` int(11) DEFAULT NULL,
    PRIMARY KEY (`c1`)
  ) ENGINE=ndbcluster DEFAULT CHARSET=latin1
  1 row in set (0.00 sec)

  ```

- ​            The columns must be added following any existing columns. If            you attempt to add a column online before any existing            columns or using the `FIRST` keyword, the            statement fails with an error.          

- ​            Existing table columns cannot be reordered online.

​        For online [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) operations        on [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) tables, fixed-format columns        are converted to dynamic when they are added online, or when        indexes are created or dropped online, as shown here:      

```
mysql> CREATE TABLE t1 (
     >     c1 INT NOT NULL AUTO_INCREMENT PRIMARY KEY
     >     ) ENGINE=NDB;
Query OK, 0 rows affected (1.44 sec)

mysql> ALTER ONLINE TABLE t1 ADD COLUMN c2 INT, ADD COLUMN c3 INT;
Query OK, 0 rows affected, 2 warnings (0.93 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> SHOW WARNINGS;
+---------+------+---------------------------------------------------------------+
| Level   | Code | Message                                                       |
+---------+------+---------------------------------------------------------------+
| Warning | 1475 | Converted FIXED field to DYNAMIC to enable on-line ADD COLUMN |
| Warning | 1475 | Converted FIXED field to DYNAMIC to enable on-line ADD COLUMN |
+---------+------+---------------------------------------------------------------+
2 rows in set (0.00 sec)

```

Note

​          Existing columns, including the table's primary key, need not          be dynamic; only the column or columns to be added online must          be dynamic.

```
mysql> CREATE TABLE t2 (
     >     c1 INT NOT NULL AUTO_INCREMENT PRIMARY KEY COLUMN_FORMAT FIXED
     >     ) ENGINE=NDB;
Query OK, 0 rows affected (2.10 sec)

mysql> ALTER ONLINE TABLE t2 ADD COLUMN c2 INT;
Query OK, 0 rows affected, 1 warning (0.78 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> SHOW WARNINGS;
+---------+------+---------------------------------------------------------------+
| Level   | Code | Message                                                       |
+---------+------+---------------------------------------------------------------+
| Warning | 1475 | Converted FIXED field to DYNAMIC to enable on-line ADD COLUMN |
+---------+------+---------------------------------------------------------------+
1 row in set (0.00 sec)

```

​        Columns are not converted from `FIXED` to        `DYNAMIC` column format by renaming operations.        For more information about `COLUMN_FORMAT`, see        [Section 13.1.17, “CREATE TABLE Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table).      

​        The `KEY`, `CONSTRAINT`, and        `IGNORE` keywords are supported in        [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) statements using the        `ONLINE` keyword.

#### 13.1.7.3 ALTER TABLE Examples

Begin with a table `t1` created as shown here:      

```sql
CREATE TABLE t1 (a INTEGER, b CHAR(10));

```

To rename the table from `t1` to `t2`:      

```
ALTER TABLE t1 RENAME t2;

```

To change column `a` from `INTEGER` to `TINYINT NOT NULL` (leaving the name the same), and to change column `b` from `CHAR(10)` to        `CHAR(20)` as well as renaming it from `b` to `c`:      

```
ALTER TABLE t2 MODIFY a TINYINT NOT NULL, CHANGE b c CHAR(20);

```

To add a new `TIMESTAMP` column  named `d`:      

```
ALTER TABLE t2 ADD d TIMESTAMP;

```

To add an index on column `d` and a `UNIQUE` index on column `a`:      

```
ALTER TABLE t2 ADD INDEX (d), ADD UNIQUE (a);

```

To remove column `c`:      

```
ALTER TABLE t2 DROP COLUMN c;

```

​To add a new `AUTO_INCREMENT` integer column        named `c`:      

```
ALTER TABLE t2 ADD c INT UNSIGNED NOT NULL AUTO_INCREMENT,
  ADD PRIMARY KEY (c);

```

​        We indexed `c` (as a `PRIMARY        KEY`) because `AUTO_INCREMENT` columns        must be indexed, and we declare `c` as        `NOT NULL` because primary key columns cannot        be `NULL`.      

​        For [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) tables, it is also possible        to change the storage type used for a table or column. For        example, consider an [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) table        created as shown here:      

```
mysql> CREATE TABLE t1 (c1 INT) TABLESPACE ts_1 ENGINE NDB;
Query OK, 0 rows affected (1.27 sec)

```

​        To convert this table to disk-based storage, you can use the        following [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) statement:      

```
mysql> ALTER TABLE t1 TABLESPACE ts_1 STORAGE DISK;
Query OK, 0 rows affected (2.99 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> SHOW CREATE TABLE t1\G
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t1` (
  `c1` int(11) DEFAULT NULL
) /*!50100 TABLESPACE ts_1 STORAGE DISK */
ENGINE=ndbcluster DEFAULT CHARSET=latin1
1 row in set (0.01 sec)

```

​        It is not necessary that the tablespace was referenced when the        table was originally created; however, the tablespace must be        referenced by the [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table):      

```
mysql> CREATE TABLE t2 (c1 INT) ts_1 ENGINE NDB;
Query OK, 0 rows affected (1.00 sec)

mysql> ALTER TABLE t2 STORAGE DISK;
ERROR 1005 (HY000): Can't create table 'c.#sql-1750_3' (errno: 140)
mysql> ALTER TABLE t2 TABLESPACE ts_1 STORAGE DISK;
Query OK, 0 rows affected (3.42 sec)
Records: 0  Duplicates: 0  Warnings: 0
mysql> SHOW CREATE TABLE t2\G
*************************** 1. row ***************************
       Table: t1
Create Table: CREATE TABLE `t2` (
  `c1` int(11) DEFAULT NULL
) /*!50100 TABLESPACE ts_1 STORAGE DISK */
ENGINE=ndbcluster DEFAULT CHARSET=latin1
1 row in set (0.01 sec)

```

​        To change the storage type of an individual column, you can use        `ALTER TABLE ... MODIFY [COLUMN]`. For example,        suppose you create an NDB Cluster Disk Data table with two        columns, using this [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table)        statement:      

```
mysql> CREATE TABLE t3 (c1 INT, c2 INT)
    ->     TABLESPACE ts_1 STORAGE DISK ENGINE NDB;
Query OK, 0 rows affected (1.34 sec)

```

​        To change column `c2` from disk-based to        in-memory storage, include a STORAGE MEMORY clause in the column        definition used by the ALTER TABLE statement, as shown here:      

```
mysql> ALTER TABLE t3 MODIFY c2 INT STORAGE MEMORY;
Query OK, 0 rows affected (3.14 sec)
Records: 0  Duplicates: 0  Warnings: 0

```

​        You can make an in-memory column into a disk-based column by        using `STORAGE DISK` in a similar fashion.      

​        Column `c1` uses disk-based storage, since this        is the default for the table (determined by the table-level        `STORAGE DISK` clause in the        [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) statement). However,        column `c2` uses in-memory storage, as can be        seen here in the output of SHOW [`CREATE        TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table):      

```
mysql> SHOW CREATE TABLE t3\G
*************************** 1. row ***************************
       Table: t3
Create Table: CREATE TABLE `t3` (
  `c1` int(11) DEFAULT NULL,
  `c2` int(11) /*!50120 STORAGE MEMORY */ DEFAULT NULL
) /*!50100 TABLESPACE ts_1 STORAGE DISK */ ENGINE=ndbcluster DEFAULT CHARSET=latin1
1 row in set (0.02 sec)

```

​        When you add an `AUTO_INCREMENT` column, column        values are filled in with sequence numbers automatically. For        `MyISAM` tables, you can set the first sequence        number by executing `SET        INSERT_ID=*value*` before        [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) or by using the        `AUTO_INCREMENT=*value*`        table option.      

​        With `MyISAM` tables, if you do not change the        `AUTO_INCREMENT` column, the sequence number is        not affected. If you drop an `AUTO_INCREMENT`        column and then add another `AUTO_INCREMENT`        column, the numbers are resequenced beginning with 1.      

​        When replication is used, adding an        `AUTO_INCREMENT` column to a table might not        produce the same ordering of the rows on the slave and the        master. This occurs because the order in which the rows are        numbered depends on the specific storage engine used for the        table and the order in which the rows were inserted. If it is        important to have the same order on the master and slave, the        rows must be ordered before assigning an        `AUTO_INCREMENT` number. Assuming that you want        to add an `AUTO_INCREMENT` column to the table        `t1`, the following statements produce a new        table `t2` identical to `t1`        but with an `AUTO_INCREMENT` column:      

```
CREATE TABLE t2 (id INT AUTO_INCREMENT PRIMARY KEY)
SELECT * FROM t1 ORDER BY col1, col2;

```

​        This assumes that the table `t1` has columns        `col1` and `col2`.      

​        This set of statements will also produce a new table        `t2` identical to `t1`, with        the addition of an `AUTO_INCREMENT` column:      

```
CREATE TABLE t2 LIKE t1;
ALTER TABLE t2 ADD id INT AUTO_INCREMENT PRIMARY KEY;
INSERT INTO t2 SELECT * FROM t1 ORDER BY col1, col2;

```

Important

​          To guarantee the same ordering on both master and slave,          *all* columns of `t1` must          be referenced in the `ORDER BY` clause.

​        Regardless of the method used to create and populate the copy        having the `AUTO_INCREMENT` column, the final        step is to drop the original table and then rename the copy:      

```
DROP TABLE t1;
ALTER TABLE t2 RENAME t1;

```

### 13.1.8 ALTER TABLESPACE Syntax

```
ALTER TABLESPACE tablespace_name
    {ADD|DROP} DATAFILE 'file_name'
    [INITIAL_SIZE [=] size]
    [WAIT]
    ENGINE [=] engine_name

```

​      This statement can be used either to add a new data file, or to      drop a data file from a tablespace.    

​      The `ADD DATAFILE` variant enables you to specify      an initial size using an `INITIAL_SIZE` clause,      where *size* is measured in bytes; the      default value is 134217728 (128 MB). Prior to MySQL NDB Cluster      7.2.14, this value was required to be specified using digits (Bug      #13116514, Bug #16104705, Bug #62858); in MySQL NDB Cluster 7.2.14      and later, you may optionally follow      *size* with a one-letter abbreviation for      an order of magnitude, similar to those used in      `my.cnf`. Generally, this is one of the letters      `M` (megabytes) or `G`      (gigabytes).

Note

​        All NDB Cluster Disk Data objects share the same namespace. This        means that *each Disk Data object* must be        uniquely named (and not merely each Disk Data object of a given        type). For example, you cannot have a tablespace and an data        file with the same name, or an undo log file and a tablespace        with the same name.

​      On 32-bit systems, the maximum supported value for      `INITIAL_SIZE` is 4294967296 (4 GB). (Bug #29186)    

​      `INITIAL_SIZE` is rounded, explicitly, as for      [`CREATE TABLESPACE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-tablespace).    

​      Once a data file has been created, its size cannot be changed;      however, you can add more data files to the tablespace using      additional `ALTER TABLESPACE ... ADD DATAFILE`      statements.    

​      Using `DROP DATAFILE` with      [`ALTER TABLESPACE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-tablespace) drops the data      file '*file_name*' from the tablespace.      You cannot drop a data file from a tablespace which is in use by      any table; in other words, the data file must be empty (no extents      used). See [Section 18.5.12.1, “NDB Cluster Disk Data Objects”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html#mysql-cluster-disk-data-objects). In      addition, any data file to be dropped must previously have been      added to the tablespace with [`CREATE      TABLESPACE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-tablespace) or [`ALTER      TABLESPACE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-tablespace).    

​      Both `ALTER TABLESPACE ... ADD DATAFILE` and      `ALTER TABLESPACE ... DROP DATAFILE` require an      `ENGINE` clause which specifies the storage      engine used by the tablespace. Currently, the only accepted values      for *engine_name* are      [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) and      [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html).    

​      `WAIT` is parsed but otherwise ignored, and so      has no effect in MySQL 5.5. It is intended for future      expansion.    

​      When `ALTER TABLESPACE ... ADD DATAFILE` is used      with `ENGINE = NDB`, a data file is created on      each Cluster data node. You can verify that the data files were      created and obtain information about them by querying the      [`INFORMATION_SCHEMA.FILES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/information-schema.html#files-table) table. For      example, the following query shows all data files belonging to the      tablespace named `newts`:    

```
mysql> SELECT LOGFILE_GROUP_NAME, FILE_NAME, EXTRA
    -> FROM INFORMATION_SCHEMA.FILES
    -> WHERE TABLESPACE_NAME = 'newts' AND FILE_TYPE = 'DATAFILE';
+--------------------+--------------+----------------+
| LOGFILE_GROUP_NAME | FILE_NAME    | EXTRA          |
+--------------------+--------------+----------------+
| lg_3               | newdata.dat  | CLUSTER_NODE=3 |
| lg_3               | newdata.dat  | CLUSTER_NODE=4 |
| lg_3               | newdata2.dat | CLUSTER_NODE=3 |
| lg_3               | newdata2.dat | CLUSTER_NODE=4 |
+--------------------+--------------+----------------+
2 rows in set (0.03 sec)

```

​      See [Section 21.29.1, “The INFORMATION_SCHEMA FILES Table”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/information-schema.html#files-table).    

​      [`ALTER TABLESPACE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-tablespace) is useful only      with Disk Data storage for NDB Cluster. See      [Section 18.5.12, “NDB Cluster Disk Data Tables”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html#mysql-cluster-disk-data).

### 13.1.9 ALTER VIEW Syntax

```
ALTER
    [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
    [DEFINER = { user | CURRENT_USER }]
    [SQL SECURITY { DEFINER | INVOKER }]
    VIEW view_name [(column_list)]
    AS select_statement
    [WITH [CASCADED | LOCAL] CHECK OPTION]

```

​      This statement changes the definition of a view, which must exist.      The syntax is similar to that for [`CREATE      VIEW`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-view) see [Section 13.1.20, “CREATE VIEW Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-view)). This statement      requires the [`CREATE VIEW`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_create-view) and      [`DROP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_drop) privileges for the view, and      some privilege for each column referred to in the      [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement.      [`ALTER VIEW`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-view) is permitted only to the      definer or users with the [`SUPER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_super)      privilege.

### 13.1.10 CREATE DATABASE Syntax

```
CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name
    [create_specification] ...

create_specification:
    [DEFAULT] CHARACTER SET [=] charset_name
  | [DEFAULT] COLLATE [=] collation_name

```

​      [`CREATE DATABASE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-database) creates a database      with the given name. To use this statement, you need the      [`CREATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_create) privilege for the database.      [`CREATE      SCHEMA`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-database) is a synonym for [`CREATE      DATABASE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-database).    

​      An error occurs if the database exists and you did not specify      `IF NOT EXISTS`.    

​      [`CREATE DATABASE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-database) is not permitted      within a session that has an active [`LOCK      TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) statement.    

​      *create_specification* options specify      database characteristics. Database characteristics are stored in      the `db.opt` file in the database directory.      The `CHARACTER SET` clause specifies the default      database character set. The `COLLATE` clause      specifies the default database collation.      [Section 10.1, “Character Set Support”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/globalization.html#charset), discusses character set and collation      names.    

​      A database in MySQL is implemented as a directory containing files      that correspond to tables in the database. Because there are no      tables in a database when it is initially created, the      [`CREATE DATABASE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-database) statement creates      only a directory under the MySQL data directory and the      `db.opt` file. Rules for permissible database      names are given in [Section 9.2, “Schema Object Names”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/language-structure.html#identifiers). If a database      name contains special characters, the name for the database      directory contains encoded versions of those characters as      described in [Section 9.2.3, “Mapping of Identifiers to File Names”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/language-structure.html#identifier-mapping).    

​      If you manually create a directory under the data directory (for      example, with **mkdir**), the server considers it a      database directory and it shows up in the output of      [`SHOW DATABASES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-databases).    

​      You can also use the [**mysqladmin**](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/programs.html#mysqladmin) program to      create databases. See [Section 4.5.2, “**mysqladmin** — Client for Administering a MySQL Server”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/programs.html#mysqladmin).

### 13.1.11 CREATE EVENT Syntax

```
CREATE
    [DEFINER = { user | CURRENT_USER }]
    EVENT
    [IF NOT EXISTS]
    event_name
    ON SCHEDULE schedule
    [ON COMPLETION [NOT] PRESERVE]
    [ENABLE | DISABLE | DISABLE ON SLAVE]
    [COMMENT 'string']
    DO event_body;

schedule:
    AT timestamp [+ INTERVAL interval] ...
  | EVERY interval
    [STARTS timestamp [+ INTERVAL interval] ...]
    [ENDS timestamp [+ INTERVAL interval] ...]

interval:
    quantity {YEAR | QUARTER | MONTH | DAY | HOUR | MINUTE |
              WEEK | SECOND | YEAR_MONTH | DAY_HOUR | DAY_MINUTE |
              DAY_SECOND | HOUR_MINUTE | HOUR_SECOND | MINUTE_SECOND}

```

​      This statement creates and schedules a new event. The event will      not run unless the Event Scheduler is enabled. For information      about checking Event Scheduler status and enabling it if      necessary, see [Section 20.4.2, “Event Scheduler Configuration”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/stored-programs-views.html#events-configuration).    

​      [`CREATE EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-event) requires the      [`EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_event) privilege for the schema in      which the event is to be created. It might also require the      [`SUPER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_super) privilege, depending on the      `DEFINER` value, as described later in this      section.    

​      The minimum requirements for a valid [`CREATE      EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-event) statement are as follows:

- ​          The keywords [`CREATE EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-event) plus          an event name, which uniquely identifies the event in a          database schema.        
- ​          An `ON SCHEDULE` clause, which determines          when and how often the event executes.        
- ​          A [`DO`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#do) clause, which contains the          SQL statement to be executed by an event.

​      This is an example of a minimal [`CREATE      EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-event) statement:    

```
CREATE EVENT myevent
    ON SCHEDULE AT CURRENT_TIMESTAMP + INTERVAL 1 HOUR
    DO
      UPDATE myschema.mytable SET mycol = mycol + 1;

```

​      The previous statement creates an event named      `myevent`. This event executes once—one      hour following its creation—by running an SQL statement that      increments the value of the `myschema.mytable`      table's `mycol` column by 1.    

​      The *event_name* must be a valid MySQL      identifier with a maximum length of 64 characters. Event names are      not case sensitive, so you cannot have two events named      `myevent` and `MyEvent` in the      same schema. In general, the rules governing event names are the      same as those for names of stored routines. See      [Section 9.2, “Schema Object Names”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/language-structure.html#identifiers).    

​      An event is associated with a schema. If no schema is indicated as      part of *event_name*, the default      (current) schema is assumed. To create an event in a specific      schema, qualify the event name with a schema using      `*schema_name*.*event_name*`      syntax.    

​      The `DEFINER` clause specifies the MySQL account      to be used when checking access privileges at event execution      time. If a *user* value is given, it      should be a MySQL account specified as      `'*user_name*'@'*host_name*'`,      [`CURRENT_USER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-user), or      [`CURRENT_USER()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-user). The default      `DEFINER` value is the user who executes the      [`CREATE EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-event) statement. This is the      same as specifying `DEFINER = CURRENT_USER`      explicitly.    

​      If you specify the `DEFINER` clause, these rules      determine the valid `DEFINER` user values:

- ​          If you do not have the [`SUPER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_super)          privilege, the only permitted *user*          value is your own account, either specified literally or by          using [`CURRENT_USER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-user). You cannot          set the definer to some other account.        
- ​          If you have the [`SUPER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_super)          privilege, you can specify any syntactically valid account          name. If the account does not exist, a warning is generated.        
- ​          Although it is possible to create an event with a nonexistent          `DEFINER` account, an error occurs at event          execution time if the account does not exist.

​      For more information about event security, see      [Section 20.6, “Access Control for Stored Programs and Views”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/stored-programs-views.html#stored-programs-security).    

​      Within an event, the [`CURRENT_USER()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-user)      function returns the account used to check privileges at event      execution time, which is the `DEFINER` user. For      information about user auditing within events, see      [Section 6.3.8, “SQL-Based MySQL Account Activity Auditing”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#account-activity-auditing).    

​      `IF NOT EXISTS` has the same meaning for      [`CREATE EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-event) as for      [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table): If an event named      *event_name* already exists in the same      schema, no action is taken, and no error results. (However, a      warning is generated in such cases.)    

​      The `ON SCHEDULE` clause determines when, how      often, and for how long the *event_body*      defined for the event repeats. This clause takes one of two forms:

- ​          `AT *timestamp*` is          used for a one-time event. It specifies that the event          executes one time only at the date and time given by          *timestamp*, which must include both          the date and time, or must be an expression that resolves to a          datetime value. You may use a value of either the          [`DATETIME`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) or          [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) type for this          purpose. If the date is in the past, a warning occurs, as          shown here:        

  ```
  mysql> SELECT NOW();
  +---------------------+
  | NOW()               |
  +---------------------+
  | 2006-02-10 23:59:01 |
  +---------------------+
  1 row in set (0.04 sec)

  mysql> CREATE EVENT e_totals
      ->     ON SCHEDULE AT '2006-02-10 23:59:00'
      ->     DO INSERT INTO test.totals VALUES (NOW());
  Query OK, 0 rows affected, 1 warning (0.00 sec)

  mysql> SHOW WARNINGS\G
  *************************** 1. row ***************************
    Level: Note
     Code: 1588
  Message: Event execution time is in the past and ON COMPLETION NOT
           PRESERVE is set. The event was dropped immediately after
           creation.

  ```

  ​          [`CREATE EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-event) statements which          are themselves invalid—for whatever reason—fail          with an error.        

  ​          You may use [`CURRENT_TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-timestamp)          to specify the current date and time. In such a case, the          event acts as soon as it is created.        

  ​          To create an event which occurs at some point in the future          relative to the current date and time—such as that          expressed by the phrase “three weeks from          now”—you can use the optional clause `+          INTERVAL *interval*`. The          *interval* portion consists of two          parts, a quantity and a unit of time, and follows the same          syntax rules that govern intervals used in the          [`DATE_ADD()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_date-add) function (see          [Section 12.7, “Date and Time Functions”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#date-and-time-functions). The units keywords          are also the same, except that you cannot use any units          involving microseconds when defining an event. With some          interval types, complex time units may be used. For example,          “two minutes and ten seconds” can be expressed as          `+ INTERVAL '2:10' MINUTE_SECOND`.        

  ​          You can also combine intervals. For example, `AT          CURRENT_TIMESTAMP + INTERVAL 3 WEEK + INTERVAL 2 DAY`          is equivalent to “three weeks and two days from          now”. Each portion of such a clause must begin with          `+ INTERVAL`.        

- ​          To repeat actions at a regular interval, use an          `EVERY` clause. The `EVERY`          keyword is followed by an *interval*          as described in the previous discussion of the          `AT` keyword. (`+ INTERVAL`          is *not* used with          `EVERY`.) For example, `EVERY 6          WEEK` means “every six weeks”.        

  ​          Although `+ INTERVAL` clauses are not          permitted in an `EVERY` clause, you can use          the same complex time units permitted in a `+          INTERVAL`.        

  ​          An `EVERY` clause may contain an optional          `STARTS` clause. `STARTS` is          followed by a *timestamp* value that          indicates when the action should begin repeating, and may also          use `+ INTERVAL          *interval*` to specify an          amount of time “from now”. For example,          `EVERY 3 MONTH STARTS CURRENT_TIMESTAMP + INTERVAL 1          WEEK` means “every three months, beginning one          week from now”. Similarly, you can express “every          two weeks, beginning six hours and fifteen minutes from          now” as `EVERY 2 WEEK STARTS CURRENT_TIMESTAMP          + INTERVAL '6:15' HOUR_MINUTE`. Not specifying          `STARTS` is the same as using `STARTS          CURRENT_TIMESTAMP`—that is, the action          specified for the event begins repeating immediately upon          creation of the event.        

  ​          An `EVERY` clause may contain an optional          `ENDS` clause. The `ENDS`          keyword is followed by a *timestamp*          value that tells MySQL when the event should stop repeating.          You may also use `+ INTERVAL          *interval*` with          `ENDS`; for instance, `EVERY 12 HOUR          STARTS CURRENT_TIMESTAMP + INTERVAL 30 MINUTE ENDS          CURRENT_TIMESTAMP + INTERVAL 4 WEEK` is equivalent to          “every twelve hours, beginning thirty minutes from now,          and ending four weeks from now”. Not using          `ENDS` means that the event continues          executing indefinitely.        

  ​          `ENDS` supports the same syntax for complex          time units as `STARTS` does.        

  ​          You may use `STARTS`,          `ENDS`, both, or neither in an          `EVERY` clause.        

  ​          If a repeating event does not terminate within its scheduling          interval, the result may be multiple instances of the event          executing simultaneously. If this is undesirable, you should          institute a mechanism to prevent simultaneous instances. For          example, you could use the          [`GET_LOCK()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_get-lock) function, or row or          table locking.

​      The `ON SCHEDULE` clause may use expressions      involving built-in MySQL functions and user variables to obtain      any of the *timestamp* or      *interval* values which it contains. You      may not use stored functions or user-defined functions in such      expressions, nor may you use any table references; however, you      may use `SELECT FROM DUAL`. This is true for both      [`CREATE EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-event) and      [`ALTER EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-event) statements. References      to stored functions, user-defined functions, and tables in such      cases are specifically not permitted, and fail with an error (see      Bug #22830).    

​      Times in the `ON SCHEDULE` clause are interpreted      using the current session      [`time_zone`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_time_zone) value. This becomes the      event time zone; that is, the time zone that is used for event      scheduling and is in effect within the event as it executes. These      times are converted to UTC and stored along with the event time      zone in the `mysql.event` table. This enables      event execution to proceed as defined regardless of any subsequent      changes to the server time zone or daylight saving time effects.      For additional information about representation of event times,      see [Section 20.4.4, “Event Metadata”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/stored-programs-views.html#events-metadata). See also      [Section 13.7.5.19, “SHOW EVENTS Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-events), and [Section 21.7, “The INFORMATION_SCHEMA EVENTS Table”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/information-schema.html#events-table).    

​      Normally, once an event has expired, it is immediately dropped.      You can override this behavior by specifying `ON      COMPLETION PRESERVE`. Using `ON COMPLETION NOT      PRESERVE` merely makes the default nonpersistent behavior      explicit.    

​      You can create an event but prevent it from being active using the      `DISABLE` keyword. Alternatively, you can use      `ENABLE` to make explicit the default status,      which is active. This is most useful in conjunction with      [`ALTER EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-event) (see      [Section 13.1.2, “ALTER EVENT Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-event)).    

​      A third value may also appear in place of      `ENABLE` or `DISABLE`;      `DISABLE ON SLAVE` is set for the status of an      event on a replication slave to indicate that the event was      created on the master and replicated to the slave, but is not      executed on the slave. See      [Section 17.4.1.15, “Replication of Invoked Features”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/replication.html#replication-features-invoked).    

​      You may supply a comment for an event using a      `COMMENT` clause.      *comment* may be any string of up to 64      characters that you wish to use for describing the event. The      comment text, being a string literal, must be surrounded by      quotation marks.    

​      The [`DO`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#do) clause specifies an action      carried by the event, and consists of an SQL statement. Nearly any      valid MySQL statement that can be used in a stored routine can      also be used as the action statement for a scheduled event. (See      [Section C.1, “Restrictions on Stored Programs”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/restrictions.html#stored-program-restrictions).) For example, the      following event `e_hourly` deletes all rows from      the `sessions` table once per hour, where this      table is part of the `site_activity` schema:    

```
CREATE EVENT e_hourly
    ON SCHEDULE
      EVERY 1 HOUR
    COMMENT 'Clears out sessions table each hour.'
    DO
      DELETE FROM site_activity.sessions;

```

​      MySQL stores the [`sql_mode`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_sql_mode) system      variable setting in effect when an event is created or altered,      and always executes the event with this setting in force,      *regardless of the current server SQL mode when the event      begins executing*.    

​      A [`CREATE EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-event) statement that      contains an [`ALTER EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-event) statement      in its [`DO`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#do) clause appears to      succeed; however, when the server attempts to execute the      resulting scheduled event, the execution fails with an error.

Note

​        Statements such as [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) or        [`SHOW`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show) that merely return a result        set have no effect when used in an event; the output from these        is not sent to the MySQL Monitor, nor is it stored anywhere.        However, you can use statements such as        [`SELECT ...        INTO`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) and        [`INSERT INTO ...        SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert-select) that store a result. (See the next example in        this section for an instance of the latter.)

​      The schema to which an event belongs is the default schema for      table references in the [`DO`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#do) clause.      Any references to tables in other schemas must be qualified with      the proper schema name.    

​      As with stored routines, you can use compound-statement syntax in      the [`DO`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#do) clause by using the      `BEGIN` and `END` keywords, as      shown here:    

```
delimiter |

CREATE EVENT e_daily
    ON SCHEDULE
      EVERY 1 DAY
    COMMENT 'Saves total number of sessions then clears the table each day'
    DO
      BEGIN
        INSERT INTO site_activity.totals (time, total)
          SELECT CURRENT_TIMESTAMP, COUNT(*)
            FROM site_activity.sessions;
        DELETE FROM site_activity.sessions;
      END |

delimiter ;

```

​      This example uses the `delimiter` command to      change the statement delimiter. See      [Section 20.1, “Defining Stored Programs”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/stored-programs-views.html#stored-programs-defining).    

​      More complex compound statements, such as those used in stored      routines, are possible in an event. This example uses local      variables, an error handler, and a flow control construct:    

```
delimiter |

CREATE EVENT e
    ON SCHEDULE
      EVERY 5 SECOND
    DO
      BEGIN
        DECLARE v INTEGER;
        DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN END;

        SET v = 0;

        WHILE v < 5 DO
          INSERT INTO t1 VALUES (0);
          UPDATE t2 SET s1 = s1 + 1;
          SET v = v + 1;
        END WHILE;
    END |

delimiter ;

```

​      There is no way to pass parameters directly to or from events;      however, it is possible to invoke a stored routine with parameters      within an event:    

```
CREATE EVENT e_call_myproc
    ON SCHEDULE
      AT CURRENT_TIMESTAMP + INTERVAL 1 DAY
    DO CALL myproc(5, 27);

```

​      If an event's definer has the [`SUPER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_super)      privilege, the event can read and write global variables. As      granting this privilege entails a potential for abuse, extreme      care must be taken in doing so.    

​      Generally, any statements that are valid in stored routines may be      used for action statements executed by events. For more      information about statements permitted within stored routines, see      [Section 20.2.1, “Stored Routine Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/stored-programs-views.html#stored-routines-syntax). You can create an event      as part of a stored routine, but an event cannot be created by      another event.

### 13.1.12 CREATE FUNCTION Syntax

​      The [`CREATE FUNCTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-function) statement is      used to create stored functions and user-defined functions (UDFs):

- ​          For information about creating stored functions, see          [Section 13.1.15, “CREATE PROCEDURE and CREATE FUNCTION Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-procedure).        

  ​

- ​          For information about creating user-defined functions, see          [Section 13.7.3.1, “CREATE FUNCTION Syntax for User-Defined Functions”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-function-udf).

### 13.1.13 CREATE INDEX Syntax

```
CREATE [ONLINE|OFFLINE] [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name
    [index_type]
    ON tbl_name (index_col_name,...)
    [index_option] ...

index_col_name:
    col_name [(length)] [ASC | DESC]

index_option:
    KEY_BLOCK_SIZE [=] value
  | index_type
  | WITH PARSER parser_name
  | COMMENT 'string'

index_type:
    USING {BTREE | HASH}

```

​      [`CREATE INDEX`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-index) is mapped to an      [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) statement to create      indexes. See [Section 13.1.7, “ALTER TABLE Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table).      [`CREATE INDEX`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-index) cannot be used to      create a `PRIMARY KEY`; use      [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) instead. For more      information about indexes, see [Section 8.3.1, “How MySQL Uses Indexes”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/optimization.html#mysql-indexes).    

​      Normally, you create all indexes on a table at the time the table      itself is created with [`CREATE      TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table). See [Section 13.1.17, “CREATE TABLE Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table). This      guideline is especially important for      [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html) tables, where the primary key      determines the physical layout of rows in the data file.      [`CREATE INDEX`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-index) enables you to add      indexes to existing tables.    

​      A column list of the form `(col1, col2, ...)`      creates a multiple-column index. Index key values are formed by      concatenating the values of the given columns.    

​      For string columns, indexes can be created that use only the      leading part of column values, using      `*col_name*(*length*)`      syntax to specify an index prefix length:

- ​          Prefixes can be specified for          [`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),          [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),          [`BINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary), and          [`VARBINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary) column indexes.        
- ​          Prefixes *must* be specified for          [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) and          [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) column indexes.        
- ​          Prefix limits are measured in bytes, whereas the prefix length          in [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table),          [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table), and          [`CREATE INDEX`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-index) statements is          interpreted as number of characters for nonbinary string types          ([`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),          [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),          [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob)) and number of bytes for          binary string types ([`BINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary),          [`VARBINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary),          [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob)). Take this into account          when specifying a prefix length for a nonbinary string column          that uses a multibyte character set.        
- ​          For spatial columns, prefix values cannot be given, as          described later in this section.

​      The statement shown here creates an index using the first 10      characters of the `name` column (assuming that      `name` has a nonbinary string type):    

```
CREATE INDEX part_of_name ON customer (name(10));

```

​      If names in the column usually differ in the first 10 characters,      this index should not be much slower than an index created from      the entire `name` column. Also, using column      prefixes for indexes can make the index file much smaller, which      could save a lot of disk space and might also speed up      [`INSERT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert) operations.    

​      Prefix support and lengths of prefixes (where supported) are      storage engine dependent. For example, a prefix can be up to 767      bytes long for [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html) tables or 3072      bytes if the [`innodb_large_prefix`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#sysvar_innodb_large_prefix)      option is enabled. For [`MyISAM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#myisam-storage-engine) tables,      the prefix limit is 1000 bytes. The      [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) storage engine does not support      prefixes (see      [Section 18.1.6.6, “Unsupported or Missing Features in NDB Cluster”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html#mysql-cluster-limitations-unsupported)).    

​      Indexes on variable-width columns of      [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) tables are created online;      that is, without any table copying. The table is not locked      against access from other NDB Cluster API nodes, although it is      locked against other operations on the *same*      API node for the duration of the operation. This is done      automatically by the server whenever it determines that it is      possible to do so; you do not have to use any special SQL syntax      or server options to cause it to happen.    

​      In standard MySQL 5.5 releases, it is not possible to      override the server when it determines that an index is to be      created without table copying. In NDB Cluster, you can create      indexes offline (which causes the table to be locked to all API      nodes in the cluster) using the `OFFLINE`      keyword. The rules and limitations governing `CREATE      OFFLINE INDEX` and `CREATE ONLINE INDEX`      are the same as for `ALTER OFFLINE TABLE ... ADD      INDEX` and `ALTER ONLINE TABLE ... ADD      INDEX`. You cannot cause the noncopying creation of an      index that would normally be created offline by using the      `ONLINE` keyword: If it is not possible to      perform the [`CREATE INDEX`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-index) operation      without table copying, the server ignores the      `ONLINE` keyword. For more information, see      [Section 13.1.7.2, “ALTER TABLE Online Operations in NDB Cluster 7.2”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table-online-operations).    

​      The `ONLINE` and `OFFLINE`      keywords are available only in NDB Cluster; attempting to use      these keywords in standard MySQL Server 5.5 releases      results in a syntax error.    

​      A `UNIQUE` index creates a constraint such that      all values in the index must be distinct. An error occurs if you      try to add a new row with a key value that matches an existing      row. For all engines, a `UNIQUE` index permits      multiple `NULL` values for columns that can      contain `NULL`. If you specify a prefix value for      a column in a `UNIQUE` index, the column values      must be unique within the prefix.    

​      If a `UNIQUE` index consists of only one column      that has an integer type, you can also refer to the column as      `_rowid` in [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select)      statements.    

​      `FULLTEXT` indexes are supported only for      [`MyISAM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#myisam-storage-engine) tables and can include only      [`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),      [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char), and      [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) columns. Indexing always      happens over the entire column; column prefix indexing is not      supported and any prefix length is ignored if specified. See      [Section 12.9, “Full-Text Search Functions”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#fulltext-search), for details of operation.    

​      The [`MyISAM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#myisam-storage-engine),      [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html),      [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html), and      [`ARCHIVE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#archive-storage-engine) storage engines support      spatial columns such as ([`POINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#spatial-type-overview) and      [`GEOMETRY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#spatial-type-overview).      ([Section 11.5, “Spatial Data Types”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#spatial-types), describes the spatial data      types.) However, support for spatial column indexing varies among      engines. Spatial and nonspatial indexes are available according to      the following rules.    

​      Spatial indexes (created using `SPATIAL INDEX`)      have these characteristics:

- ​          Available only for [`MyISAM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#myisam-storage-engine) tables.          Specifying `SPATIAL INDEX` for other storage          engines results in an error.        
- ​          Indexed columns must be `NOT NULL`.        
- ​          Column prefix lengths are prohibited. The full width of each          column is indexed.

​      Characteristics of nonspatial indexes (created with      `INDEX`, `UNIQUE`, or      `PRIMARY KEY`):

- ​          Permitted for any storage engine that supports spatial columns          except [`ARCHIVE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#archive-storage-engine).        
- ​          Columns can be `NULL` unless the index is a          primary key.        
- ​          For each spatial column in a non-`SPATIAL`          index except [`POINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#spatial-type-overview) columns, a          column prefix length must be specified. (This is the same          requirement as for indexed [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob)          columns.) The prefix length is given in bytes.        
- ​          The index type for a non-`SPATIAL` index          depends on the storage engine. Currently, B-tree is used.        
- ​          You can add an index on a column that can have          `NULL` values only for          [`MyISAM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#myisam-storage-engine),          [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html), and          [`MEMORY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#memory-storage-engine) tables        
- ​          You can add an index on a [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob)          or [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) column only for          [`MyISAM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#myisam-storage-engine) and          [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html) tables

​      An *index_col_name* specification can end      with `ASC` or `DESC`. These      keywords are permitted for future extensions for specifying      ascending or descending index value storage. Currently, they are      parsed but ignored; index values are always stored in ascending      order.    

​      Following the index column list, index options can be given. An      *index_option* value can be any of the      following:

- ​          `KEY_BLOCK_SIZE [=]          *value*`        

  ​          For [`MyISAM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#myisam-storage-engine) tables,          `KEY_BLOCK_SIZE` optionally specifies the          size in bytes to use for index key blocks. The value is          treated as a hint; a different size could be used if          necessary. A `KEY_BLOCK_SIZE` value specified          for an individual index definition overrides a table-level          `KEY_BLOCK_SIZE` value.        

  ​          `KEY_BLOCK_SIZE` is not supported at the          index level for [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html) tables.          See [Section 13.1.17, “CREATE TABLE Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table).        

- ​          *index_type*        

  ​          Some storage engines permit you to specify an index type when          creating an index. For example:        

  ```
  CREATE TABLE lookup (id INT) ENGINE = MEMORY;
  CREATE INDEX id_index ON lookup (id) USING BTREE;

  ```

  ​          [Table 13.1, “Index Types Per Storage Engine”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-index-storage-engine-index-types)          shows the permissible index type values supported by different          storage engines. Where multiple index types are listed, the          first one is the default when no index type specifier is          given. Storage engines not listed in the table do not support          an *index_type* clause in index          definitions.

  ​

  **Table 13.1 Index Types Per Storage Engine**

  | Storage Engine                           | Permissible Index Types            |
  | ---------------------------------------- | ---------------------------------- |
  | [`MyISAM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#myisam-storage-engine) | `BTREE`                            |
  | [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html) | `BTREE`                            |
  | [`MEMORY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#memory-storage-engine)/`HEAP` | `HASH`, `BTREE`                    |
  | [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) | `BTREE`, `HASH` (see note in text) |

  ​

  ​          The *index_type* clause cannot be          used for `FULLTEXT INDEX` or `SPATIAL          INDEX` specifications. Full-text index implementation          is storage engine dependent. Spatial indexes are implemented          as R-tree indexes.        

  ​          `BTREE` indexes are implemented by the          [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) storage engine as T-tree          indexes.

  ​

  ​

  Note

  ​            For indexes on [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) table            columns, the `USING` option can be            specified only for a unique index or primary key.            `USING HASH` prevents the creation of an            ordered index; otherwise, creating a unique index or primary            key on an [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) table            automatically results in the creation of both an ordered            index and a hash index, each of which indexes the same set            of columns.          

  ​            For unique indexes that include one or more            `NULL` columns of an            [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) table, the hash index can            be used only to look up literal values, which means that            `IS [NOT] NULL` conditions require a full            scan of the table. One workaround is to make sure that a            unique index using one or more `NULL`            columns on such a table is always created in such a way that            it includes the ordered index; that is, avoid employing            `USING HASH` when creating the index.

  ​          If you specify an index type that is not valid for a given          storage engine, but another index type is available that the          engine can use without affecting query results, the engine          uses the available type. The parser recognizes          `RTREE` as a type name, but currently this          cannot be specified for any storage engine.

  Note

  ​            Use of the *index_type* option            before the `ON            *tbl_name*` clause is            deprecated; support for use of the option in this position            will be removed in a future MySQL release. If an            *index_type* option is given in            both the earlier and later positions, the final option            applies.

  ​          `TYPE *type_name*`          is recognized as a synonym for `USING          *type_name*`. However,          `USING` is the preferred form.        

  ​          For the storage engines that support an          *index_type* option,          [Table 13.2, “Storage Engine Index Characteristics”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-index-storage-engine-index-characteristics)          shows some characteristics of index use.

  ​

  **Table 13.2 Storage Engine Index Characteristics**

  | Storage Engine | Index Type | Index Class | Stores NULL Values | Permits Multiple NULL Values | IS NULL Scan Type  | IS NOT NULL Scan Type |
  | -------------- | ---------- | ----------- | ------------------ | ---------------------------- | ------------------ | --------------------- |
  | `InnoDB`       | `BTREE`    | Primary key | No                 | No                           | N/A                | N/A                   |
  | Unique         | Yes        | Yes         | Index              | Index                        |                    |                       |
  | Key            | Yes        | Yes         | Index              | Index                        |                    |                       |
  | `MyISAM`       | `BTREE`    | Primary key | No                 | No                           | N/A                | N/A                   |
  | Unique         | Yes        | Yes         | Index              | Index                        |                    |                       |
  | Key            | Yes        | Yes         | Index              | Index                        |                    |                       |
  | Inapplicable   | `FULLTEXT` | Yes         | Yes                | Table                        | Table              |                       |
  | Inapplicable   | `SPATIAL`  | No          | No                 | N/A                          | N/A                |                       |
  | `MEMORY`       | `HASH`     | Primary key | No                 | No                           | N/A                | N/A                   |
  | Unique         | Yes        | Yes         | Index              | Index                        |                    |                       |
  | Key            | Yes        | Yes         | Index              | Index                        |                    |                       |
  | `BTREE`        | Primary    | No          | No                 | N/A                          | N/A                |                       |
  | Unique         | Yes        | Yes         | Index              | Index                        |                    |                       |
  | Key            | Yes        | Yes         | Index              | Index                        |                    |                       |
  | `NDB`          | `BTREE`    | Primary key | No                 | No                           | Index              | Index                 |
  | Unique         | Yes        | Yes         | Index              | Index                        |                    |                       |
  | Key            | Yes        | Yes         | Index              | Index                        |                    |                       |
  | `HASH`         | Primary    | No          | No                 | Table (see note 1)           | Table (see note 1) |                       |
  | Unique         | Yes        | Yes         | Table (see note 1) | Table (see note 1)           |                    |                       |
  | Key            | Yes        | Yes         | Table (see note 1) | Table (see note 1)           |                    |                       |

  ​

  ​          Table note:        

  ​          \1. If `USING HASH` is specified that prevents          creation of an implicit ordered index.        

- ​          `WITH PARSER          *parser_name*`        

  ​          This option can be used only with `FULLTEXT`          indexes. It associates a parser plugin with the index if          full-text indexing and searching operations need special          handling. See [Section 24.2, “The MySQL Plugin API”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/extending-mysql.html#plugin-api), for details on          creating plugins.        

- ​          `COMMENT '*string*'`        

  ​          Index definitions can include an optional comment of up to          1024 characters.

### 13.1.14 CREATE LOGFILE GROUP Syntax

```
CREATE LOGFILE GROUP logfile_group
    ADD UNDOFILE 'undo_file'
    [INITIAL_SIZE [=] initial_size]
    [UNDO_BUFFER_SIZE [=] undo_buffer_size]
    [REDO_BUFFER_SIZE [=] redo_buffer_size]
    [NODEGROUP [=] nodegroup_id]
    [WAIT]
    [COMMENT [=] 'string']
    ENGINE [=] engine_name

```

​      This statement creates a new log file group named      *logfile_group* having a single      `UNDO` file named      '*undo_file*'. A      [`CREATE LOGFILE GROUP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-logfile-group) statement has      one and only one `ADD UNDOFILE` clause. For rules      covering the naming of log file groups, see      [Section 9.2, “Schema Object Names”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/language-structure.html#identifiers).

Note

​        All NDB Cluster Disk Data objects share the same namespace. This        means that *each Disk Data object* must be        uniquely named (and not merely each Disk Data object of a given        type). For example, you cannot have a tablespace and a log file        group with the same name, or a tablespace and a data file with        the same name.

​      In MySQL NDB Cluster 7.2, you can have only one log file group per      Cluster at any given time. (See Bug #16386)    

​      The optional `INITIAL_SIZE` parameter sets the      `UNDO` file's initial size; if not specified, it      defaults to `128M` (128 megabytes). The optional      `UNDO_BUFFER_SIZE` parameter sets the size used      by the `UNDO` buffer for the log file group; The      default value for `UNDO_BUFFER_SIZE` is      `8M` (eight megabytes); this value cannot exceed      the amount of system memory available. Both of these parameters      are specified in bytes. In MySQL NDB Cluster 7.2.14 and later, you      may optionally follow either or both of these with a one-letter      abbreviation for an order of magnitude, similar to those used in      `my.cnf`. Generally, this is one of the      letters `M` (for megabytes) or      `G` (for gigabytes). Prior to MySQL NDB Cluster      7.2.14, the values for these options could only be specified using      digits. (Bug #13116514, Bug #16104705, Bug #62858)    

​      Memory used for `UNDO_BUFFER_SIZE` comes from the      global pool whose size is determined by the value of the      [`SharedGlobalMemory`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html#ndbparam-ndbd-sharedglobalmemory) data      node configuration parameter. This includes any default value      implied for this option by the setting of the      [`InitialLogFileGroup`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html#ndbparam-ndbd-initiallogfilegroup) data      node configuration parameter.    

​      The maximum permitted for `UNDO_BUFFER_SIZE` is      629145600 (600 MB).    

​      On 32-bit systems, the maximum supported value for      `INITIAL_SIZE` is 4294967296 (4 GB). (Bug #29186)    

​      The minimum allowed value for `INITIAL_SIZE` is      1048576 (1 MB).    

​      The `ENGINE` option determines the storage engine      to be used by this log file group, with      *engine_name* being the name of the      storage engine. In MySQL 5.5, this must be      [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) (or      [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html)). If      `ENGINE` is not set, MySQL tries to use the      engine specified by the      [`default_storage_engine`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_default_storage_engine) server      system variable (formerly      [`storage_engine`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_storage_engine)). In any case, if      the engine is not specified as [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) or      [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html), the `CREATE      LOGFILE GROUP` statement appears to succeed but actually      fails to create the log file group, as shown here:    

```
mysql> CREATE LOGFILE GROUP lg1
    ->     ADD UNDOFILE 'undo.dat' INITIAL_SIZE = 10M;
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql> SHOW WARNINGS;
+-------+------+------------------------------------------------------------------------------------------------+
| Level | Code | Message                                                                                        |
+-------+------+------------------------------------------------------------------------------------------------+
| Error | 1478 | Table storage engine 'InnoDB' does not support the create option 'TABLESPACE or LOGFILE GROUP' |
+-------+------+------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)

mysql> DROP LOGFILE GROUP lg1 ENGINE = NDB;            
ERROR 1529 (HY000): Failed to drop LOGFILE GROUP

mysql> CREATE LOGFILE GROUP lg1
    ->     ADD UNDOFILE 'undo.dat' INITIAL_SIZE = 10M
    ->     ENGINE = NDB;
Query OK, 0 rows affected (2.97 sec)

```

​      The fact that the `CREATE LOGFILE GROUP`      statement does not actually return an error when a      non-`NDB` storage engine is named, but rather      appears to succeed, is a known issue which we hope to address in a      future release of NDB Cluster.    

​      *REDO_BUFFER_SIZE*,      `NODEGROUP`, `WAIT`, and      `COMMENT` are parsed but ignored, and so have no      effect in MySQL 5.5. These options are intended for      future expansion.    

​      When used with `ENGINE [=] NDB`, a log file group      and associated `UNDO` log file are created on      each Cluster data node. You can verify that the      `UNDO` files were created and obtain information      about them by querying the      [`INFORMATION_SCHEMA.FILES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/information-schema.html#files-table) table. For      example:    

```
mysql> SELECT LOGFILE_GROUP_NAME, LOGFILE_GROUP_NUMBER, EXTRA
    -> FROM INFORMATION_SCHEMA.FILES
    -> WHERE FILE_NAME = 'undo_10.dat';
+--------------------+----------------------+----------------+
| LOGFILE_GROUP_NAME | LOGFILE_GROUP_NUMBER | EXTRA          |
+--------------------+----------------------+----------------+
| lg_3               |                   11 | CLUSTER_NODE=3 |
| lg_3               |                   11 | CLUSTER_NODE=4 |
+--------------------+----------------------+----------------+
2 rows in set (0.06 sec)

```

​      [`CREATE LOGFILE GROUP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-logfile-group) is useful only      with Disk Data storage for NDB Cluster. See      [Section 18.5.12, “NDB Cluster Disk Data Tables”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html#mysql-cluster-disk-data).

### 13.1.15 CREATE PROCEDURE and CREATE FUNCTION Syntax

```
CREATE
    [DEFINER = { user | CURRENT_USER }]
    PROCEDURE sp_name ([proc_parameter[,...]])
    [characteristic ...] routine_body

CREATE
    [DEFINER = { user | CURRENT_USER }]
    FUNCTION sp_name ([func_parameter[,...]])
    RETURNS type
    [characteristic ...] routine_body

proc_parameter:
    [ IN | OUT | INOUT ] param_name type

func_parameter:
    param_name type

type:
    Any valid MySQL data type

characteristic:
    COMMENT 'string'
  | LANGUAGE SQL
  | [NOT] DETERMINISTIC
  | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
  | SQL SECURITY { DEFINER | INVOKER }

routine_body:
    Valid SQL routine statement

```

​      These statements create stored routines. By default, a routine is      associated with the default database. To associate the routine      explicitly with a given database, specify the name as      *db_name.sp_name* when you create it.    

​      The [`CREATE FUNCTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-function) statement is      also used in MySQL to support UDFs (user-defined functions). See      [Section 24.4, “Adding New Functions to MySQL”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/extending-mysql.html#adding-functions). A UDF can be regarded as an      external stored function. Stored functions share their namespace      with UDFs. See [Section 9.2.4, “Function Name Parsing and Resolution”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/language-structure.html#function-resolution), for the      rules describing how the server interprets references to different      kinds of functions.    

​      To invoke a stored procedure, use the      [`CALL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#call) statement (see      [Section 13.2.1, “CALL Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#call)). To invoke a stored function, refer to it      in an expression. The function returns a value during expression      evaluation.    

​      [`CREATE PROCEDURE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-procedure) and      [`CREATE FUNCTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-function) require the      [`CREATE ROUTINE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_create-routine) privilege. They      might also require the [`SUPER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_super)      privilege, depending on the `DEFINER` value, as      described later in this section. If binary logging is enabled,      [`CREATE FUNCTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-function) might require the      [`SUPER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_super) privilege, as described in      [Section 20.7, “Binary Logging of Stored Programs”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/stored-programs-views.html#stored-programs-logging).    

​      By default, MySQL automatically grants the      [`ALTER ROUTINE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_alter-routine) and      [`EXECUTE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_execute) privileges to the routine      creator. This behavior can be changed by disabling the      [`automatic_sp_privileges`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_automatic_sp_privileges) system      variable. See [Section 20.2.2, “Stored Routines and MySQL Privileges”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/stored-programs-views.html#stored-routines-privileges).    

​      The `DEFINER` and `SQL SECURITY`      clauses specify the security context to be used when checking      access privileges at routine execution time, as described later in      this section.    

​      If the routine name is the same as the name of a built-in SQL      function, a syntax error occurs unless you use a space between the      name and the following parenthesis when defining the routine or      invoking it later. For this reason, avoid using the names of      existing SQL functions for your own stored routines.    

​      The [`IGNORE_SPACE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_ignore_space) SQL mode      applies to built-in functions, not to stored routines. It is      always permissible to have spaces after a stored routine name,      regardless of whether      [`IGNORE_SPACE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_ignore_space) is enabled.    

​      The parameter list enclosed within parentheses must always be      present. If there are no parameters, an empty parameter list of      `()` should be used. Parameter names are not case      sensitive.    

​      Each parameter is an `IN` parameter by default.      To specify otherwise for a parameter, use the keyword      `OUT` or `INOUT` before the      parameter name.

Note

​        Specifying a parameter as `IN`,        `OUT`, or `INOUT` is valid        only for a `PROCEDURE`. For a        `FUNCTION`, parameters are always regarded as        `IN` parameters.

​      An `IN` parameter passes a value into a      procedure. The procedure might modify the value, but the      modification is not visible to the caller when the procedure      returns. An `OUT` parameter passes a value from      the procedure back to the caller. Its initial value is      `NULL` within the procedure, and its value is      visible to the caller when the procedure returns. An      `INOUT` parameter is initialized by the caller,      can be modified by the procedure, and any change made by the      procedure is visible to the caller when the procedure returns.    

​      For each `OUT` or `INOUT`      parameter, pass a user-defined variable in the      [`CALL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#call) statement that invokes the      procedure so that you can obtain its value when the procedure      returns. If you are calling the procedure from within another      stored procedure or function, you can also pass a routine      parameter or local routine variable as an `IN` or      `INOUT` parameter.    

​      Routine parameters cannot be referenced in statements prepared      within the routine; see      [Section C.1, “Restrictions on Stored Programs”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/restrictions.html#stored-program-restrictions).    

​      The following example shows a simple stored procedure that uses an      `OUT` parameter:    

```
mysql> delimiter //

mysql> CREATE PROCEDURE simpleproc (OUT param1 INT)
    -> BEGIN
    ->   SELECT COUNT(*) INTO param1 FROM t;
    -> END//
Query OK, 0 rows affected (0.00 sec)

mysql> delimiter ;

mysql> CALL simpleproc(@a);
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT @a;
+------+
| @a   |
+------+
| 3    |
+------+
1 row in set (0.00 sec)

```

​      The example uses the [**mysql**](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/programs.html#mysql) client      `delimiter` command to change the statement      delimiter from `;` to `//` while      the procedure is being defined. This enables the      `;` delimiter used in the procedure body to be      passed through to the server rather than being interpreted by      [**mysql**](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/programs.html#mysql) itself. See      [Section 20.1, “Defining Stored Programs”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/stored-programs-views.html#stored-programs-defining).    

​      The `RETURNS` clause may be specified only for a      `FUNCTION`, for which it is mandatory. It      indicates the return type of the function, and the function body      must contain a `RETURN      *value*` statement. If the      [`RETURN`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#return) statement returns a value of      a different type, the value is coerced to the proper type. For      example, if a function specifies an      [`ENUM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum) or      [`SET`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#set) value in the      `RETURNS` clause, but the      [`RETURN`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#return) statement returns an      integer, the value returned from the function is the string for      the corresponding [`ENUM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum) member of      set of [`SET`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#set) members.    

​      The following example function takes a parameter, performs an      operation using an SQL function, and returns the result. In this      case, it is unnecessary to use `delimiter`      because the function definition contains no internal      `;` statement delimiters:    

```
mysql> CREATE FUNCTION hello (s CHAR(20))
mysql> RETURNS CHAR(50) DETERMINISTIC
    -> RETURN CONCAT('Hello, ',s,'!');
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT hello('world');
+----------------+
| hello('world') |
+----------------+
| Hello, world!  |
+----------------+
1 row in set (0.00 sec)

```

​      Parameter types and function return types can be declared to use      any valid data type, except that the `COLLATE`      attribute cannot be used prior to MySQL 5.5.3. As of 5.5.3,      `COLLATE` can be used if preceded by the      `CHARACTER SET` attribute.    

​      The *routine_body* consists of a valid      SQL routine statement. This can be a simple statement such as      [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) or      [`INSERT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert), or a compound statement      written using `BEGIN` and `END`.      Compound statements can contain declarations, loops, and other      control structure statements. The syntax for these statements is      described in [Section 13.6, “Compound-Statement Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#sql-syntax-compound-statements).    

​      MySQL permits routines to contain DDL statements, such as      `CREATE` and `DROP`. MySQL also      permits stored procedures (but not stored functions) to contain      SQL transaction statements such as      [`COMMIT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit). Stored functions may not      contain statements that perform explicit or implicit commit or      rollback. Support for these statements is not required by the SQL      standard, which states that each DBMS vendor may decide whether to      permit them.    

​      Statements that return a result set can be used within a stored      procedure but not within a stored function. This prohibition      includes [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statements that do      not have an `INTO      *var_list*` clause and other      statements such as [`SHOW`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show),      [`EXPLAIN`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#explain), and      [`CHECK TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#check-table). For statements that      can be determined at function definition time to return a result      set, a `Not allowed to return a result set from a      function` error occurs      ([`ER_SP_NO_RETSET`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/error-handling.html#error_er_sp_no_retset)). For statements      that can be determined only at runtime to return a result set, a      `PROCEDURE %s can't return a result set in the given      context` error occurs      ([`ER_SP_BADSELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/error-handling.html#error_er_sp_badselect)).    

​      [`USE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#use) statements within stored      routines are not permitted. When a routine is invoked, an implicit      `USE *db_name*` is      performed (and undone when the routine terminates). The causes the      routine to have the given default database while it executes.      References to objects in databases other than the routine default      database should be qualified with the appropriate database name.    

​      For additional information about statements that are not permitted      in stored routines, see      [Section C.1, “Restrictions on Stored Programs”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/restrictions.html#stored-program-restrictions).    

​      For information about invoking stored procedures from within      programs written in a language that has a MySQL interface, see      [Section 13.2.1, “CALL Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#call).    

​      MySQL stores the [`sql_mode`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_sql_mode) system      variable setting in effect when a routine is created or altered,      and always executes the routine with this setting in force,      *regardless of the current server SQL mode when the      routine begins executing*.    

​      The switch from the SQL mode of the invoker to that of the routine      occurs after evaluation of arguments and assignment of the      resulting values to routine parameters. If you define a routine in      strict SQL mode but invoke it in nonstrict mode, assignment of      arguments to routine parameters does not take place in strict      mode. If you require that expressions passed to a routine be      assigned in strict SQL mode, you should invoke the routine with      strict mode in effect.    

​      The `COMMENT` characteristic is a MySQL      extension, and may be used to describe the stored routine. This      information is displayed by the [`SHOW CREATE      PROCEDURE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-create-procedure) and [`SHOW CREATE      FUNCTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-create-function) statements.    

​      The `LANGUAGE` characteristic indicates the      language in which the routine is written. The server ignores this      characteristic; only SQL routines are supported.    

​      A routine is considered “deterministic” if it always      produces the same result for the same input parameters, and      “not deterministic” otherwise. If neither      `DETERMINISTIC` nor `NOT      DETERMINISTIC` is given in the routine definition, the      default is `NOT DETERMINISTIC`. To declare that a      function is deterministic, you must specify      `DETERMINISTIC` explicitly.    

​      Assessment of the nature of a routine is based on the      “honesty” of the creator: MySQL does not check that a      routine declared `DETERMINISTIC` is free of      statements that produce nondeterministic results. However,      misdeclaring a routine might affect results or affect performance.      Declaring a nondeterministic routine as      `DETERMINISTIC` might lead to unexpected results      by causing the optimizer to make incorrect execution plan choices.      Declaring a deterministic routine as      `NONDETERMINISTIC` might diminish performance by      causing available optimizations not to be used.    

​      If binary logging is enabled, the `DETERMINISTIC`      characteristic affects which routine definitions MySQL accepts.      See [Section 20.7, “Binary Logging of Stored Programs”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/stored-programs-views.html#stored-programs-logging).    

​      A routine that contains the [`NOW()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_now)      function (or its synonyms) or      [`RAND()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_rand) is nondeterministic, but it      might still be replication-safe. For      [`NOW()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_now), the binary log includes the      timestamp and replicates correctly.      [`RAND()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_rand) also replicates correctly as      long as it is called only a single time during the execution of a      routine. (You can consider the routine execution timestamp and      random number seed as implicit inputs that are identical on the      master and slave.)    

​      Several characteristics provide information about the nature of      data use by the routine. In MySQL, these characteristics are      advisory only. The server does not use them to constrain what      kinds of statements a routine will be permitted to execute.

- ​          `CONTAINS SQL` indicates that the routine          does not contain statements that read or write data. This is          the default if none of these characteristics is given          explicitly. Examples of such statements are `SET @x =          1` or `DO RELEASE_LOCK('abc')`,          which execute but neither read nor write data.        
- ​          `NO SQL` indicates that the routine contains          no SQL statements.        
- ​          `READS SQL DATA` indicates that the routine          contains statements that read data (for example,          [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select)), but not statements          that write data.        
- ​          `MODIFIES SQL DATA` indicates that the          routine contains statements that may write data (for example,          [`INSERT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert) or          [`DELETE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#delete)).

​      The `SQL SECURITY` characteristic can be      `DEFINER` or `INVOKER` to      specify the security context; that is, whether the routine      executes using the privileges of the account named in the routine      `DEFINER` clause or the user who invokes it. This      account must have permission to access the database with which the      routine is associated. The default value is      `DEFINER`. The user who invokes the routine must      have the [`EXECUTE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_execute) privilege for it,      as must the `DEFINER` account if the routine      executes in definer security context.    

​      The `DEFINER` clause specifies the MySQL account      to be used when checking access privileges at routine execution      time for routines that have the `SQL SECURITY      DEFINER` characteristic.    

​      If a *user* value is given for the      `DEFINER` clause, it should be a MySQL account      specified as      `'*user_name*'@'*host_name*'`,      [`CURRENT_USER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-user), or      [`CURRENT_USER()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-user). The default      `DEFINER` value is the user who executes the      [`CREATE PROCEDURE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-procedure) or      [`CREATE FUNCTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-function) statement. This is      the same as specifying `DEFINER = CURRENT_USER`      explicitly.    

​      If you specify the `DEFINER` clause, these rules      determine the valid `DEFINER` user values:

- ​          If you do not have the [`SUPER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_super)          privilege, the only permitted *user*          value is your own account, either specified literally or by          using [`CURRENT_USER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-user). You cannot          set the definer to some other account.        
- ​          If you have the [`SUPER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_super)          privilege, you can specify any syntactically valid account          name. If the account does not exist, a warning is generated.        
- ​          Although it is possible to create a routine with a nonexistent          `DEFINER` account, an error occurs at routine          execution time if the `SQL SECURITY` value is          `DEFINER` but the definer account does not          exist.

​      For more information about stored routine security, see      [Section 20.6, “Access Control for Stored Programs and Views”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/stored-programs-views.html#stored-programs-security).    

​      Within a stored routine that is defined with the `SQL      SECURITY DEFINER` characteristic,      [`CURRENT_USER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-user) returns the routine's      `DEFINER` value. For information about user      auditing within stored routines, see      [Section 6.3.8, “SQL-Based MySQL Account Activity Auditing”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#account-activity-auditing).    

​      Consider the following procedure, which displays a count of the      number of MySQL accounts listed in the      `mysql.user` table:    

```
CREATE DEFINER = 'admin'@'localhost' PROCEDURE account_count()
BEGIN
  SELECT 'Number of accounts:', COUNT(*) FROM mysql.user;
END;

```

​      The procedure is assigned a `DEFINER` account of      `'admin'@'localhost'` no matter which user      defines it. It executes with the privileges of that account no      matter which user invokes it (because the default security      characteristic is `DEFINER`). The procedure      succeeds or fails depending on whether invoker has the      [`EXECUTE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_execute) privilege for it and      `'admin'@'localhost'` has the      [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_select) privilege for the      `mysql.user` table.    

​      Now suppose that the procedure is defined with the `SQL      SECURITY INVOKER` characteristic:    

```
CREATE DEFINER = 'admin'@'localhost' PROCEDURE account_count()
SQL SECURITY INVOKER
BEGIN
  SELECT 'Number of accounts:', COUNT(*) FROM mysql.user;
END;

```

​      The procedure still has a `DEFINER` of      `'admin'@'localhost'`, but in this case, it      executes with the privileges of the invoking user. Thus, the      procedure succeeds or fails depending on whether the invoker has      the [`EXECUTE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_execute) privilege for it and      the [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_select) privilege for the      `mysql.user` table.    

​      The server handles the data type of a routine parameter, local      routine variable created with      [`DECLARE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#declare), or function return value      as follows:

- ​          Assignments are checked for data type mismatches and overflow.          Conversion and overflow problems result in warnings, or errors          in strict SQL mode.        

- ​          Only scalar values can be assigned. For example, a statement          such as `SET x = (SELECT 1, 2)` is invalid.        

- ​          For character data types, if there is a `CHARACTER          SET` attribute in the declaration, the specified          character set and its default collation is used. If the          `COLLATE` attribute is also present, that          collation is used rather than the default collation.        

  ​          Prior to MySQL 5.5.3, if there is a `CHARACTER          SET` attribute in the declaration, the          `COLLATE` attribute is not supported, and the          character set's default collation is used. (This includes use          of `BINARY`, which in this context specifies          the binary collation of the character set.) If there is no          `CHARACTER SET` attribute, the database          character set and its default collation (rather than the          database collation) are used.        

  ​          If `CHARACTER SET` and          `COLLATE` attributes are not present, the          database character set and collation in effect at routine          creation time are used. To avoid having the server use the          database character set and collation, provide explicit          `CHARACTER SET` and          `COLLATE` attributes for character data          parameters.        

  ​          If you change the database default character set or collation,          stored routines that use the database defaults must be dropped          and recreated so that they use the new defaults.        

  ​          The database character set and collation are given by the          value of the          [`character_set_database`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_character_set_database) and          [`collation_database`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_collation_database) system          variables. For more information, see          [Section 10.1.3.3, “Database Character Set and Collation”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/globalization.html#charset-database).

### 13.1.16 CREATE SERVER Syntax

```
CREATE SERVER server_name
    FOREIGN DATA WRAPPER wrapper_name
    OPTIONS (option [, option] ...)

option:
  { HOST character-literal
  | DATABASE character-literal
  | USER character-literal
  | PASSWORD character-literal
  | SOCKET character-literal
  | OWNER character-literal
  | PORT numeric-literal }

```

​      This statement creates the definition of a server for use with the      `FEDERATED` storage engine. The `CREATE      SERVER` statement creates a new row in the      `servers` table in the `mysql`      database. This statement requires the      [`SUPER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_super) privilege.    

​      The `*server_name*`      should be a unique reference to the server. Server definitions are      global within the scope of the server, it is not possible to      qualify the server definition to a specific database.      `*server_name*` has a      maximum length of 64 characters (names longer than 64 characters      are silently truncated), and is case insensitive. You may specify      the name as a quoted string.    

​      The `*wrapper_name*`      should be `mysql`, and may be quoted with single      quotation marks. Other values for      `*wrapper_name*` are not      currently supported.    

​      For each `*option*` you      must specify either a character literal or numeric literal.      Character literals are UTF-8, support a maximum length of 64      characters and default to a blank (empty) string. String literals      are silently truncated to 64 characters. Numeric literals must be      a number between 0 and 9999, default value is 0.

Note

​        The `OWNER` option is currently not applied,        and has no effect on the ownership or operation of the server        connection that is created.

​      The `CREATE SERVER` statement creates an entry in      the `mysql.servers` table that can later be used      with the [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) statement      when creating a `FEDERATED` table. The options      that you specify will be used to populate the columns in the      `mysql.servers` table. The table columns are      `Server_name`, `Host`,      `Db`, `Username`,      `Password`, `Port` and      `Socket`.    

​      For example:    

```
CREATE SERVER s
FOREIGN DATA WRAPPER mysql
OPTIONS (USER 'Remote', HOST '198.51.100.106', DATABASE 'test');

```

​      Be sure to specify all options necessary to establish a connection      to the server. The user name, host name, and database name are      mandatory. Other options might be required as well, such as      password.    

​      The data stored in the table can be used when creating a      connection to a `FEDERATED` table:    

```
CREATE TABLE t (s1 INT) ENGINE=FEDERATED CONNECTION='s';
```

​      For more information, see      [Section 15.9, “The FEDERATED Storage Engine”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#federated-storage-engine).    

​      `CREATE SERVER` causes an implicit commit. See      [Section 13.3.3, “Statements That Cause an Implicit Commit”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#implicit-commit).    

​      `CREATE SERVER` is not written to the binary log,      regardless of the logging format that is in use.

### 13.1.17 CREATE TABLE Syntax

- [13.1.17.1 CREATE TABLE Statement Retention](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-statement-retention)
- [13.1.17.2 Files Created by CREATE TABLE](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-files)
- [13.1.17.3 CREATE TEMPORARY TABLE Syntax](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-temporary-table)
- [13.1.17.4 CREATE TABLE ... LIKE Syntax](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-like)
- [13.1.17.5 CREATE TABLE ... SELECT Syntax](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-select)
- [13.1.17.6 Using FOREIGN KEY Constraints](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-foreign-keys)
- [13.1.17.7 Silent Column Specification Changes](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#silent-column-changes)

```
CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
    (create_definition,...)
    [table_options]
    [partition_options]

CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
    [(create_definition,...)]
    [table_options]
    [partition_options]
    [IGNORE | REPLACE]
    [AS] query_expression

CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
    { LIKE old_tbl_name | (LIKE old_tbl_name) }

create_definition:
    col_name column_definition
  | [CONSTRAINT [symbol]] PRIMARY KEY [index_type] (index_col_name,...)
      [index_option] ...
  | {INDEX|KEY} [index_name] [index_type] (index_col_name,...)
      [index_option] ...
  | [CONSTRAINT [symbol]] UNIQUE [INDEX|KEY]
      [index_name] [index_type] (index_col_name,...)
      [index_option] ...
  | {FULLTEXT|SPATIAL} [INDEX|KEY] [index_name] (index_col_name,...)
      [index_option] ...
  | [CONSTRAINT [symbol]] FOREIGN KEY
      [index_name] (index_col_name,...) reference_definition
  | CHECK (expr)

column_definition:
    data_type [NOT NULL | NULL] [DEFAULT default_value]
      [AUTO_INCREMENT] [UNIQUE [KEY]] [[PRIMARY] KEY]
      [COMMENT 'string']
      [COLUMN_FORMAT {FIXED|DYNAMIC|DEFAULT}]
      [STORAGE {DISK|MEMORY|DEFAULT}]
      [reference_definition]

data_type:
    BIT[(length)]
  | TINYINT[(length)] [UNSIGNED] [ZEROFILL]
  | SMALLINT[(length)] [UNSIGNED] [ZEROFILL]
  | MEDIUMINT[(length)] [UNSIGNED] [ZEROFILL]
  | INT[(length)] [UNSIGNED] [ZEROFILL]
  | INTEGER[(length)] [UNSIGNED] [ZEROFILL]
  | BIGINT[(length)] [UNSIGNED] [ZEROFILL]
  | REAL[(length,decimals)] [UNSIGNED] [ZEROFILL]
  | DOUBLE[(length,decimals)] [UNSIGNED] [ZEROFILL]
  | FLOAT[(length,decimals)] [UNSIGNED] [ZEROFILL]
  | DECIMAL[(length[,decimals])] [UNSIGNED] [ZEROFILL]
  | NUMERIC[(length[,decimals])] [UNSIGNED] [ZEROFILL]
  | DATE
  | TIME
  | TIMESTAMP
  | DATETIME
  | YEAR
  | CHAR[(length)]
      [CHARACTER SET charset_name] [COLLATE collation_name]
  | VARCHAR(length)
      [CHARACTER SET charset_name] [COLLATE collation_name]
  | BINARY[(length)]
  | VARBINARY(length)
  | TINYBLOB
  | BLOB[(length)]
  | MEDIUMBLOB
  | LONGBLOB
  | TINYTEXT
      [CHARACTER SET charset_name] [COLLATE collation_name]
  | TEXT[(length)]
      [CHARACTER SET charset_name] [COLLATE collation_name]
  | MEDIUMTEXT
      [CHARACTER SET charset_name] [COLLATE collation_name]
  | LONGTEXT
      [CHARACTER SET charset_name] [COLLATE collation_name]
  | ENUM(value1,value2,value3,...)
      [CHARACTER SET charset_name] [COLLATE collation_name]
  | SET(value1,value2,value3,...)
      [CHARACTER SET charset_name] [COLLATE collation_name]
  | spatial_type

index_col_name:
    col_name [(length)] [ASC | DESC]

index_type:
    USING {BTREE | HASH}

index_option:
    KEY_BLOCK_SIZE [=] value
  | index_type
  | WITH PARSER parser_name
  | COMMENT 'string'

reference_definition:
    REFERENCES tbl_name (index_col_name,...)
      [MATCH FULL | MATCH PARTIAL | MATCH SIMPLE]
      [ON DELETE reference_option]
      [ON UPDATE reference_option]

reference_option:
    RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT

table_options:
    table_option [[,] table_option] ...

table_option:
    AUTO_INCREMENT [=] value
  | AVG_ROW_LENGTH [=] value
  | [DEFAULT] CHARACTER SET [=] charset_name
  | CHECKSUM [=] {0 | 1}
  | [DEFAULT] COLLATE [=] collation_name
  | COMMENT [=] 'string'
  | CONNECTION [=] 'connect_string'
  | {DATA|INDEX} DIRECTORY [=] 'absolute path to directory'
  | DELAY_KEY_WRITE [=] {0 | 1}
  | ENGINE [=] engine_name
  | INSERT_METHOD [=] { NO | FIRST | LAST }
  | KEY_BLOCK_SIZE [=] value
  | MAX_ROWS [=] value
  | MIN_ROWS [=] value
  | PACK_KEYS [=] {0 | 1 | DEFAULT}
  | PASSWORD [=] 'string'
  | ROW_FORMAT [=] {DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT}
  | TABLESPACE tablespace_name [STORAGE {DISK|MEMORY|DEFAULT}]
  | UNION [=] (tbl_name[,tbl_name]...)

partition_options:
    PARTITION BY
        { [LINEAR] HASH(expr)
        | [LINEAR] KEY [ALGORITHM={1|2}] (column_list)
        | RANGE{(expr) | COLUMNS(column_list)}
        | LIST{(expr) | COLUMNS(column_list)} }
    [PARTITIONS num]
    [SUBPARTITION BY
        { [LINEAR] HASH(expr)
        | [LINEAR] KEY [ALGORITHM={1|2}] (column_list) }
      [SUBPARTITIONS num]
    ]
    [(partition_definition [, partition_definition] ...)]

partition_definition:
    PARTITION partition_name
        [VALUES
            {LESS THAN {(expr | value_list) | MAXVALUE}
            |
            IN (value_list)}]
        [[STORAGE] ENGINE [=] engine_name]
        [COMMENT [=] 'string' ]
        [DATA DIRECTORY [=] 'data_dir']
        [INDEX DIRECTORY [=] 'index_dir']
        [MAX_ROWS [=] max_number_of_rows]
        [MIN_ROWS [=] min_number_of_rows]
        [TABLESPACE [=] tablespace_name]
        [NODEGROUP [=] node_group_id]
        [(subpartition_definition [, subpartition_definition] ...)]

subpartition_definition:
    SUBPARTITION logical_name
        [[STORAGE] ENGINE [=] engine_name]
        [COMMENT [=] 'string' ]
        [DATA DIRECTORY [=] 'data_dir']
        [INDEX DIRECTORY [=] 'index_dir']
        [MAX_ROWS [=] max_number_of_rows]
        [MIN_ROWS [=] min_number_of_rows]
        [TABLESPACE [=] tablespace_name]
        [NODEGROUP [=] node_group_id]

query_expression:
    SELECT ...   (Some valid select or union statement)

```

​      [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) creates a table with      the given name. You must have the      [`CREATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_create) privilege for the table.    

​      By default, tables are created in the default database, using the      [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html) storage engine. An error      occurs if the table exists, if there is no default database, or if      the database does not exist.    

​      For information about the physical representation of a table, see      [Section 13.1.17.2, “Files Created by CREATE TABLE”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-files).    

​      The original [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table)      statement, including all specifications and table options are      stored by MySQL when the table is created. For more information,      see [Section 13.1.17.1, “CREATE TABLE Statement Retention”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-statement-retention).    

​      There are several aspects to the [`CREATE      TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) statement, described under the following topics in      this section:

- [Table Name](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-name)
- [Temporary Tables](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-temporary-tables)
- [Cloning or Copying a Table](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-clone-copy)
- [Column Data Types and Attributes](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-types-attributes)
- [Indexes and Foreign Keys](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-indexes-keys)
- [Table Options](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-options)
- [Creating Partitioned Tables](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-partitioning)

#### Table Name

- ​          `*tbl_name*`        

  ​          The table name can be specified as          *db_name.tbl_name* to create the          table in a specific database. This works regardless of whether          there is a default database, assuming that the database          exists. If you use quoted identifiers, quote the database and          table names separately. For example, write          ``mydb`.`mytbl``, not          ``mydb.mytbl``.        

  ​          Rules for permissible table names are given in          [Section 9.2, “Schema Object Names”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/language-structure.html#identifiers).        

- ​          `IF NOT EXISTS`        

  ​          Prevents an error from occurring if the table exists. However,          there is no verification that the existing table has a          structure identical to that indicated by the          [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) statement.

#### Temporary Tables

​      You can use the `TEMPORARY` keyword when creating      a table. A `TEMPORARY` table is visible only      within the current session, and is dropped automatically when the      session is closed. For more information, see      [Section 13.1.17.3, “CREATE TEMPORARY TABLE Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-temporary-table).

#### Cloning or Copying a Table

- ​          `LIKE`        

  ​          Use `CREATE TABLE ... LIKE` to create an          empty table based on the definition of another table,          including any column attributes and indexes defined in the          original table:        

  ```
  CREATE TABLE new_tbl LIKE orig_tbl;

  ```

  ​          For more information, see [Section 13.1.17.4, “CREATE TABLE ... LIKE Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-like).        

- ​          `[AS]          *query_expression*`        

  ​          To create one table from another, add a          [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement at the end of          the [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) statement:        

  ```
  CREATE TABLE new_tbl AS SELECT * FROM orig_tbl;

  ```

  ​          For more information, see          [Section 13.1.17.5, “CREATE TABLE ... SELECT Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-select).        

- ​          `IGNORE|REPLACE`        

  ​          The `IGNORE` and `REPLACE`          options indicate how to handle rows that duplicate unique key          values when copying a table using a          [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement.        

  ​          For more information, see          [Section 13.1.17.5, “CREATE TABLE ... SELECT Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-select).

#### Column Data Types and Attributes

​      There is a hard limit of 4096 columns per table, but the effective      maximum may be less for a given table and depends on the factors      discussed in [Section C.10.4, “Limits on Table Column Count and Row Size”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/restrictions.html#column-count-limit).

- ​          `*data_type*`        

  ​          *data_type* represents the data type          in a column definition.          *spatial_type* represents a spatial          data type. The data type syntax shown is representative only.          For a full description of the syntax available for specifying          column data types, as well as information about the properties          of each type, see [Chapter 11, *Data Types*](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html), and          [Section 11.5, “Spatial Data Types”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#spatial-types).

  - ​              Some attributes do not apply to all data types.              `AUTO_INCREMENT` applies only to integer              and floating-point types. `DEFAULT` does              not apply to the [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) or              [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) types.            

  - ​              Character data types ([`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),              [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),              [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob)) can include              `CHARACTER SET` and              `COLLATE` attributes to specify the              character set and collation for the column. For details,              see [Section 10.1, “Character Set Support”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/globalization.html#charset). `CHARSET`              is a synonym for `CHARACTER SET`.              Example:            

    ```
    CREATE TABLE t (c CHAR(20) CHARACTER SET utf8 COLLATE utf8_bin);

    ```

    ​              MySQL 5.5 interprets length specifications in              character column definitions in characters. Lengths for              [`BINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary) and              [`VARBINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary) are in bytes.            

  - ​              For [`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),              [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),              [`BINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary), and              [`VARBINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary) columns, indexes              can be created that use only the leading part of column              values, using              `*col_name*(*length*)`              syntax to specify an index prefix length.              [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) and              [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) columns also can be              indexed, but a prefix length *must* be              given. Prefix lengths are given in characters for              nonbinary string types and in bytes for binary string              types. That is, index entries consist of the first              *length* characters of each              column value for [`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),              [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char), and              [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) columns, and the first              *length* bytes of each column              value for [`BINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary),              [`VARBINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary), and              [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) columns. Indexing only              a prefix of column values like this can make the index              file much smaller. For additional information about index              prefixes, see [Section 13.1.13, “CREATE INDEX Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-index).            

    ​

    ​

    ​

    ​

    ​              Only the `InnoDB` and              `MyISAM` storage engines support indexing              on [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) and              [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) columns. For example:            

    ```
    CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));

    ```

- ​          `NOT NULL | NULL`        

  ​

  ​

  ​          If neither `NULL` nor `NOT          NULL` is specified, the column is treated as though          `NULL` had been specified.        

  ​          In MySQL 5.5, only the `InnoDB`,          `MyISAM`, and `MEMORY`          storage engines support indexes on columns that can have          `NULL` values. In other cases, you must          declare indexed columns as `NOT NULL` or an          error results.        

- ​          `DEFAULT`        

  ​

  ​

  ​          Specifies a default value for a column. With one exception,          the default value must be a constant; it cannot be a function          or an expression. This means, for example, that you cannot set          the default for a date column to be the value of a function          such as [`NOW()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_now) or          [`CURRENT_DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-date). The exception is          that you can specify          [`CURRENT_TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-timestamp) as the          default for a [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) column.          See [Section 11.3.5, “Automatic Initialization and Updating for TIMESTAMP”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#timestamp-initialization).        

  ​          If a column definition includes no explicit          `DEFAULT` value, MySQL determines the default          value as described in [Section 11.6, “Data Type Default Values”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#data-type-defaults).        

  ​          [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) and          [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) columns cannot be assigned          a default value.        

  ​          [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) fails if a          date-valued default is not correct according to the          [`NO_ZERO_IN_DATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_no_zero_in_date) SQL mode,          even if strict SQL mode is not enabled. For example,          `c1 DATE DEFAULT '2010-00-00'` causes          [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) to fail with          `Invalid default value for 'c1'`.        

- ​          `AUTO_INCREMENT`        

  ​          An integer or floating-point column can have the additional          attribute `AUTO_INCREMENT`. When you insert a          value of `NULL` (recommended) or          `0` into an indexed          `AUTO_INCREMENT` column, the column is set to          the next sequence value. Typically this is          `*value*+1`, where          *value* is the largest value for the          column currently in the table.          `AUTO_INCREMENT` sequences begin with          `1`.        

  ​          To retrieve an `AUTO_INCREMENT` value after          inserting a row, use the          [`LAST_INSERT_ID()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_last-insert-id) SQL function          or the [`mysql_insert_id()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/connectors-apis.html#mysql-insert-id) C API          function. See [Section 12.14, “Information Functions”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#information-functions), and          [Section 23.8.7.37, “mysql_insert_id()”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/connectors-apis.html#mysql-insert-id).        

  ​          If the [`NO_AUTO_VALUE_ON_ZERO`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_no_auto_value_on_zero)          SQL mode is enabled, you can store `0` in          `AUTO_INCREMENT` columns as          `0` without generating a new sequence value.          See [Section 5.1.8, “Server SQL Modes”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sql-mode).        

  ​          There can be only one `AUTO_INCREMENT` column          per table, it must be indexed, and it cannot have a          `DEFAULT` value. An          `AUTO_INCREMENT` column works properly only          if it contains only positive values. Inserting a negative          number is regarded as inserting a very large positive number.          This is done to avoid precision problems when numbers          “wrap” over from positive to negative and also to          ensure that you do not accidentally get an          `AUTO_INCREMENT` column that contains          `0`.        

  ​          For `MyISAM` tables, you can specify an          `AUTO_INCREMENT` secondary column in a          multiple-column key. See          [Section 3.6.9, “Using AUTO_INCREMENT”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/tutorial.html#example-auto-increment).        

  ​

  ​

  ​          To make MySQL compatible with some ODBC applications, you can          find the `AUTO_INCREMENT` value for the last          inserted row with the following query:        

  ```
  SELECT * FROM tbl_name WHERE auto_col IS NULL

  ```

  ​          This method requires that          [`sql_auto_is_null`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_sql_auto_is_null) variable is          not set to 0. See [Section 5.1.5, “Server System Variables”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#server-system-variables).        

  ​          For information about `InnoDB` and          `AUTO_INCREMENT`, see          [Section 14.11.1.5, “AUTO_INCREMENT Handling in InnoDB”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#innodb-auto-increment-handling). For          information about `AUTO_INCREMENT` and MySQL          Replication, see          [Section 17.4.1.1, “Replication and AUTO_INCREMENT”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/replication.html#replication-features-auto-increment).        

- ​          `COMMENT`        

  ​

  ​          A comment for a column can be specified with the          `COMMENT` option, up to 1024 characters long          (255 characters before MySQL 5.5.3). The comment is displayed          by the [`SHOW CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-create-table) and          [`SHOW FULL          COLUMNS`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-columns) statements.        

- ​          `COLUMN_FORMAT`        

  ​

  ​          In NDB Cluster, it is also possible to specify a data storage          format for individual columns of          [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) tables using          `COLUMN_FORMAT`. Permissible column formats          are `FIXED`, `DYNAMIC`, and          `DEFAULT`. `FIXED` is used          to specify fixed-width storage, `DYNAMIC`          permits the column to be variable-width, and          `DEFAULT` causes the column to use          fixed-width or variable-width storage as determined by the          column's data type (possibly overridden by a          `ROW_FORMAT` specifier).        

  ​          For [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) tables, the default value          for `COLUMN_FORMAT` is          `DEFAULT`.        

  ​          `COLUMN_FORMAT` currently has no effect on          columns of tables using storage engines other than          [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html). In MySQL 5.5          and later, `COLUMN_FORMAT` is silently          ignored.        

- ​          `STORAGE`        

  ​

  ​          For [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) tables, it is possible to          specify whether the column is stored on disk or in memory by          using a `STORAGE` clause. `STORAGE          DISK` causes the column to be stored on disk, and          `STORAGE MEMORY` causes in-memory storage to          be used. The [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table)          statement used must still include a          `TABLESPACE` clause:        

  ```
  mysql> CREATE TABLE t1 (
      ->     c1 INT STORAGE DISK,
      ->     c2 INT STORAGE MEMORY
      -> ) ENGINE NDB;
  ERROR 1005 (HY000): Can't create table 'c.t1' (errno: 140)

  mysql> CREATE TABLE t1 (
      ->     c1 INT STORAGE DISK,
      ->     c2 INT STORAGE MEMORY
      -> ) TABLESPACE ts_1 ENGINE NDB;
  Query OK, 0 rows affected (1.06 sec)

  ```

  ​          For [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) tables, `STORAGE          DEFAULT` is equivalent to `STORAGE          MEMORY`.        

  ​          The `STORAGE` clause has no effect on tables          using storage engines other than          [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html). The          `STORAGE` keyword is supported only in the          build of [**mysqld**](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/programs.html#mysqld) that is supplied with NDB          Cluster; it is not recognized in any other version of MySQL,          where any attempt to use the `STORAGE`          keyword causes a syntax error.

#### Indexes and Foreign Keys

- ​          `CONSTRAINT          *symbol*`        

  ​          If the `CONSTRAINT          *symbol*` clause is given,          the *symbol* value, if used, must be          unique in the database. A duplicate          *symbol* results in an error. If the          clause is not given, or a *symbol* is          not included following the `CONSTRAINT`          keyword, a name for the constraint is created automatically.        

- ​          `PRIMARY KEY`        

  ​

  ​          A unique index where all key columns must be defined as          `NOT NULL`. If they are not explicitly          declared as `NOT NULL`, MySQL declares them          so implicitly (and silently). A table can have only one          `PRIMARY KEY`. The name of a `PRIMARY          KEY` is always `PRIMARY`, which thus          cannot be used as the name for any other kind of index.        

  ​          If you do not have a `PRIMARY KEY` and an          application asks for the `PRIMARY KEY` in          your tables, MySQL returns the first `UNIQUE`          index that has no `NULL` columns as the          `PRIMARY KEY`.        

  ​          In `InnoDB` tables, keep the `PRIMARY          KEY` short to minimize storage overhead for secondary          indexes. Each secondary index entry contains a copy of the          primary key columns for the corresponding row. (See          [Section 14.11.2.1, “Clustered and Secondary Indexes”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#innodb-index-types).)        

  ​          In the created table, a `PRIMARY KEY` is          placed first, followed by all `UNIQUE`          indexes, and then the nonunique indexes. This helps the MySQL          optimizer to prioritize which index to use and also more          quickly to detect duplicated `UNIQUE` keys.        

  ​          A `PRIMARY KEY` can be a multiple-column          index. However, you cannot create a multiple-column index          using the `PRIMARY KEY` key attribute in a          column specification. Doing so only marks that single column          as primary. You must use a separate `PRIMARY          KEY(*index_col_name*, ...)`          clause.        

  ​

  ​          If a `PRIMARY KEY` consists of only one          column that has an integer type, you can also refer to the          column as `_rowid` in          [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statements.        

  ​          In MySQL, the name of a `PRIMARY KEY` is          `PRIMARY`. For other indexes, if you do not          assign a name, the index is assigned the same name as the          first indexed column, with an optional suffix          (`_2`, `_3`,          `...`) to make it unique. You can see index          names for a table using `SHOW INDEX FROM          *tbl_name*`. See          [Section 13.7.5.23, “SHOW INDEX Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-index).        

- ​          `KEY | INDEX`        

  ​          `KEY` is normally a synonym for          `INDEX`. The key attribute `PRIMARY          KEY` can also be specified as just          `KEY` when given in a column definition. This          was implemented for compatibility with other database systems.        

- ​          `UNIQUE`        

  ​          A `UNIQUE` index creates a constraint such          that all values in the index must be distinct. An error occurs          if you try to add a new row with a key value that matches an          existing row. For all engines, a `UNIQUE`          index permits multiple `NULL` values for          columns that can contain `NULL`. If you          specify a prefix value for a column in a          `UNIQUE` index, the column values must be          unique within the prefix.        

  ​

  ​          If a `UNIQUE` index consists of only one          column that has an integer type, you can also refer to the          column as `_rowid` in          [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statements.        

- ​          `FULLTEXT`        

  ​          A `FULLTEXT` index is a special type of index          used for full-text searches. Only the          `MyISAM` storage engine supports          `FULLTEXT` indexes. They can be created only          from [`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),          [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char), and          [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) columns. Indexing always          happens over the entire column; column prefix indexing is not          supported and any prefix length is ignored if specified. See          [Section 12.9, “Full-Text Search Functions”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#fulltext-search), for details of operation. A          `WITH PARSER` clause can be specified as an          *index_option* value to associate a          parser plugin with the index if full-text indexing and          searching operations need special handling. This clause is          valid only for `FULLTEXT` indexes. See          [Section 24.2, “The MySQL Plugin API”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/extending-mysql.html#plugin-api), for details on creating plugins.        

- ​          `SPATIAL`        

  ​          You can create `SPATIAL` indexes on spatial          data types. Spatial types are supported only for          `MyISAM` tables and indexed columns must be          declared as `NOT NULL`. See          [Section 11.5, “Spatial Data Types”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#spatial-types).        

- ​          `FOREIGN KEY`        

  ​          MySQL supports foreign keys, which let you cross-reference          related data across tables, and foreign key constraints, which          help keep this spread-out data consistent. For definition and          option information, see          [*reference_definition*](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-reference-definition),          and          [*reference_option*](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-reference-option).        

  ​          Partitioned tables employing the          [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html) storage engine do not          support foreign keys. See          [Section 19.5, “Restrictions and Limitations on Partitioning”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/partitioning.html#partitioning-limitations), for more          information.        

- ​          `CHECK`        

  ​          The `CHECK` clause is parsed but ignored by          all storage engines. See          [Section 1.7.2.3, “Foreign Key Differences”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/introduction.html#ansi-diff-foreign-keys).        

- ​          `*index_col_name*`

  - ​              An *index_col_name* specification              can end with `ASC` or              `DESC`. These keywords are permitted for              future extensions for specifying ascending or descending              index value storage. Currently, they are parsed but              ignored; index values are always stored in ascending              order.            

  - ​              Prefixes, defined by the *length*              attribute, can be up to 767 bytes long for              `InnoDB` tables or 3072 bytes if the              [`innodb_large_prefix`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#sysvar_innodb_large_prefix)              option is enabled.            

    ​              Prefix limits are measured in bytes, whereas the prefix              length in [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table),              [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table), and              [`CREATE INDEX`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-index) statements is              interpreted as number of characters for nonbinary string              types ([`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),              [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),              [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob)) and number of bytes              for binary string types              ([`BINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary),              [`VARBINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary),              [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob)). Take this into              account when specifying a prefix length for a nonbinary              string column that uses a multibyte character set.

- ​          `*index_type*`        

  ​          Some storage engines permit you to specify an index type when          creating an index. The syntax for the          *index_type* specifier is          `USING *type_name*`.        

  ​          Example:        

  ```
  CREATE TABLE lookup
    (id INT, INDEX USING BTREE (id))
    ENGINE = MEMORY;

  ```

  ​          The preferred position for `USING` is after          the index column list. It can be given before the column list,          but support for use of the option in that position is          deprecated and will be removed in a future MySQL release.        

- ​          `*index_option*`        

  ​          *index_option* values specify          additional options for an index.

  - ​              `KEY_BLOCK_SIZE`            

    ​              For [`MyISAM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#myisam-storage-engine) tables,              `KEY_BLOCK_SIZE` optionally specifies the              size in bytes to use for index key blocks. The value is              treated as a hint; a different size could be used if              necessary. A `KEY_BLOCK_SIZE` value              specified for an individual index definition overrides the              table-level `KEY_BLOCK_SIZE` value.            

    ​              For information about the table-level              `KEY_BLOCK_SIZE` attribute, see              [Table Options](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-options).            

  - ​              `WITH PARSER`            

    ​              A `WITH PARSER` clause can be specified              as an *index_option* value to              associate a parser plugin with the index if full-text              indexing and searching operations need special handling.              This clause is valid only for `FULLTEXT`              indexes. See [Section 24.2, “The MySQL Plugin API”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/extending-mysql.html#plugin-api), for details on              creating plugins.            

  - ​              `COMMENT`            

    ​              As of MySQL 5.5.3, index definitions can include an              optional comment of up to 1024 characters.

  ​          For more information about permissible          *index_option* values, see          [Section 13.1.13, “CREATE INDEX Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-index). For more information about          indexes, see [Section 8.3.1, “How MySQL Uses Indexes”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/optimization.html#mysql-indexes).        

- ​          `*reference_definition*`        

  ​          For *reference_definition* syntax          details and examples, see          [Section 13.1.17.6, “Using FOREIGN KEY Constraints”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-foreign-keys). For information          specific to foreign keys in `InnoDB`, see          [Section 14.11.1.6, “InnoDB and FOREIGN KEY Constraints”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#innodb-foreign-key-constraints).        

  ​          [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html) tables support checking of          foreign key constraints. The columns of the referenced table          must always be explicitly named. Both `ON          DELETE` and `ON UPDATE` actions on          foreign keys. For more detailed information and examples, see          [Section 13.1.17.6, “Using FOREIGN KEY Constraints”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-foreign-keys). For information          specific to foreign keys in `InnoDB`, see          [Section 14.11.1.6, “InnoDB and FOREIGN KEY Constraints”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#innodb-foreign-key-constraints).        

  ​          For other storage engines, MySQL Server parses and ignores the          `FOREIGN KEY` and          `REFERENCES` syntax in          [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) statements. See          [Section 1.7.2.3, “Foreign Key Differences”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/introduction.html#ansi-diff-foreign-keys).

  Important

  ​            For users familiar with the ANSI/ISO SQL Standard, please            note that no storage engine, including            `InnoDB`, recognizes or enforces the            `MATCH` clause used in referential            integrity constraint definitions. Use of an explicit            `MATCH` clause will not have the specified            effect, and also causes `ON DELETE` and            `ON UPDATE` clauses to be ignored. For            these reasons, specifying `MATCH` should be            avoided.          

  ​            The `MATCH` clause in the SQL standard            controls how `NULL` values in a composite            (multiple-column) foreign key are handled when comparing to            a primary key. `InnoDB` essentially            implements the semantics defined by `MATCH            SIMPLE`, which permit a foreign key to be all or            partially `NULL`. In that case, the (child            table) row containing such a foreign key is permitted to be            inserted, and does not match any row in the referenced            (parent) table. It is possible to implement other semantics            using triggers.          

  ​            Additionally, MySQL requires that the referenced columns be            indexed for performance. However, `InnoDB`            does not enforce any requirement that the referenced columns            be declared `UNIQUE` or `NOT            NULL`. The handling of foreign key references to            nonunique keys or keys that contain `NULL`            values is not well defined for operations such as            `UPDATE` or `DELETE            CASCADE`. You are advised to use foreign keys that            reference only keys that are both `UNIQUE`            (or `PRIMARY`) and `NOT            NULL`.          

  ​            MySQL parses but ignores “inline            `REFERENCES` specifications” (as            defined in the SQL standard) where the references are            defined as part of the column specification. MySQL accepts            `REFERENCES` clauses only when specified as            part of a separate `FOREIGN KEY`            specification.

- ​          `*reference_option*`        

  ​          For information about the `RESTRICT`,          `CASCADE`, `SET NULL`,          `NO ACTION`, and `SET          DEFAULT` options, see          [Section 13.1.17.6, “Using FOREIGN KEY Constraints”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-foreign-keys).

#### Table Options

​      Table options are used to optimize the behavior of the table. In      most cases, you do not have to specify any of them. These options      apply to all storage engines unless otherwise indicated. Options      that do not apply to a given storage engine may be accepted and      remembered as part of the table definition. Such options then      apply if you later use [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table)      to convert the table to use a different storage engine.

- ​          `ENGINE`        

  ​          Specifies the storage engine for the table, using one of the          names shown in the following table. The engine name can be          unquoted or quoted. The quoted name          `'DEFAULT'` is equivalent to specifying the          default storage engine name.

  | Storage Engine                           | Description                              |
  | ---------------------------------------- | ---------------------------------------- |
  | `InnoDB`                                 | Transaction-safe tables with row locking and foreign keys. The default                  storage engine for new tables. See                  [Chapter 14, *The InnoDB Storage Engine*](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html), and in                  particular [Section 14.1, “Introduction to InnoDB”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#innodb-introduction) if                  you have MySQL experience but are new to                  `InnoDB`. |
  | `MyISAM`                                 | The binary portable storage engine that is primarily used for read-only                  or read-mostly workloads. See                  [Section 15.3, “The MyISAM Storage Engine”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#myisam-storage-engine). |
  | `MEMORY`                                 | The data for this storage engine is stored only in memory. See                  [Section 15.4, “The MEMORY Storage Engine”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#memory-storage-engine). |
  | `CSV`                                    | Tables that store rows in comma-separated values format. See                  [Section 15.5, “The CSV Storage Engine”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#csv-storage-engine). |
  | `ARCHIVE`                                | The archiving storage engine. See                  [Section 15.6, “The ARCHIVE Storage Engine”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#archive-storage-engine). |
  | `EXAMPLE`                                | An example engine. See [Section 15.10, “The EXAMPLE Storage Engine”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#example-storage-engine). |
  | `FEDERATED`                              | Storage engine that accesses remote tables. See                  [Section 15.9, “The FEDERATED Storage Engine”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#federated-storage-engine). |
  | `HEAP`                                   | This is a synonym for `MEMORY`.          |
  | `MERGE`                                  | A collection of `MyISAM` tables used as one table. Also                  known as `MRG_MyISAM`. See                  [Section 15.8, “The MERGE Storage Engine”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#merge-storage-engine). |
  | [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) | Clustered, fault-tolerant, memory-based tables. Also known as                  [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html). See[Chapter 18, *MySQL NDB Cluster 7.2*](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html). |

  ​          If a storage engine is specified that is not available, MySQL          uses the default engine instead. Normally, this is          `MyISAM`. For example, if a table definition          includes the `ENGINE=INNODB` option but the          MySQL server does not support `INNODB`          tables, the table is created as a `MyISAM`          table. This makes it possible to have a replication setup          where you have transactional tables on the master but tables          created on the slave are nontransactional (to get more speed).          In MySQL 5.5, a warning occurs if the storage          engine specification is not honored.        

  ​          Engine substitution can be controlled by the setting of the          [`NO_ENGINE_SUBSTITUTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_no_engine_substitution) SQL          mode, as described in [Section 5.1.8, “Server SQL Modes”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sql-mode).

  Note

  ​            The older `TYPE` option was synonymous with            `ENGINE`. `TYPE` was            deprecated in MySQL 4.0 and removed in MySQL 5.5.            *When upgrading to MySQL 5.5 or later, you must            convert existing applications that rely on            TYPE to use ENGINE            instead*.

- ​          `AUTO_INCREMENT`        

  ​          The initial `AUTO_INCREMENT` value for the          table. In MySQL 5.5, this works for          `MyISAM`, `MEMORY`,          `InnoDB`, and `ARCHIVE`          tables. To set the first auto-increment value for engines that          do not support the `AUTO_INCREMENT` table          option, insert a “dummy” row with a value one          less than the desired value after creating the table, and then          delete the dummy row.        

  ​          For engines that support the `AUTO_INCREMENT`          table option in [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table)          statements, you can also use `ALTER TABLE          *tbl_name* AUTO_INCREMENT =          *N*` to reset the          `AUTO_INCREMENT` value. The value cannot be          set lower than the maximum value currently in the column.        

- ​          `AVG_ROW_LENGTH`        

  ​          An approximation of the average row length for your table. You          need to set this only for large tables with variable-size          rows.        

  ​          When you create a `MyISAM` table, MySQL uses          the product of the `MAX_ROWS` and          `AVG_ROW_LENGTH` options to decide how big          the resulting table is. If you don't specify either option,          the maximum size for `MyISAM` data and index          files is 256TB by default. (If your operating system does not          support files that large, table sizes are constrained by the          file size limit.) If you want to keep down the pointer sizes          to make the index smaller and faster and you don't really need          big files, you can decrease the default pointer size by          setting the          [`myisam_data_pointer_size`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_myisam_data_pointer_size)          system variable. (See          [Section 5.1.5, “Server System Variables”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#server-system-variables).) If you want all          your tables to be able to grow above the default limit and are          willing to have your tables slightly slower and larger than          necessary, you can increase the default pointer size by          setting this variable. Setting the value to 7 permits table          sizes up to 65,536TB.        

- ​          `[DEFAULT] CHARACTER SET`        

  ​          Specifies a default character set for the table.          `CHARSET` is a synonym for `CHARACTER          SET`. If the character set name is          `DEFAULT`, the database character set is          used.        

- ​          `CHECKSUM`        

  ​          Set this to 1 if you want MySQL to maintain a live checksum          for all rows (that is, a checksum that MySQL updates          automatically as the table changes). This makes the table a          little slower to update, but also makes it easier to find          corrupted tables. The [`CHECKSUM          TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#checksum-table) statement reports the checksum.          (`MyISAM` only.)        

- ​          `[DEFAULT] COLLATE`        

  ​          Specifies a default collation for the table.        

- ​          `COMMENT`        

  ​          A comment for the table, up to 2048 characters long (60          characters before MySQL 5.5.3).        

- ​          `CONNECTION`        

  ​          The connection string for a `FEDERATED`          table.

  Note

  ​            Older versions of MySQL used a `COMMENT`            option for the connection string.

- ​          `DATA DIRECTORY`, `INDEX          DIRECTORY`        

  ​          By using `DATA          DIRECTORY='*directory*'` or          `INDEX          DIRECTORY='*directory*'` you          can specify where the `MyISAM` storage engine          should put a table's data file and index file. The directory          must be the full path name to the directory, not a relative          path.        

  ​          As of MySQL 5.5.54, you must have the          [`FILE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_file) privilege to use the          `DATA DIRECTORY` or `INDEX          DIRECTORY` table option.

  Important

  ​            Table-level `DATA DIRECTORY` and            `INDEX DIRECTORY` options are ignored for            partitioned tables. (Bug #32091)

  ​          These options work only when you are not using the          [`--skip-symbolic-links`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#option_mysqld_symbolic-links)          option. Your operating system must also have a working,          thread-safe `realpath()` call. See          [Section 8.12.3.2, “Using Symbolic Links for MyISAM Tables on Unix”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/optimization.html#symbolic-links-to-tables), for more complete          information.        

  ​          If a `MyISAM` table is created with no          `DATA DIRECTORY` option, the          `.MYD` file is created in the database          directory. By default, if `MyISAM` finds an          existing `.MYD` file in this case, it          overwrites it. The same applies to `.MYI`          files for tables created with no `INDEX          DIRECTORY` option. To suppress this behavior, start          the server with the          [`--keep_files_on_create`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_keep_files_on_create) option,          in which case `MyISAM` will not overwrite          existing files and returns an error instead.        

  ​          If a `MyISAM` table is created with a          `DATA DIRECTORY` or `INDEX          DIRECTORY` option and an existing          `.MYD` or `.MYI` file is          found, MyISAM always returns an error. It will not overwrite a          file in the specified directory.

  Important

  ​            You cannot use path names that contain the MySQL data            directory with `DATA DIRECTORY` or            `INDEX DIRECTORY`. This includes            partitioned tables and individual table partitions. (See Bug            #32167.)

- ​          `DELAY_KEY_WRITE`        

  ​          Set this to 1 if you want to delay key updates for the table          until the table is closed. See the description of the          [`delay_key_write`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_delay_key_write) system          variable in [Section 5.1.5, “Server System Variables”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#server-system-variables).          (`MyISAM` only.)        

- ​          `INSERT_METHOD`        

  ​          If you want to insert data into a `MERGE`          table, you must specify with `INSERT_METHOD`          the table into which the row should be inserted.          `INSERT_METHOD` is an option useful for          `MERGE` tables only. Use a value of          `FIRST` or `LAST` to have          inserts go to the first or last table, or a value of          `NO` to prevent inserts. See          [Section 15.8, “The MERGE Storage Engine”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#merge-storage-engine).        

- ​          `KEY_BLOCK_SIZE`        

  ​          For [`MyISAM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#myisam-storage-engine) tables,          `KEY_BLOCK_SIZE` optionally specifies the          size in bytes to use for index key blocks. The value is          treated as a hint; a different size could be used if          necessary. A `KEY_BLOCK_SIZE` value specified          for an individual index definition overrides the table-level          `KEY_BLOCK_SIZE` value.        

  ​          For [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html) tables,          `KEY_BLOCK_SIZE` optionally specifies the          [page](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/glossary.html#glos_page) size (in kilobytes) to          use for [compressed](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/glossary.html#glos_compression)          `InnoDB` tables. The          `KEY_BLOCK_SIZE` value is treated as a hint;          a different size could be used by `InnoDB` if          necessary. Valid `KEY_BLOCK_SIZE` values          include 0, 1, 2, 4, 8, and 16. A value of 0 represents the          default compressed page size, which is half of the          `InnoDB` page size.        

  ​          Oracle recommends enabling          [`innodb_strict_mode`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#sysvar_innodb_strict_mode) when          specifying `KEY_BLOCK_SIZE` for          `InnoDB` tables. When          [`innodb_strict_mode`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#sysvar_innodb_strict_mode) is          enabled, specifying an invalid          `KEY_BLOCK_SIZE` value returns an error. If          [`innodb_strict_mode`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#sysvar_innodb_strict_mode) is          disabled, an invalid `KEY_BLOCK_SIZE` value          results in a warning, and the          `KEY_BLOCK_SIZE` option is ignored.        

  ​          The `Create_options` column in response to          [`SHOW TABLE STATUS`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-table-status) reports the          originally specified `KEY_BLOCK_SIZE` option,          as does [`SHOW CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-create-table).        

  ​          `InnoDB` only supports          `KEY_BLOCK_SIZE` at the table level.        

- ​          `MAX_ROWS`        

  ​          The maximum number of rows you plan to store in the table.          This is not a hard limit, but rather a hint to the storage          engine that the table must be able to store at least this many          rows.        

  ​

  ​

  ​

  ​

  ​          The [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) storage engine treats          this value as a maximum. If you plan to create very large NDB          Cluster tables (containing millions of rows), you should use          this option to insure that [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html)          allocates sufficient number of index slots in the hash table          used for storing hashes of the table's primary keys by          setting `MAX_ROWS = 2 *          *rows*`, where          *rows* is the number of rows that you          expect to insert into the table.        

  ​          The maximum `MAX_ROWS` value is 4294967295;          larger values are truncated to this limit.        

- ​          `MIN_ROWS`        

  ​          The minimum number of rows you plan to store in the table. The          [`MEMORY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#memory-storage-engine) storage engine uses this          option as a hint about memory use.        

- ​          `PACK_KEYS`        

  ​          Takes effect only with `MyISAM` tables. Set          this option to 1 if you want to have smaller indexes. This          usually makes updates slower and reads faster. Setting the          option to 0 disables all packing of keys. Setting it to          `DEFAULT` tells the storage engine to pack          only long [`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),          [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char),          [`BINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary), or          [`VARBINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary) columns.        

  ​          If you do not use `PACK_KEYS`, the default is          to pack strings, but not numbers. If you use          `PACK_KEYS=1`, numbers are packed as well.        

  ​          When packing binary number keys, MySQL uses prefix          compression:

  - ​              Every key needs one extra byte to indicate how many bytes              of the previous key are the same for the next key.            
  - ​              The pointer to the row is stored in high-byte-first order              directly after the key, to improve compression.

  ​          This means that if you have many equal keys on two consecutive          rows, all following “same” keys usually only take          two bytes (including the pointer to the row). Compare this to          the ordinary case where the following keys takes          `storage_size_for_key + pointer_size` (where          the pointer size is usually 4). Conversely, you get a          significant benefit from prefix compression only if you have          many numbers that are the same. If all keys are totally          different, you use one byte more per key, if the key is not a          key that can have `NULL` values. (In this          case, the packed key length is stored in the same byte that is          used to mark if a key is `NULL`.)        

- ​          `PASSWORD`        

  ​          This option is unused. If you have a need to scramble your          `.frm` files and make them unusable to any          other MySQL server, please contact our sales department.        

- ​          `ROW_FORMAT`        

  ​          Defines the physical format in which the rows are stored.        

  ​          When executing a [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table)          statement with [strict          mode](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/glossary.html#glos_strict_mode) disabled, if you specify a row format that is not          supported by the storage engine that is used for the table,          the table is created using that storage engine's default          row format. The information reported in the          `Row_format` column in response to          [`SHOW TABLE STATUS`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-table-status) is the actual          row format used. This may differ from the value in the          `Create_options` column because the original          [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) definition is          retained during creation. [`SHOW CREATE          TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-create-table) also reports the row format used in the          original [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table)          statement.        

  ​          Row format choices differ depending on the storage engine used          for the table.        

  ​          For `InnoDB` tables:

  - ​              Rows are stored in compact format              (`ROW_FORMAT=COMPACT`) by default.            
  - ​              The noncompact format used in older versions of MySQL can              still be requested by specifying              `ROW_FORMAT=REDUNDANT`.            
  - ​              To enable compression for `InnoDB`              tables, specify `ROW_FORMAT=COMPRESSED`              and follow the procedures in              [Section 14.12, “InnoDB Table Compression”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#innodb-compression).            
  - ​              For more efficient `InnoDB` storage of              data types, especially [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob)              types, specify `ROW_FORMAT=DYNAMIC` and              follow the procedures in              [Section 14.14.3, “DYNAMIC and COMPRESSED Row Formats”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#innodb-row-format-dynamic). Both the              `COMPRESSED` and              `DYNAMIC` row formats require creating              the table with the configuration settings              [`innodb_file_per_table=1`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#sysvar_innodb_file_per_table)              and              [`innodb_file_format=barracuda`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#sysvar_innodb_file_format).            
  - ​              When you specify a non-default              `ROW_FORMAT` clause, consider also              enabling the              [`innodb_strict_mode`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#sysvar_innodb_strict_mode)              configuration option.            
  - ​              `ROW_FORMAT=FIXED` is not supported. If              `ROW_FORMAT=FIXED` is specified while              [`innodb_strict_mode`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#sysvar_innodb_strict_mode) is              disabled, `InnoDB` issues a warning and              assumes `ROW_FORMAT=COMPACT`. If              `ROW_FORMAT=FIXED` is specified while              [`innodb_strict_mode`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#sysvar_innodb_strict_mode) is              enabled, `InnoDB` returns an error.            
  - ​              For additional information about `InnoDB`              row formats, see [Section 14.14, “InnoDB Row Storage and Row Formats”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#innodb-row-format).

  ​          For `MyISAM` tables, the option value can be          `FIXED` or `DYNAMIC` for          static or variable-length row format.          [**myisampack**](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/programs.html#myisampack) sets the type to          `COMPRESSED`. See          [Section 15.3.3, “MyISAM Table Storage Formats”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#myisam-table-formats).        

- ​          `TABLESPACE`        

  ​          The `TABLESPACE` and          `STORAGE` table options are employed only          with [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) tables. The          tablespace named *tablespace_name*          must already have been created using          [`CREATE TABLESPACE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-tablespace).          `STORAGE` determines the type of storage used          (disk or memory), and can be one of `DISK`,          `MEMORY`, or `DEFAULT`.        

  ​          `TABLESPACE ... STORAGE DISK` assigns a table          to an NDB Cluster Disk Data tablespace. See          [Section 18.5.12, “NDB Cluster Disk Data Tables”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html#mysql-cluster-disk-data), for more          information.

  Important

  ​            A `STORAGE` clause cannot be used in a            [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) statement            without a `TABLESPACE` clause.

- ​          [`UNION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#union)        

  ​          Used to access a collection of identical          `MyISAM` tables as one. This works only with          `MERGE` tables. See          [Section 15.8, “The MERGE Storage Engine”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#merge-storage-engine).        

  ​          You must have [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_select),          [`UPDATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_update), and          [`DELETE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_delete) privileges for the          tables you map to a `MERGE` table.

  Note

  ​            Formerly, all tables used had to be in the same database as            the `MERGE` table itself. This restriction            no longer applies.

#### Creating Partitioned Tables

​      *partition_options* can be used to      control partitioning of the table created with      [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table).    

​      Not all options shown in the syntax for      *partition_options* at the beginning of      this section are available for all partitioning types. Please see      the listings for the following individual types for information      specific to each type, and see [Chapter 19, *Partitioning*](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/partitioning.html), for      more complete information about the workings of and uses for      partitioning in MySQL, as well as additional examples of table      creation and other statements relating to MySQL partitioning.

- ​          `PARTITION BY`        

  ​          If used, a *partition_options* clause          begins with `PARTITION BY`. This clause          contains the function that is used to determine the partition;          the function returns an integer value ranging from 1 to          *num*, where          *num* is the number of partitions.          (The maximum number of user-defined partitions which a table          may contain is 1024; the number of          subpartitions—discussed later in this section—is          included in this maximum.)        

  ​          Partitions can be modified, merged, added to tables, and          dropped from tables. For basic information about the MySQL          statements to accomplish these tasks, see          [Section 13.1.7, “ALTER TABLE Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table). For more detailed descriptions          and examples, see [Section 19.3, “Partition Management”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/partitioning.html#partitioning-management).

  Note

  ​            The expression (*expr*) used in a            `PARTITION BY` clause cannot refer to any            columns not in the table being created; such references are            specifically not permitted and cause the statement to fail            with an error. (Bug #29444)

- ​          `HASH(*expr*)`        

  ​          Hashes one or more columns to create a key for placing and          locating rows. *expr* is an          expression using one or more table columns. This can be any          valid MySQL expression (including MySQL functions) that yields          a single integer value. For example, these are both valid          [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) statements using          `PARTITION BY HASH`:        

  ```
  CREATE TABLE t1 (col1 INT, col2 CHAR(5))
      PARTITION BY HASH(col1);

  CREATE TABLE t1 (col1 INT, col2 CHAR(5), col3 DATETIME)
      PARTITION BY HASH ( YEAR(col3) );

  ```

  ​          You may not use either `VALUES LESS THAN` or          `VALUES IN` clauses with `PARTITION          BY HASH`.        

  ​          `PARTITION BY HASH` uses the remainder of          *expr* divided by the number of          partitions (that is, the modulus). For examples and additional          information, see [Section 19.2.4, “HASH Partitioning”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/partitioning.html#partitioning-hash).        

  ​          The `LINEAR` keyword entails a somewhat          different algorithm. In this case, the number of the partition          in which a row is stored is calculated as the result of one or          more logical [`AND`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#operator_and) operations. For          discussion and examples of linear hashing, see          [Section 19.2.4.1, “LINEAR HASH Partitioning”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/partitioning.html#partitioning-linear-hash).        

- ​          `KEY [ALGORITHM={1|2}]          (*column_list*)`: This is          similar to `HASH`, except that MySQL supplies          the hashing function so as to guarantee an even data          distribution. The *column_list*          argument is simply a list of 1 or more table columns (maximum:          16). This example shows a simple table partitioned by key,          with 4 partitions:        

  ```
  CREATE TABLE tk (col1 INT, col2 CHAR(5), col3 DATE)
      PARTITION BY KEY(col3)
      PARTITIONS 4;

  ```

  ​          For tables that are partitioned by key, you can employ linear          partitioning by using the `LINEAR` keyword.          This has the same effect as with tables that are partitioned          by `HASH`. That is, the partition number is          found using the          [`&`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#operator_bitwise-and)          operator rather than the modulus (see          [Section 19.2.4.1, “LINEAR HASH Partitioning”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/partitioning.html#partitioning-linear-hash), and          [Section 19.2.5, “KEY Partitioning”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/partitioning.html#partitioning-key), for details). This example          uses linear partitioning by key to distribute data between 5          partitions:        

  ```
  CREATE TABLE tk (col1 INT, col2 CHAR(5), col3 DATE)
      PARTITION BY LINEAR KEY(col3)
      PARTITIONS 5;

  ```

  ​          The `ALGORITHM={1|2}` option is supported          with `[SUB]PARTITION BY [LINEAR] KEY`          beginning with MySQL 5.5.31. `ALGORITHM=1`          causes the server to use the same key-hashing functions as          MySQL 5.1; `ALGORITHM=2` means that the          server employs the key-hashing functions implemented and used          by default for new `KEY` partitioned tables          in MySQL 5.5 and later. (Partitioned tables created with the          key-hashing functions employed in MySQL 5.5 and later cannot          be used by a MySQL 5.1 server.) Not specifying the option has          the same effect as using `ALGORITHM=2`. This          option is intended for use chiefly when upgrading or          downgrading `[LINEAR] KEY` partitioned tables          between MySQL 5.1 and later MySQL versions, or for creating          tables partitioned by `KEY` or          `LINEAR KEY` on a MySQL 5.5 or later server          which can be used on a MySQL 5.1 server. For more information,          see [Section 13.1.7.1, “ALTER TABLE Partition Operations”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table-partition-operations).        

  ​          [**mysqldump**](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/programs.html#mysqldump) in MySQL 5.5.31 and later writes          this option encased in versioned comments, like this:        

  ```
  CREATE TABLE t1 (a INT)
  /*!50100 PARTITION BY KEY */ /*!50531 ALGORITHM = 1 */ /*!50100 ()
        PARTITIONS 3 */

  ```

  ​          This causes MySQL 5.5.30 and earlier servers to ignore the          option, which would otherwise cause a syntax error in those          versions. If you plan to load a dump made on a MySQL 5.5.31 or          later MySQL 5.5 server where you use tables that are          partitioned or subpartitioned by `KEY` into a          MySQL 5.6 server previous to version 5.6.11, be sure to          consult          [Changes Affecting Upgrades to MySQL 5.6](http://dev.mysql.com/doc/refman/5.6/en/upgrading-from-previous-series.html),          before proceeding. (The information found there also applies          if you are loading a dump containing `KEY`          partitioned or subpartitioned tables made from a MySQL 5.6.11          or later server into a MySQL 5.5.30 or earlier server.)        

  ​          Also in MySQL 5.5.31 and later, `ALGORITHM=1`          is shown when necessary in the output of          [`SHOW CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-create-table) using          versioned comments in the same manner as          [**mysqldump**](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/programs.html#mysqldump). `ALGORITHM=2`          is always omitted from `SHOW CREATE TABLE`          output, even if this option was specified when creating the          original table.        

  ​          You may not use either `VALUES LESS THAN` or          `VALUES IN` clauses with `PARTITION          BY KEY`.        

- ​          `RANGE(*expr*)`        

  ​          In this case, *expr* shows a range of          values using a set of `VALUES LESS THAN`          operators. When using range partitioning, you must define at          least one partition using `VALUES LESS THAN`.          You cannot use `VALUES IN` with range          partitioning.

  Note

  ​            For tables partitioned by `RANGE`,            `VALUES LESS THAN` must be used with either            an integer literal value or an expression that evaluates to            a single integer value. In MySQL 5.5, you can            overcome this limitation in a table that is defined using            `PARTITION BY RANGE COLUMNS`, as described            later in this section.

  ​          Suppose that you have a table that you wish to partition on a          column containing year values, according to the following          scheme.

  | Partition Number: | Years Range:     |
  | ----------------- | ---------------- |
  | 0                 | 1990 and earlier |
  | 1                 | 1991 to 1994     |
  | 2                 | 1995 to 1998     |
  | 3                 | 1999 to 2002     |
  | 4                 | 2003 to 2005     |
  | 5                 | 2006 and later   |

  ​          A table implementing such a partitioning scheme can be          realized by the [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table)          statement shown here:        

  ```
  CREATE TABLE t1 (
      year_col  INT,
      some_data INT
  )
  PARTITION BY RANGE (year_col) (
      PARTITION p0 VALUES LESS THAN (1991),
      PARTITION p1 VALUES LESS THAN (1995),
      PARTITION p2 VALUES LESS THAN (1999),
      PARTITION p3 VALUES LESS THAN (2002),
      PARTITION p4 VALUES LESS THAN (2006),
      PARTITION p5 VALUES LESS THAN MAXVALUE
  );

  ```

  ​          `PARTITION ... VALUES LESS THAN ...`          statements work in a consecutive fashion. `VALUES LESS          THAN MAXVALUE` works to specify          “leftover” values that are greater than the          maximum value otherwise specified.        

  ​          `VALUES LESS THAN` clauses work sequentially          in a manner similar to that of the `case`          portions of a `switch ... case` block (as          found in many programming languages such as C, Java, and PHP).          That is, the clauses must be arranged in such a way that the          upper limit specified in each successive `VALUES LESS          THAN` is greater than that of the previous one, with          the one referencing `MAXVALUE` coming last of          all in the list.        

- ​          `RANGE          COLUMNS(*column_list*)`        

  ​          This variant on `RANGE` was introduced in          MySQL 5.5.0 to facilitate partition pruning for queries using          range conditions on multiple columns (that is, having          conditions such as `WHERE a = 1 AND b <          10` or `WHERE a = 1 AND b = 10 AND c <          10`). It enables you to specify value ranges in          multiple columns by using a list of columns in the          `COLUMNS` clause and a set of column values          in each `PARTITION ... VALUES LESS THAN          (*value_list*)` partition          definition clause. (In the simplest case, this set consists of          a single column.) The maximum number of columns that can be          referenced in the *column_list* and          *value_list* is 16.        

  ​          The *column_list* used in the          `COLUMNS` clause may contain only names of          columns; each column in the list must be one of the following          MySQL data types: the integer types; the string types; and          time or date column types. Columns using          `BLOB`, `TEXT`,          `SET`, `ENUM`,          `BIT`, or spatial data types are not          permitted; columns that use floating-point number types are          also not permitted. You also may not use functions or          arithmetic expressions in the `COLUMNS`          clause.        

  ​          The `VALUES LESS THAN` clause used in a          partition definition must specify a literal value for each          column that appears in the `COLUMNS()`          clause; that is, the list of values used for each          `VALUES LESS THAN` clause must contain the          same number of values as there are columns listed in the          `COLUMNS` clause. An attempt to use more or          fewer values in a `VALUES LESS THAN` clause          than there are in the `COLUMNS` clause causes          the statement to fail with the error Inconsistency          in usage of column lists for partitioning.... You          cannot use `NULL` for any value appearing in          `VALUES LESS THAN`. It is possible to use          `MAXVALUE` more than once for a given column          other than the first, as shown in this example:        

  ```
  CREATE TABLE rc (
      a INT NOT NULL,
      b INT NOT NULL
  )
  PARTITION BY RANGE COLUMNS(a,b) (
      PARTITION p0 VALUES LESS THAN (10,5),
      PARTITION p1 VALUES LESS THAN (20,10),
      PARTITION p2 VALUES LESS THAN (50,MAXVALUE),
      PARTITION p3 VALUES LESS THAN (65,MAXVALUE),
      PARTITION p4 VALUES LESS THAN (MAXVALUE,MAXVALUE)
  );

  ```

  ​          Each value used in a `VALUES LESS THAN` value          list must match the type of the corresponding column exactly;          no conversion is made. For example, you cannot use the string          `'1'` for a value that matches a column that          uses an integer type (you must use the numeral          `1` instead), nor can you use the numeral          `1` for a value that matches a column that          uses a string type (in such a case, you must use a quoted          string: `'1'`).        

  ​          For more information, see          [Section 19.2.1, “RANGE Partitioning”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/partitioning.html#partitioning-range), and          [Section 19.4, “Partition Pruning”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/partitioning.html#partitioning-pruning).        

- ​          `LIST(*expr*)`        

  ​          This is useful when assigning partitions based on a table          column with a restricted set of possible values, such as a          state or country code. In such a case, all rows pertaining to          a certain state or country can be assigned to a single          partition, or a partition can be reserved for a certain set of          states or countries. It is similar to          `RANGE`, except that only `VALUES          IN` may be used to specify permissible values for          each partition.        

  ​          `VALUES IN` is used with a list of values to          be matched. For instance, you could create a partitioning          scheme such as the following:        

  ```
  CREATE TABLE client_firms (
      id   INT,
      name VARCHAR(35)
  )
  PARTITION BY LIST (id) (
      PARTITION r0 VALUES IN (1, 5, 9, 13, 17, 21),
      PARTITION r1 VALUES IN (2, 6, 10, 14, 18, 22),
      PARTITION r2 VALUES IN (3, 7, 11, 15, 19, 23),
      PARTITION r3 VALUES IN (4, 8, 12, 16, 20, 24)
  );

  ```

  ​          When using list partitioning, you must define at least one          partition using `VALUES IN`. You cannot use          `VALUES LESS THAN` with `PARTITION BY          LIST`.

  Note

  ​            For tables partitioned by `LIST`, the value            list used with `VALUES IN` must consist of            integer values only. In MySQL 5.5, you can            overcome this limitation using partitioning by `LIST            COLUMNS`, which is described later in this section.

- ​          `LIST          COLUMNS(*column_list*)`        

  ​          This variant on `LIST` was introduced in          MySQL 5.5.0 to facilitate partition pruning for queries using          comparison conditions on multiple columns (that is, having          conditions such as `WHERE a = 5 AND b = 5` or          `WHERE a = 1 AND b = 10 AND c = 5`). It          enables you to specify values in multiple columns by using a          list of columns in the `COLUMNS` clause and a          set of column values in each `PARTITION ... VALUES IN          (*value_list*)` partition          definition clause.        

  ​          The rules governing regarding data types for the column list          used in `LIST          COLUMNS(*column_list*)` and          the value list used in `VALUES          IN(*value_list*)` are the          same as those for the column list used in `RANGE          COLUMNS(*column_list*)` and          the value list used in `VALUES LESS          THAN(*value_list*)`,          respectively, except that in the `VALUES IN`          clause, `MAXVALUE` is not permitted, and you          may use `NULL`.        

  ​          There is one important difference between the list of values          used for `VALUES IN` with `PARTITION          BY LIST COLUMNS` as opposed to when it is used with          `PARTITION BY LIST`. When used with          `PARTITION BY LIST COLUMNS`, each element in          the `VALUES IN` clause must be a          *set* of column values; the number of          values in each set must be the same as the number of columns          used in the `COLUMNS` clause, and the data          types of these values must match those of the columns (and          occur in the same order). In the simplest case, the set          consists of a single column. The maximum number of columns          that can be used in the *column_list*          and in the elements making up the          *value_list* is 16.        

  ​          The table defined by the following `CREATE          TABLE` statement provides an example of a table using          `LIST COLUMNS` partitioning:        

  ```
  CREATE TABLE lc (
      a INT NULL,
      b INT NULL
  )
  PARTITION BY LIST COLUMNS(a,b) (
      PARTITION p0 VALUES IN( (0,0), (NULL,NULL) ),
      PARTITION p1 VALUES IN( (0,1), (0,2), (0,3), (1,1), (1,2) ),
      PARTITION p2 VALUES IN( (1,0), (2,0), (2,1), (3,0), (3,1) ),
      PARTITION p3 VALUES IN( (1,3), (2,2), (2,3), (3,2), (3,3) )
  );

  ```

- ​          `PARTITIONS *num*`        

  ​          The number of partitions may optionally be specified with a          `PARTITIONS *num*`          clause, where *num* is the number of          partitions. If both this clause *and* any          `PARTITION` clauses are used,          *num* must be equal to the total          number of any partitions that are declared using          `PARTITION` clauses.

  Note

  ​            Whether or not you use a `PARTITIONS`            clause in creating a table that is partitioned by            `RANGE` or `LIST`, you            must still include at least one `PARTITION            VALUES` clause in the table definition (see below).

- ​          `SUBPARTITION BY`        

  ​          A partition may optionally be divided into a number of          subpartitions. This can be indicated by using the optional          `SUBPARTITION BY` clause. Subpartitioning may          be done by `HASH` or `KEY`.          Either of these may be `LINEAR`. These work          in the same way as previously described for the equivalent          partitioning types. (It is not possible to subpartition by          `LIST` or `RANGE`.)        

  ​          The number of subpartitions can be indicated using the          `SUBPARTITIONS` keyword followed by an          integer value.        

- ​          Rigorous checking of the value used in          `PARTITIONS` or          `SUBPARTITIONS` clauses is applied and this          value must adhere to the following rules:

  - ​              The value must be a positive, nonzero integer.            
  - ​              No leading zeros are permitted.            
  - ​              The value must be an integer literal, and cannot not be an              expression. For example, `PARTITIONS              0.2E+01` is not permitted, even though              `0.2E+01` evaluates to              `2`. (Bug #15890)

- ​          `*partition_definition*`        

  ​          Each partition may be individually defined using a          *partition_definition* clause. The          individual parts making up this clause are as follows:

  - ​              `PARTITION              *partition_name*`            

    ​              Specifies a logical name for the partition.            

  - ​              `VALUES`            

    ​              For range partitioning, each partition must include a              `VALUES LESS THAN` clause; for list              partitioning, you must specify a `VALUES              IN` clause for each partition. This is used to              determine which rows are to be stored in this partition.              See the discussions of partitioning types in              [Chapter 19, *Partitioning*](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/partitioning.html), for syntax examples.            

  - ​              `COMMENT`            

    ​              An optional `COMMENT` clause may be used              to specify a string that describes the partition. Example:            

    ```
    COMMENT = 'Data for the years previous to 1999'

    ```

  - ​              `DATA DIRECTORY` and `INDEX              DIRECTORY`            

    ​              `DATA DIRECTORY` and `INDEX              DIRECTORY` may be used to indicate the directory              where, respectively, the data and indexes for this              partition are to be stored. Both the              `*data_dir*`              and the              `*index_dir*`              must be absolute system path names.            

    ​              As of MySQL 5.5.54, you must have the              [`FILE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_file) privilege to use the              `DATA DIRECTORY` or `INDEX              DIRECTORY` partition option.            

    ​              Example:            

    ```
    CREATE TABLE th (id INT, name VARCHAR(30), adate DATE)
    PARTITION BY LIST(YEAR(adate))
    (
      PARTITION p1999 VALUES IN (1995, 1999, 2003)
        DATA DIRECTORY = '/var/appdata/95/data'
        INDEX DIRECTORY = '/var/appdata/95/idx',
      PARTITION p2000 VALUES IN (1996, 2000, 2004)
        DATA DIRECTORY = '/var/appdata/96/data'
        INDEX DIRECTORY = '/var/appdata/96/idx',
      PARTITION p2001 VALUES IN (1997, 2001, 2005)
        DATA DIRECTORY = '/var/appdata/97/data'
        INDEX DIRECTORY = '/var/appdata/97/idx',
      PARTITION p2002 VALUES IN (1998, 2002, 2006)
        DATA DIRECTORY = '/var/appdata/98/data'
        INDEX DIRECTORY = '/var/appdata/98/idx'
    );

    ```

    ​              `DATA DIRECTORY` and `INDEX              DIRECTORY` behave in the same way as in the              [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) statement's              *table_option* clause as used for              `MyISAM` tables.            

    ​              One data directory and one index directory may be              specified per partition. If left unspecified, the data and              indexes are stored by default in the table's database              directory.            

    ​              On Windows, the `DATA DIRECTORY` and              `INDEX DIRECTORY` options are not              supported for individual partitions or subpartitions.              These options are ignored on Windows, except that a              warning is generated. (Bug #30459)

    Note

    ​                The `DATA DIRECTORY` and `INDEX                DIRECTORY` options are ignored for creating                partitioned tables if                [`NO_DIR_IN_CREATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_no_dir_in_create) is in                effect. (Bug #24633)

  - ​              `MAX_ROWS` and              `MIN_ROWS`            

    ​              May be used to specify, respectively, the maximum and              minimum number of rows to be stored in the partition. The              values for *max_number_of_rows*              and *min_number_of_rows* must be              positive integers. As with the table-level options with              the same names, these act only as              “suggestions” to the server and are not hard              limits.            

  - ​              `TABLESPACE`            

    ​              The optional `TABLESPACE` clause may be              used to designate a tablespace for the partition. Used for              NDB Cluster only.            

  - ​              `[STORAGE] ENGINE`            

    ​              The partitioning handler accepts a `[STORAGE]              ENGINE` option for both              `PARTITION` and              `SUBPARTITION`. Currently, the only way              in which this can be used is to set all partitions or all              subpartitions to the same storage engine, and an attempt              to set different storage engines for partitions or              subpartitions in the same table will give rise to the              error ERROR 1469 (HY000): The mix of handlers              in the partitions is not permitted in this version of              MySQL. We expect to lift this restriction on              partitioning in a future MySQL release.            

  - ​              `NODEGROUP`            

    ​              The `NODEGROUP` option can be used to              make this partition act as part of the node group              identified by *node_group_id*.              This option is applicable only to NDB Cluster.

- ​          `*subpartition_definition*`        

  ​          The partition definition may optionally contain one or more          *subpartition_definition* clauses.          Each of these consists at a minimum of the          `SUBPARTITION          *name*`, where          *name* is an identifier for the          subpartition. Except for the replacement of the          `PARTITION` keyword with          `SUBPARTITION`, the syntax for a subpartition          definition is identical to that for a partition definition.        

  ​          Subpartitioning must be done by `HASH` or          `KEY`, and can be done only on          `RANGE` or `LIST`          partitions. See [Section 19.2.6, “Subpartitioning”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/partitioning.html#partitioning-subpartitions).

#### 13.1.17.1 CREATE TABLE Statement Retention

​        The original [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table)        statement, including all specifications and table options are        stored by MySQL when the table is created. The information is        retained so that if you change storage engines, collations or        other settings using an [`ALTER        TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) statement, the original table options specified        are retained. This enables you to change between        [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html) and        [`MyISAM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#myisam-storage-engine) table types even though the        row formats supported by the two engines are different.      

​        Because the text of the original statement is retained, but due        to the way that certain values and options may be silently        reconfigured (such as the `ROW_FORMAT`), the        active table definition (accessible through        [`DESCRIBE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#describe) or with        [`SHOW TABLE STATUS`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-table-status)) and the table        creation string (accessible through [`SHOW        CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-create-table)) will report different values.

#### 13.1.17.2 Files Created by CREATE TABLE

​        MySQL represents each table by an `.frm`        table format (definition) file in the database directory. The        storage engine for the table might create other files as well.      

​        For `InnoDB` tables, the file storage is        controlled by the        [`innodb_file_per_table`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#sysvar_innodb_file_per_table)        configuration option. For each `InnoDB` table        created when this option is turned on, the table data and all        associated indexes are stored in a        [.ibd file](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/glossary.html#glos_ibd_file) located inside        the database directory. When this option is turned off, all        `InnoDB` tables and indexes are stored in the        [system tablespace](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/glossary.html#glos_system_tablespace),        represented by one or more        [ibdata* files](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/glossary.html#glos_ibdata_file).      

​        For `MyISAM` tables, the storage engine creates        data and index files. Thus, for each `MyISAM`        table *tbl_name*, there are three disk        files.

| File             | Purpose                        |
| ---------------- | ------------------------------ |
| `*tbl_name*.frm` | Table format (definition) file |
| `*tbl_name*.MYD` | Data file                      |
| `*tbl_name*.MYI` | Index file                     |

​        [Chapter 15, *Alternative Storage Engines*](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html), describes what files each        storage engine creates to represent tables. If a table name        contains special characters, the names for the table files        contain encoded versions of those characters as described in        [Section 9.2.3, “Mapping of Identifiers to File Names”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/language-structure.html#identifier-mapping).

#### 13.1.17.3 CREATE TEMPORARY TABLE Syntax

​        You can use the `TEMPORARY` keyword when        creating a table. A `TEMPORARY` table is        visible only within the current session, and is dropped        automatically when the session is closed. This means that two        different sessions can use the same temporary table name without        conflicting with each other or with an existing        non-`TEMPORARY` table of the same name. (The        existing table is hidden until the temporary table is dropped.)      

​        [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) causes an implicit        commit, except when used with the `TEMPORARY`        keyword. See [Section 13.3.3, “Statements That Cause an Implicit Commit”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#implicit-commit).      

​        `TEMPORARY` tables have a very loose        relationship with databases (schemas). Dropping a database does        not automatically drop any `TEMPORARY` tables        created within that database. Also, you can create a        `TEMPORARY` table in a nonexistent database if        you qualify the table name with the database name in the        `CREATE TABLE` statement. In this case, all        subsequent references to the table must be qualified with the        database name.      

​        To create a temporary table, you must have the        [`CREATE TEMPORARY TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_create-temporary-tables)        privilege. However, other operations on a temporary table, such        as [`INSERT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert),        [`UPDATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#update), or        [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select), require additional        privileges for those operations for the database containing the        temporary table, or for the nontemporary table of the same name.      

​        To keep privileges for temporary and nontemporary tables        separate, a common workaround for this situation is to create a        database dedicated to the use of temporary tables. Then for that        database, a user can be granted the [`CREATE        TEMPORARY TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_create-temporary-tables) privilege, along with any other        privileges required for temporary table operations done by that        user.

#### 13.1.17.4 CREATE TABLE ... LIKE Syntax

​        Use `CREATE TABLE ... LIKE` to create an empty        table based on the definition of another table, including any        column attributes and indexes defined in the original table:      

```
CREATE TABLE new_tbl LIKE orig_tbl;

```

​        The copy is created using the same version of the table storage        format as the original table. The        [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_select) privilege is required on        the original table.      

​        `LIKE` works only for base tables, not for        views.

Important

​          Beginning with MySQL 5.5.3, you cannot execute `CREATE          TABLE` or `CREATE TABLE ... LIKE`          while a [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) statement          is in effect.        

​          Also as of MySQL 5.5.3,          [`CREATE TABLE ...          LIKE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) makes the same checks as          [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) and does not just          copy the `.frm` file. This means that if          the current SQL mode is different from the mode in effect when          the original table was created, the table definition might be          considered invalid for the new mode and the statement will          fail.

​        `CREATE TABLE ... LIKE` does not preserve any        `DATA DIRECTORY` or `INDEX        DIRECTORY` table options that were specified for the        original table, or any foreign key definitions.      

​        If the original table is a `TEMPORARY` table,        `CREATE TABLE ... LIKE` does not preserve        `TEMPORARY`. To create a        `TEMPORARY` destination table, use        `CREATE TEMPORARY TABLE ... LIKE`.

#### 13.1.17.5 CREATE TABLE ... SELECT Syntax

​        You can create one table from another by adding a        [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement at the end of        the [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) statement:      

```
CREATE TABLE new_tbl [AS] SELECT * FROM orig_tbl;

```

​        MySQL creates new columns for all elements in the        [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select). For example:      

```
mysql> CREATE TABLE test (a INT NOT NULL AUTO_INCREMENT,
    ->        PRIMARY KEY (a), KEY(b))
    ->        ENGINE=MyISAM SELECT b,c FROM test2;

```

​        This creates a [`MyISAM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#myisam-storage-engine) table with        three columns, `a`, `b`, and        `c`. The `ENGINE` option is        part of the [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table)        statement, and should not be used following the        [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select); this would result in a        syntax error. The same is true for other        [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) options such as        `CHARSET`.      

​        Notice that the columns from the        [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement are appended to        the right side of the table, not overlapped onto it. Take the        following example:      

```
mysql> SELECT * FROM foo;
+---+
| n |
+---+
| 1 |
+---+

mysql> CREATE TABLE bar (m INT) SELECT n FROM foo;
Query OK, 1 row affected (0.02 sec)
Records: 1  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM bar;
+------+---+
| m    | n |
+------+---+
| NULL | 1 |
+------+---+
1 row in set (0.00 sec)

```

​        For each row in table `foo`, a row is inserted        in `bar` with the values from        `foo` and default values for the new columns.      

​        In a table resulting from        [`CREATE TABLE ...        SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table), columns named only in the        [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) part come first.        Columns named in both parts or only in the        [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) part come after that. The        data type of [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) columns can        be overridden by also specifying the column in the        [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) part.      

​        If any errors occur while copying the data to the table, it is        automatically dropped and not created.      

​        You can precede the [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) by        `IGNORE` or `REPLACE` to        indicate how to handle rows that duplicate unique key values.        With `IGNORE`, rows that duplicate an existing        row on a unique key value are discarded. With        `REPLACE`, new rows replace rows that have the        same unique key value. If neither `IGNORE` nor        `REPLACE` is specified, duplicate unique key        values result in an error.      

​        Because the ordering of the rows in the underlying        [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statements cannot always        be determined, `CREATE TABLE ... IGNORE SELECT`        and `CREATE TABLE ... REPLACE SELECT`        statements in MySQL 5.5.18 and later are flagged as unsafe for        statement-based replication. With this change, such statements        produce a warning in the error log when using statement-based        mode and are written to the binary log using the row-based        format when using `MIXED` mode. See also        [Section 17.1.2.1, “Advantages and Disadvantages of Statement-Based and Row-Based        Replication”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/replication.html#replication-sbr-rbr).      

​        [`CREATE TABLE ...        SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) does not automatically create any indexes for        you. This is done intentionally to make the statement as        flexible as possible. If you want to have indexes in the created        table, you should specify these before the        [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement:      

```
mysql> CREATE TABLE bar (UNIQUE (n)) SELECT n FROM foo;

```

​        Some conversion of data types might occur. For example, the        `AUTO_INCREMENT` attribute is not preserved,        and [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) columns can become        [`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) columns. Retrained        attributes are `NULL` (or `NOT        NULL`) and, for those columns that have them,        `CHARACTER SET`, `COLLATION`,        `COMMENT`, and the `DEFAULT`        clause.      

​        When creating a table with        [`CREATE        TABLE ... SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-select), make sure to alias any function        calls or expressions in the query. If you do not, the        `CREATE` statement might fail or result in        undesirable column names.      

```
CREATE TABLE artists_and_works
  SELECT artist.name, COUNT(work.artist_id) AS number_of_works
  FROM artist LEFT JOIN work ON artist.id = work.artist_id
  GROUP BY artist.id;

```

​        You can also explicitly specify the data type for a column in        the created table:      

```
CREATE TABLE foo (a TINYINT NOT NULL) SELECT b+1 AS a FROM bar;

```

​        For [`CREATE TABLE        ... SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table), if `IF NOT EXISTS` is        given and the destination table already exists, the result is        version dependent. Before MySQL 5.5.6, MySQL handles the        statement as follows:

- ​            The table definition given in the            [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) part is ignored.            No error occurs, even if the definition does not match that            of the existing table. MySQL attempts to insert the rows            from the [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) part anyway.          
- ​            If there is a mismatch between the number of columns in the            table and the number of columns produced by the            [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) part, the selected            values are assigned to the rightmost columns. For example,            if the table contains *n* columns            and the [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) produces            *m* columns, where            *m* <            *n*, the selected values are            assigned to the *m* rightmost            columns in the table. Each of the initial            *n* −            *m* columns is assigned its default            value, either that specified explicitly in the column            definition or the implicit column data type default if the            definition contains no default. If the            [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) part produces too many            columns (*m* >            *n*), an error occurs.          
- ​            If strict SQL mode is enabled and any of these initial            columns do not have an explicit default value, the statement            fails with an error.

​        The following example illustrates `IF NOT        EXISTS` handling:      

```
mysql> CREATE TABLE t1 (i1 INT DEFAULT 0, i2 INT, i3 INT, i4 INT);
Query OK, 0 rows affected (0.05 sec)

mysql> CREATE TABLE IF NOT EXISTS t1 (c1 CHAR(10)) SELECT 1, 2;
Query OK, 1 row affected, 1 warning (0.01 sec)
Records: 1  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM t1;
+------+------+------+------+
| i1   | i2   | i3   | i4   |
+------+------+------+------+
|    0 | NULL |    1 |    2 |
+------+------+------+------+
1 row in set (0.00 sec)

```

​        As of MySQL 5.5.6, handling of        [`CREATE        TABLE IF NOT EXISTS ... SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-select) statements was changed        for the case that the destination table already exists. This        change also involves a change in MySQL 5.1 beginning with        5.1.51.

- ​            Previously, for            [`CREATE            TABLE IF NOT EXISTS ... SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-select), MySQL produced a            warning that the table exists, but inserted the rows and            wrote the statement to the binary log anyway. By contrast,            [`CREATE            TABLE ... SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-select) (without `IF NOT            EXISTS`) failed with an error, but MySQL inserted            no rows and did not write the statement to the binary log.          
- ​            MySQL now handles both statements the same way when the            destination table exists, in that neither statement inserts            rows or is written to the binary log. The difference between            them is that MySQL produces a warning when `IF NOT            EXISTS` is present and an error when it is not.

​        This change means that, for the preceding example, the        [`CREATE        TABLE IF NOT EXISTS ... SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-select) statement inserts        nothing into the destination table as of MySQL 5.5.6.      

​        This change in handling of `IF NOT EXISTS`        results in an incompatibility for statement-based replication        from a MySQL 5.1 master with the original behavior and a MySQL        5.5 slave with the new behavior. Suppose that        [`CREATE        TABLE IF NOT EXISTS ... SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-select) is executed on the        master and the destination table exists. The result is that rows        are inserted on the master but not on the slave. (Row-based        replication does not have this problem.)      

​        To address this issue, statement-based binary logging for        [`CREATE        TABLE IF NOT EXISTS ... SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-select) is changed in MySQL 5.1        as of 5.1.51:

- ​            If the destination table does not exist, there is no change:            The statement is logged as is.          
- ​            If the destination table does exist, the statement is logged            as the equivalent pair of            [`CREATE            TABLE IF NOT EXISTS`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-select) and            [`INSERT ...            SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert-select) statements. (If the            [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) in the original            statement is preceded by `IGNORE` or            [`REPLACE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#replace), the            [`INSERT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert) becomes            [`INSERT            IGNORE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert) or [`REPLACE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#replace),            respectively.)

​        This change provides forward compatibility for statement-based        replication from MySQL 5.1 to 5.5 because when the destination        table exists, the rows will be inserted on both the master and        slave. To take advantage of this compatibility measure, the 5.1        server must be at least 5.1.51 and the 5.5 server must be at        least 5.5.6.      

​        To upgrade an existing 5.1-to-5.5 replication scenario, upgrade        the master first to 5.1.51 or higher. Note that this differs        from the usual replication upgrade advice of upgrading the slave        first.      

​        A workaround for applications that wish to achieve the original        effect (rows inserted regardless of whether the destination        table exists) is to use        [`CREATE        TABLE IF NOT EXISTS`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-select) and        [`INSERT ...        SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert-select) statements rather than        [`CREATE        TABLE IF NOT EXISTS ... SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-select) statements.      

​        Along with the change just described, the following related        change was made: Previously, if an existing view was named as        the destination table for        [`CREATE        TABLE IF NOT EXISTS ... SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table-select), rows were inserted        into the underlying base table and the statement was written to        the binary log. As of MySQL 5.1.51 and 5.5.6, nothing is        inserted or logged.      

​        To ensure that the binary log can be used to re-create the        original tables, MySQL does not permit concurrent inserts during        [`CREATE TABLE ...        SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table).

#### 13.1.17.6 Using FOREIGN KEY Constraints

​        MySQL supports foreign keys, which let you cross-reference        related data across tables, and        [foreign key        constraints](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/glossary.html#glos_foreign_key_constraint), which help keep this spread-out data        consistent. The essential syntax for a foreign key constraint        definition in a [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) or        [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) statement looks like        this:      

```
[CONSTRAINT [symbol]] FOREIGN KEY
    [index_name] (index_col_name, ...)
    REFERENCES tbl_name (index_col_name,...)
    [ON DELETE reference_option]
    [ON UPDATE reference_option]

reference_option:
    RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT

```

​        *index_name* represents a foreign key        ID. The *index_name* value is ignored        if there is already an explicitly defined index on the child        table that can support the foreign key. Otherwise, MySQL        implicitly creates a foreign key index that is named according        to the following rules:

- ​            If defined, the `CONSTRAINT`            *symbol* value is used. Otherwise,            the `FOREIGN KEY`            *index_name* value is used.          
- ​            If neither a `CONSTRAINT`            *symbol* or `FOREIGN            KEY` *index_name* is            defined, the foreign key index name is generated using the            name of the referencing foreign key column.

​        Foreign keys definitions are subject to the following        conditions:

- ​            Foreign key relationships involve a            [parent table](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/glossary.html#glos_parent_table) that            holds the central data values, and a            [child table](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/glossary.html#glos_child_table) with            identical values pointing back to its parent. The            `FOREIGN KEY` clause is specified in the            child table. The parent and child tables must use the same            storage engine. They must not be            `TEMPORARY` tables.          

  ​            In MySQL 5.5, creation of a foreign key            constraint requires at least one of the            [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_select),            [`INSERT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_insert),            [`UPDATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_update),            [`DELETE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_delete), or            [`REFERENCES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_references) privileges for the            parent table as of 5.5.41.          

- ​            Corresponding columns in the foreign key and the referenced            key must have similar data types. *The size and            sign of integer types must be the same*. The            length of string types need not be the same. For nonbinary            (character) string columns, the character set and collation            must be the same.          

- ​            When [`foreign_key_checks`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_foreign_key_checks) is            enabled, which is the default setting, character set            conversion is not permitted on tables that include a            character string column used in a foreign key constraint.            The workaround is described in            [Section 13.1.7, “ALTER TABLE Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table).          

- ​            MySQL requires indexes on foreign keys and referenced keys            so that foreign key checks can be fast and not require a            table scan. In the referencing table, there must be an index            where the foreign key columns are listed as the            *first* columns in the same order. Such            an index is created on the referencing table automatically            if it does not exist. This index might be silently dropped            later, if you create another index that can be used to            enforce the foreign key constraint.            *index_name*, if given, is used as            described previously.          

- ​            `InnoDB` permits a foreign key to reference            any column or group of columns. However, in the referenced            table, there must be an index where the referenced columns            are listed as the *first* columns in the            same order.          

- ​            Index prefixes on foreign key columns are not supported. One            consequence of this is that            [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) and            [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) columns cannot be            included in a foreign key because indexes on those columns            must always include a prefix length.          

- ​            If the `CONSTRAINT            *symbol*` clause is given,            the *symbol* value, if used, must            be unique in the database. A duplicate            *symbol* will result in an error            similar to: ERROR 1005 (HY000): Can't create            table 'test.#sql-211d_3' (errno: 121). If the            clause is not given, or a *symbol*            is not included following the `CONSTRAINT`            keyword, a name for the constraint is created automatically.          

- ​            [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html) does not currently            support foreign keys for tables with user-defined            partitioning. This includes both parent and child tables.

##### Referential Actions

​        This section describes how foreign keys help guarantee        [referential        integrity](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/glossary.html#glos_referential_integrity).      

​        For storage engines supporting foreign keys, MySQL rejects any        [`INSERT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert) or        [`UPDATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#update) operation that attempts to        create a foreign key value in a child table if there is no a        matching candidate key value in the parent table.      

​        When an [`UPDATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#update) or        [`DELETE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#delete) operation affects a key        value in the parent table that has matching rows in the child        table, the result depends on the *referential        action* specified using `ON UPDATE`        and `ON DELETE` subclauses of the        `FOREIGN KEY` clause. MySQL supports five        options regarding the action to be taken, listed here:

- ​            `CASCADE`: Delete or update the row from            the parent table, and automatically delete or update the            matching rows in the child table. Both `ON DELETE            CASCADE` and `ON UPDATE CASCADE`            are supported. Between two tables, do not define several            `ON UPDATE CASCADE` clauses that act on the            same column in the parent table or in the child table.

  Note

  ​              Cascaded foreign key actions do not activate triggers.

- ​            `SET NULL`: Delete or update the row from            the parent table, and set the foreign key column or columns            in the child table to `NULL`. Both            `ON DELETE SET NULL` and `ON UPDATE            SET NULL` clauses are supported.          

  ​            If you specify a `SET NULL` action,            *make sure that you have not declared the columns            in the child table as NOT            NULL*.          

- ​            `RESTRICT`: Rejects the delete or update            operation for the parent table. Specifying            `RESTRICT` (or `NO            ACTION`) is the same as omitting the `ON            DELETE` or `ON UPDATE` clause.          

- ​            `NO ACTION`: A keyword from standard SQL.            In MySQL, equivalent to `RESTRICT`. The            MySQL Server rejects the delete or update operation for the            parent table if there is a related foreign key value in the            referenced table. Some database systems have deferred            checks, and `NO ACTION` is a deferred            check. In MySQL, foreign key constraints are checked            immediately, so `NO ACTION` is the same as            `RESTRICT`.          

- ​            `SET DEFAULT`: This action is recognized by            the MySQL parser, but [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html)            rejects table definitions containing `ON DELETE SET            DEFAULT` or `ON UPDATE SET            DEFAULT` clauses.

​        For an `ON DELETE` or `ON        UPDATE` that is not specified, the default action is        always `RESTRICT`.      

​        MySQL supports foreign key references between one column and        another within a table. (A column cannot have a foreign key        reference to itself.) In these cases, “child table        records” really refers to dependent records within the        same table.

##### Examples of Foreign Key Clauses

​        Here is a simple example that relates `parent`        and `child` tables through a single-column        foreign key:      

```
CREATE TABLE parent (
    id INT NOT NULL,
    PRIMARY KEY (id)
) ENGINE=INNODB;

CREATE TABLE child (
    id INT,
    parent_id INT,
    INDEX par_ind (parent_id),
    FOREIGN KEY (parent_id)
        REFERENCES parent(id)
        ON DELETE CASCADE
) ENGINE=INNODB;

```

​        A more complex example in which a        `product_order` table has foreign keys for two        other tables. One foreign key references a two-column index in        the `product` table. The other references a        single-column index in the `customer` table:      

```
CREATE TABLE product (
    category INT NOT NULL, id INT NOT NULL,
    price DECIMAL,
    PRIMARY KEY(category, id)
)   ENGINE=INNODB;

CREATE TABLE customer (
    id INT NOT NULL,
    PRIMARY KEY (id)
)   ENGINE=INNODB;

CREATE TABLE product_order (
    no INT NOT NULL AUTO_INCREMENT,
    product_category INT NOT NULL,
    product_id INT NOT NULL,
    customer_id INT NOT NULL,

    PRIMARY KEY(no),
    INDEX (product_category, product_id),
    INDEX (customer_id),

    FOREIGN KEY (product_category, product_id)
      REFERENCES product(category, id)
      ON UPDATE CASCADE ON DELETE RESTRICT,

    FOREIGN KEY (customer_id)
      REFERENCES customer(id)
)   ENGINE=INNODB;

```

##### Adding foreign keys

​        You can add a new foreign key constraint to an existing table by        using [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table). The syntax        relating to foreign keys for this statement is shown here:      

```
ALTER TABLE tbl_name
    ADD [CONSTRAINT [symbol]] FOREIGN KEY
    [index_name] (index_col_name, ...)
    REFERENCES tbl_name (index_col_name,...)
    [ON DELETE reference_option]
    [ON UPDATE reference_option]

```

​        The foreign key can be self referential (referring to the same        table). When you add a foreign key constraint to a table using        [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table), *remember        to create the required indexes first.*

##### Dropping Foreign Keys

​        You can also use [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) to        drop foreign keys, using the syntax shown here:      

```
ALTER TABLE tbl_name DROP FOREIGN KEY fk_symbol;

```

​        If the `FOREIGN KEY` clause included a        `CONSTRAINT` name when you created the foreign        key, you can refer to that name to drop the foreign key.        Otherwise, the *fk_symbol* value is        generated internally when the foreign key is created. To find        out the symbol value when you want to drop a foreign key, use a        [`SHOW CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-create-table) statement, as        shown here:      

```
mysql> SHOW CREATE TABLE ibtest11c\G
*************************** 1. row ***************************
       Table: ibtest11c
Create Table: CREATE TABLE `ibtest11c` (
  `A` int(11) NOT NULL auto_increment,
  `D` int(11) NOT NULL default '0',
  `B` varchar(200) NOT NULL default '',
  `C` varchar(175) default NULL,
  PRIMARY KEY  (`A`,`D`,`B`),
  KEY `B` (`B`,`C`),
  KEY `C` (`C`),
  CONSTRAINT `0_38775` FOREIGN KEY (`A`, `D`)
REFERENCES `ibtest11a` (`A`, `D`)
ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `0_38776` FOREIGN KEY (`B`, `C`)
REFERENCES `ibtest11a` (`B`, `C`)
ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=INNODB CHARSET=latin1
1 row in set (0.01 sec)

mysql> ALTER TABLE ibtest11c DROP FOREIGN KEY `0_38775`;

```

​        Adding and dropping a foreign key in separate clauses of a        single [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) statement may        be problematic in some cases and is therefore unsupported. Use        separate statements for each operation.      

​        If an [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) statement        results in changes to column values (for example, because a        column is truncated), MySQL's foreign key constraint checks        do not notice possible violations caused by changing the values.

##### Foreign Keys and Other MySQL Statements

​        Table and column identifiers in a `FOREIGN KEY ...        REFERENCES ...` clause can be quoted within backticks        (```). Alternatively, double quotation marks        (`"`) can be used if the        [`ANSI_QUOTES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sqlmode_ansi_quotes) SQL mode is        enabled. The setting of the        [`lower_case_table_names`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_lower_case_table_names) system        variable is also taken into account.      

​        You can view a child table's foreign key definitions as        part of the output of the [`SHOW CREATE        TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-create-table) statement:      

```
SHOW CREATE TABLE tbl_name;

```

​        You can also obtain information about foreign keys by querying        the        [`INFORMATION_SCHEMA.KEY_COLUMN_USAGE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/information-schema.html#key-column-usage-table)        table.      

​        [**mysqldump**](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/programs.html#mysqldump) produces correct definitions of        tables in the dump file, including the foreign keys for child        tables.      

​        To make it easier to reload dump files for tables that have        foreign key relationships, [**mysqldump**](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/programs.html#mysqldump)        automatically includes a statement in the dump output to set        [`foreign_key_checks`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_foreign_key_checks) to 0. This        avoids problems with tables having to be reloaded in a        particular order when the dump is reloaded. It is also possible        to set this variable manually:      

```
mysql> SET foreign_key_checks = 0;
mysql> SOURCE dump_file_name;
mysql> SET foreign_key_checks = 1;

```

​        This enables you to import the tables in any order if the dump        file contains tables that are not correctly ordered for foreign        keys. It also speeds up the import operation. Setting        [`foreign_key_checks`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_foreign_key_checks) to 0 can        also be useful for ignoring foreign key constraints during        [`LOAD DATA`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#load-data) and        [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) operations. However,        even if [`foreign_key_checks = 0`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_foreign_key_checks),        MySQL does not permit the creation of a foreign key constraint        where a column references a nonmatching column type. Also, if a        table has foreign key constraints, [`ALTER        TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) cannot be used to alter the table to use another        storage engine. To change the storage engine, you must drop any        foreign key constraints first.      

​        You cannot issue [`DROP TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-table) for a        table that is referenced by a `FOREIGN KEY`        constraint, unless you do `SET foreign_key_checks =        0`. When you drop a table, any constraints that were        defined in the statement used to create that table are also        dropped.      

​        If you re-create a table that was dropped, it must have a        definition that conforms to the foreign key constraints        referencing it. It must have the correct column names and types,        and it must have indexes on the referenced keys, as stated        earlier. If these are not satisfied, MySQL returns Error 1005        and refers to Error 150 in the error message, which means that a        foreign key constraint was not correctly formed. Similarly, if        an [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) fails due to Error        150, this means that a foreign key definition would be        incorrectly formed for the altered table.      

​        For `InnoDB` tables, you can obtain a detailed        explanation of the most recent `InnoDB` foreign        key error in the MySQL Server, by checking the output of        [`SHOW ENGINE INNODB        STATUS`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-engine).

Important

​          For users familiar with the ANSI/ISO SQL Standard, please note          that no storage engine, including `InnoDB`,          recognizes or enforces the `MATCH` clause          used in referential-integrity constraint definitions. Use of          an explicit `MATCH` clause will not have the          specified effect, and also causes `ON DELETE`          and `ON UPDATE` clauses to be ignored. For          these reasons, specifying `MATCH` should be          avoided.        

​          The `MATCH` clause in the SQL standard          controls how `NULL` values in a composite          (multiple-column) foreign key are handled when comparing to a          primary key. MySQL essentially implements the semantics          defined by `MATCH SIMPLE`, which permit a          foreign key to be all or partially `NULL`. In          that case, the (child table) row containing such a foreign key          is permitted to be inserted, and does not match any row in the          referenced (parent) table. It is possible to implement other          semantics using triggers.        

​          Additionally, MySQL requires that the referenced columns be          indexed for performance reasons. However, the system does not          enforce a requirement that the referenced columns be          `UNIQUE` or be declared `NOT          NULL`. The handling of foreign key references to          nonunique keys or keys that contain `NULL`          values is not well defined for operations such as          [`UPDATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#update) or `DELETE          CASCADE`. You are advised to use foreign keys that          reference only `UNIQUE` (including          `PRIMARY`) and `NOT NULL`          keys.        

​          Furthermore, MySQL parses but ignores “inline          `REFERENCES` specifications” (as          defined in the SQL standard) where the references are defined          as part of the column specification. MySQL accepts          `REFERENCES` clauses only when specified as          part of a separate `FOREIGN KEY`          specification. For storage engines that do not support foreign          keys (such as [`MyISAM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#myisam-storage-engine)), MySQL          Server parses and ignores foreign key specifications.

#### 13.1.17.7 Silent Column Specification Changes

​        In some cases, MySQL silently changes column specifications from        those given in a [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) or        [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) statement. These        might be changes to a data type, to attributes associated with a        data type, or to an index specification.      

​        All changes are subject to the internal row-size limit of 65,535        bytes, which may cause some attempts at data type changes to        fail. See [Section C.10.4, “Limits on Table Column Count and Row Size”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/restrictions.html#column-count-limit).

- ​            [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime) display sizes are            discarded.          

  ​            Also note that [`TIMESTAMP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#datetime)            columns are `NOT NULL` by default.          

- ​            Columns that are part of a `PRIMARY KEY`            are made `NOT NULL` even if not declared            that way.          

- ​            Trailing spaces are automatically deleted from            [`ENUM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum) and            [`SET`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#set) member values when the            table is created.          

- ​            MySQL maps certain data types used by other SQL database            vendors to MySQL types. See            [Section 11.9, “Using Data Types from Other Database Engines”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#other-vendor-data-types).          

- ​            If you include a `USING` clause to specify            an index type that is not permitted for a given storage            engine, but there is another index type available that the            engine can use without affecting query results, the engine            uses the available type.          

- ​            If strict SQL mode is not enabled, a            [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) column with a length            specification greater than 65535 is converted to            [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob), and a            [`VARBINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary) column with a            length specification greater than 65535 is converted to            [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob). Otherwise, an error            occurs in either of these cases.          

- ​            Specifying the `CHARACTER SET binary`            attribute for a character data type causes the column to be            created as the corresponding binary data type:            [`CHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) becomes            [`BINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary),            [`VARCHAR`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#char) becomes            [`VARBINARY`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#binary-varbinary), and            [`TEXT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob) becomes            [`BLOB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#blob). For the            [`ENUM`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#enum) and            [`SET`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/data-types.html#set) data types, this does not            occur; they are created as declared. Suppose that you            specify a table using this definition:          

  ```
  CREATE TABLE t
  (
    c1 VARCHAR(10) CHARACTER SET binary,
    c2 TEXT CHARACTER SET binary,
    c3 ENUM('a','b','c') CHARACTER SET binary
  );

  ```

  ​            The resulting table has this definition:          

  ```
  CREATE TABLE t
  (
    c1 VARBINARY(10),
    c2 BLOB,
    c3 ENUM('a','b','c') CHARACTER SET binary
  );

  ```

​        To see whether MySQL used a data type other than the one you        specified, issue a [`DESCRIBE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#describe) or        [`SHOW CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-create-table) statement after        creating or altering the table.      

​        Certain other data type changes can occur if you compress a        table using [**myisampack**](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/programs.html#myisampack). See        [Section 15.3.3.3, “Compressed Table Characteristics”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/storage-engines.html#compressed-format).

### 13.1.18 CREATE TABLESPACE Syntax

```
CREATE TABLESPACE tablespace_name
    ADD DATAFILE 'file_name'
    USE LOGFILE GROUP logfile_group
    [EXTENT_SIZE [=] extent_size]
    [INITIAL_SIZE [=] initial_size]
    [AUTOEXTEND_SIZE [=] autoextend_size]
    [MAX_SIZE [=] max_size]
    [NODEGROUP [=] nodegroup_id]
    [WAIT]
    [COMMENT [=] comment_text]
    ENGINE [=] engine_name

```

​      This statement is used to create a tablespace, which can contain      one or more data files, providing storage space for tables. One      data file is created and added to the tablespace using this      statement. Additional data files may be added to the tablespace by      using the [`ALTER TABLESPACE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-tablespace)      statement (see [Section 13.1.8, “ALTER TABLESPACE Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-tablespace)). For rules      covering the naming of tablespaces, see      [Section 9.2, “Schema Object Names”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/language-structure.html#identifiers).

Note

​        All NDB Cluster Disk Data objects share the same namespace. This        means that *each Disk Data object* must be        uniquely named (and not merely each Disk Data object of a given        type). For example, you cannot have a tablespace and a log file        group with the same name, or a tablespace and a data file with        the same name.

​      A log file group of one or more `UNDO` log files      must be assigned to the tablespace to be created with the      `USE LOGFILE GROUP` clause.      *logfile_group* must be an existing log      file group created with [`CREATE LOGFILE      GROUP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-logfile-group) (see [Section 13.1.14, “CREATE LOGFILE GROUP Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-logfile-group)).      Multiple tablespaces may use the same log file group for      `UNDO` logging.    

​      The `EXTENT_SIZE` sets the size, in bytes, of the      extents used by any files belonging to the tablespace. The default      value is 1M. The minimum size is 32K, and theoretical maximum is      2G, although the practical maximum size depends on a number of      factors. In most cases, changing the extent size does not have any      measurable effect on performance, and the default value is      recommended for all but the most unusual situations.    

​      An extent is a unit of disk      space allocation. One extent is filled with as much data as that      extent can contain before another extent is used. In theory, up to      65,535 (64K) extents may used per data file; however, the      recommended maximum is 32,768 (32K). The recommended maximum size      for a single data file is 32G—that is, 32K extents × 1      MB per extent. In addition, once an extent is allocated to a given      partition, it cannot be used to store data from a different      partition; an extent cannot store data from more than one      partition. This means, for example that a tablespace having a      single datafile whose `INITIAL_SIZE` is 256 MB      and whose `EXTENT_SIZE` is 128M has just two      extents, and so can be used to store data from at most two      different disk data table partitions.    

​      You can see how many extents remain free in a given data file by      querying the [`INFORMATION_SCHEMA.FILES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/information-schema.html#files-table)      table, and so derive an estimate for how much space remains free      in the file. For further discussion and examples, see      [Section 21.29.1, “The INFORMATION_SCHEMA FILES Table”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/information-schema.html#files-table).    

​      The `INITIAL_SIZE` parameter sets the data file's      total size in bytes. Once the file has been created, its size      cannot be changed; however, you can add more data files to the      tablespace using `ALTER TABLESPACE ... ADD      DATAFILE`. See [Section 13.1.8, “ALTER TABLESPACE Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-tablespace).    

​      `INITIAL_SIZE` is optional; its default value is      134217728 (128 MB).    

​      On 32-bit systems, the maximum supported value for      `INITIAL_SIZE` is 4294967296 (4 GB). (Bug #29186)    

​      When setting `EXTENT_SIZE`, you may optionally      follow the number with a one-letter abbreviation for an order of      magnitude, similar to those used in `my.cnf`.      Generally, this is one of the letters `M` (for      megabytes) or `G` (for gigabytes). In MySQL NDB      Cluster 7.2.14 and later, these abbreviations are also supported      when specifying `INITIAL_SIZE` as well. (Bug      #13116514, Bug #16104705, Bug #62858)    

​      `INITIAL_SIZE`, `EXTENT_SIZE`,      and `UNDO_BUFFER_SIZE` are subject to rounding as      follows:

- ​          `EXTENT_SIZE` and          `UNDO_BUFFER_SIZE` are each rounded up to the          nearest whole multiple of 32K.        

- ​          `INITIAL_SIZE` is rounded          *down* to the nearest whole multiple of          32K.        

  ​          For data files, *INITIAL_SIZE* is subject          to further rounding; the result just obtained is rounded up to          the nearest whole multiple of `EXTENT_SIZE`          (after any rounding).

​      The rounding just described is done explicitly, and a warning is      issued by the MySQL Server when any such rounding is performed.      The rounded values are also used by the NDB kernel for calculating      [`INFORMATION_SCHEMA.FILES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/information-schema.html#files-table) column      values and other purposes. However, to avoid an unexpected result,      we suggest that you always use whole multiples of 32K in      specifying these options.    

​      `AUTOEXTEND_SIZE`, `MAX_SIZE`,      `NODEGROUP`, `WAIT`, and      `COMMENT` are parsed but ignored, and so      currently have no effect. These options are intended for future      expansion.    

​      The `ENGINE` parameter determines the storage      engine which uses this tablespace, with      *engine_name* being the name of the      storage engine. Currently, *engine_name*      must be one of the values [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) or      [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html).    

​      When [`CREATE TABLESPACE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-tablespace) is used with      `ENGINE = NDB`, a tablespace and associated data      file are created on each Cluster data node. You can verify that      the data files were created and obtain information about them by      querying the [`INFORMATION_SCHEMA.FILES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/information-schema.html#files-table)      table. For example:    

```
mysql> SELECT LOGFILE_GROUP_NAME, FILE_NAME, EXTRA
    -> FROM INFORMATION_SCHEMA.FILES
    -> WHERE TABLESPACE_NAME = 'newts' AND FILE_TYPE = 'DATAFILE';
+--------------------+-------------+----------------+
| LOGFILE_GROUP_NAME | FILE_NAME   | EXTRA          |
+--------------------+-------------+----------------+
| lg_3               | newdata.dat | CLUSTER_NODE=3 |
| lg_3               | newdata.dat | CLUSTER_NODE=4 |
+--------------------+-------------+----------------+
2 rows in set (0.01 sec)

```

​      (See [Section 21.29.1, “The INFORMATION_SCHEMA FILES Table”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/information-schema.html#files-table).)    

​      [`CREATE TABLESPACE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-tablespace) is useful only      with Disk Data storage for NDB Cluster. See      [Section 18.5.12, “NDB Cluster Disk Data Tables”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html#mysql-cluster-disk-data).

### 13.1.19 CREATE TRIGGER Syntax

```
CREATE
    [DEFINER = { user | CURRENT_USER }]
    TRIGGER trigger_name
    trigger_time trigger_event
    ON tbl_name FOR EACH ROW
    trigger_body

trigger_time: { BEFORE | AFTER }

trigger_event: { INSERT | UPDATE | DELETE }

```

​      This statement creates a new trigger. A trigger is a named      database object that is associated with a table, and that      activates when a particular event occurs for the table. The      trigger becomes associated with the table named      *tbl_name*, which must refer to a      permanent table. You cannot associate a trigger with a      `TEMPORARY` table or a view.    

​      Trigger names exist in the schema namespace, meaning that all      triggers must have unique names within a schema. Triggers in      different schemas can have the same name.    

​      This section describes [`CREATE      TRIGGER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-trigger) syntax. For additional discussion, see      [Section 20.3.1, “Trigger Syntax and Examples”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/stored-programs-views.html#trigger-syntax).    

​      [`CREATE TRIGGER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-trigger) requires the      [`TRIGGER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_trigger) privilege for the table      associated with the trigger. The statement might also require the      [`SUPER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_super) privilege, depending on the      `DEFINER` value, as described later in this      section. If binary logging is enabled, [`CREATE      TRIGGER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-trigger) might require the      [`SUPER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_super) privilege, as described in      [Section 20.7, “Binary Logging of Stored Programs”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/stored-programs-views.html#stored-programs-logging).    

​      The `DEFINER` clause determines the security      context to be used when checking access privileges at trigger      activation time, as described later in this section.    

​      *trigger_time* is the trigger action      time. It can be `BEFORE` or      `AFTER` to indicate that the trigger activates      before or after each row to be modified.    

​      Basic column value checks occur prior to trigger activation, so      you cannot use `BEFORE` triggers to convert      values inappropriate for the column type to valid values.    

​      *trigger_event* indicates the kind of      operation that activates the trigger. These      *trigger_event* values are permitted:

- ​          [`INSERT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert): The trigger activates          whenever a new row is inserted into the table; for example,          through [`INSERT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert),          [`LOAD DATA`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#load-data), and          [`REPLACE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#replace) statements.        
- ​          [`UPDATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#update): The trigger activates          whenever a row is modified; for example, through          [`UPDATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#update) statements.        
- ​          [`DELETE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#delete): The trigger activates          whenever a row is deleted from the table; for example, through          [`DELETE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#delete) and          [`REPLACE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#replace) statements.          [`DROP TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-table) and          [`TRUNCATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#truncate-table) statements on          the table do *not* activate this trigger,          because they do not use [`DELETE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#delete).          Dropping a partition does not activate          [`DELETE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#delete) triggers, either.

​      The *trigger_event* does not represent a      literal type of SQL statement that activates the trigger so much      as it represents a type of table operation. For example, an      [`INSERT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert) trigger activates not only      for [`INSERT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert) statements but also      [`LOAD DATA`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#load-data) statements because both      statements insert rows into a table.    

​      A potentially confusing example of this is the `INSERT      INTO ... ON DUPLICATE KEY UPDATE ...` syntax: a      `BEFORE INSERT` trigger activates for every row,      followed by either an `AFTER INSERT` trigger or      both the `BEFORE UPDATE` and `AFTER      UPDATE` triggers, depending on whether there was a      duplicate key for the row.

Note

​        Cascaded foreign key actions do not activate triggers.

​      There cannot be multiple triggers for a given table that have the      same trigger event and action time. For example, you cannot have      two `BEFORE UPDATE` triggers for a table. But you      can have a `BEFORE UPDATE` and a `BEFORE      INSERT` trigger, or a `BEFORE UPDATE`      and an `AFTER UPDATE` trigger.    

​      *trigger_body* is the statement to      execute when the trigger activates. To execute multiple      statements, use the      [`BEGIN ... END`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#begin-end)      compound statement construct. This also enables you to use the      same statements that are permissible within stored routines. See      [Section 13.6.1, “BEGIN ... END Compound-Statement Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#begin-end). Some statements are not permitted in      triggers; see [Section C.1, “Restrictions on Stored Programs”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/restrictions.html#stored-program-restrictions).    

​      Within the trigger body, you can refer to columns in the subject      table (the table associated with the trigger) by using the aliases      `OLD` and `NEW`.      `OLD.*col_name*` refers      to a column of an existing row before it is updated or deleted.      `NEW.*col_name*` refers      to the column of a new row to be inserted or an existing row after      it is updated.    

​      MySQL stores the [`sql_mode`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_sql_mode) system      variable setting in effect when a trigger is created, and always      executes the trigger body with this setting in force,      *regardless of the current server SQL mode when the      trigger begins executing*.    

​      The `DEFINER` clause specifies the MySQL account      to be used when checking access privileges at trigger activation      time. If a *user* value is given, it      should be a MySQL account specified as      `'*user_name*'@'*host_name*'`,      [`CURRENT_USER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-user), or      [`CURRENT_USER()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-user). The default      `DEFINER` value is the user who executes the      [`CREATE TRIGGER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-trigger) statement. This is      the same as specifying `DEFINER = CURRENT_USER`      explicitly.    

​      If you specify the `DEFINER` clause, these rules      determine the valid `DEFINER` user values:

- ​          If you do not have the [`SUPER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_super)          privilege, the only permitted *user*          value is your own account, either specified literally or by          using [`CURRENT_USER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-user). You cannot          set the definer to some other account.        
- ​          If you have the [`SUPER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_super)          privilege, you can specify any syntactically valid account          name. If the account does not exist, a warning is generated.        
- ​          Although it is possible to create a trigger with a nonexistent          `DEFINER` account, it is not a good idea for          such triggers to be activated until the account actually does          exist. Otherwise, the behavior with respect to privilege          checking is undefined.

​      MySQL takes the `DEFINER` user into account when      checking trigger privileges as follows:

- ​          At [`CREATE TRIGGER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-trigger) time, the          user who issues the statement must have the          [`TRIGGER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_trigger) privilege.        
- ​          At trigger activation time, privileges are checked against the          `DEFINER` user. This user must have these          privileges:
  - ​              The [`TRIGGER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_trigger) privilege for              the subject table.            
  - ​              The [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_select) privilege for              the subject table if references to table columns occur              using              `OLD.*col_name*`              or              `NEW.*col_name*`              in the trigger body.            
  - ​              The [`UPDATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_update) privilege for              the subject table if table columns are targets of              `SET NEW.*col_name* =              *value*` assignments in              the trigger body.            
  - ​              Whatever other privileges normally are required for the              statements executed by the trigger.

​      For more information about trigger security, see      [Section 20.6, “Access Control for Stored Programs and Views”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/stored-programs-views.html#stored-programs-security).    

​      Within a trigger body, the      [`CURRENT_USER()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-user) function returns the      account used to check privileges at trigger activation time. This      is the `DEFINER` user, not the user whose actions      caused the trigger to be activated. For information about user      auditing within triggers, see      [Section 6.3.8, “SQL-Based MySQL Account Activity Auditing”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#account-activity-auditing).    

​      If you use [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) to lock a      table that has triggers, the tables used within the trigger are      also locked, as described in      [Section 13.3.5.2, “LOCK TABLES and Triggers”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables-and-triggers).    

​      For additional discussion of trigger use, see      [Section 20.3.1, “Trigger Syntax and Examples”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/stored-programs-views.html#trigger-syntax).

### 13.1.20 CREATE VIEW Syntax

```
CREATE
    [OR REPLACE]
    [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
    [DEFINER = { user | CURRENT_USER }]
    [SQL SECURITY { DEFINER | INVOKER }]
    VIEW view_name [(column_list)]
    AS select_statement
    [WITH [CASCADED | LOCAL] CHECK OPTION]

```

​      The [`CREATE VIEW`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-view) statement creates a      new view, or replaces an existing view if the `OR      REPLACE` clause is given. If the view does not exist,      [`CREATE OR REPLACE      VIEW`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-view) is the same as [`CREATE      VIEW`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-view). If the view does exist,      [`CREATE OR REPLACE      VIEW`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-view) replaces it.    

​      For information about restrictions on view use, see      [Section C.5, “Restrictions on Views”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/restrictions.html#view-restrictions).    

​      The *select_statement* is a      [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement that provides the      definition of the view. (Selecting from the view selects, in      effect, using the [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select)      statement.) The *select_statement* can      select from base tables or other views.    

​      The view definition is “frozen” at creation time and      is not affected by subsequent changes to the definitions of the      underlying tables. For example, if a view is defined as      `SELECT *` on a table, new columns added to the      table later do not become part of the view, and columns dropped      from the table will result in an error when selecting from the      view.    

​      The `ALGORITHM` clause affects how MySQL      processes the view. The `DEFINER` and      `SQL SECURITY` clauses specify the security      context to be used when checking access privileges at view      invocation time. The `WITH CHECK OPTION` clause      can be given to constrain inserts or updates to rows in tables      referenced by the view. These clauses are described later in this      section.    

​      The [`CREATE VIEW`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-view) statement requires      the [`CREATE VIEW`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_create-view) privilege for the      view, and some privilege for each column selected by the      [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement. For columns used      elsewhere in the [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement,      you must have the [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_select) privilege.      If the `OR REPLACE` clause is present, you must      also have the [`DROP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_drop) privilege for      the view. [`CREATE VIEW`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-view) might also      require the [`SUPER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_super) privilege,      depending on the `DEFINER` value, as described      later in this section.    

​      When a view is referenced, privilege checking occurs as described      later in this section.    

​      A view belongs to a database. By default, a new view is created in      the default database. To create the view explicitly in a given      database, use *db_name.view_name* syntax      to qualify the view name with the database name:    

```
CREATE VIEW test.v AS SELECT * FROM t;

```

​      Unqualified table or view names in the      [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement are also      interpreted with respect to the default database. A view can refer      to tables or views in other databases by qualifying the table or      view name with the appropriate database name.    

​      Within a database, base tables and views share the same namespace,      so a base table and a view cannot have the same name.    

​      Columns retrieved by the [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select)      statement can be simple references to table columns, or      expressions that use functions, constant values, operators, and so      forth.    

​      A view must have unique column names with no duplicates, just like      a base table. By default, the names of the columns retrieved by      the [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement are used for      the view column names. To define explicit names for the view      columns, specify the optional      *column_list* clause as a list of      comma-separated identifiers. The number of names in      *column_list* must be the same as the      number of columns retrieved by the      [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement.    

​      A view can be created from many kinds of      [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statements. It can refer to      base tables or other views. It can use joins,      [`UNION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#union), and subqueries. The      [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) need not even refer to any      tables:    

```
CREATE VIEW v_today (today) AS SELECT CURRENT_DATE;

```

​      The following example defines a view that selects two columns from      another table as well as an expression calculated from those      columns:    

```
mysql> CREATE TABLE t (qty INT, price INT);
mysql> INSERT INTO t VALUES(3, 50);
mysql> CREATE VIEW v AS SELECT qty, price, qty*price AS value FROM t;
mysql> SELECT * FROM v;
+------+-------+-------+
| qty  | price | value |
+------+-------+-------+
|    3 |    50 |   150 |
+------+-------+-------+

```

​      A view definition is subject to the following restrictions:

- ​          The [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement cannot          contain a subquery in the `FROM` clause.        
- ​          The [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement cannot          refer to system variables or user-defined variables.        
- ​          Within a stored program, the          [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement cannot refer          to program parameters or local variables.        
- ​          The [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement cannot          refer to prepared statement parameters.        
- ​          Any table or view referred to in the definition must exist.          If, after the view has been created, a table or view that the          definition refers to is dropped, use of the view results in an          error. To check a view definition for problems of this kind,          use the [`CHECK TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#check-table) statement.        
- ​          The definition cannot refer to a `TEMPORARY`          table, and you cannot create a `TEMPORARY`          view.        
- ​          You cannot associate a trigger with a view.        
- ​          Aliases for column names in the          [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) statement are checked          against the maximum column length of 64 characters (not the          maximum alias length of 256 characters).

​      `ORDER BY` is permitted in a view definition, but      it is ignored if you select from a view using a statement that has      its own `ORDER BY` or filtering or grouping. When      `ORDER BY` is combined with      `LIMIT` or `OFFSET` in a view      definition, the ordering is always enforced before the query      result is used by the outer query, but it does not guarantee that      the same ordering is used in the end result. As a workaround, add      an `ORDER BY` clause to the outer query.    

​      For other options or clauses in the definition, they are added to      the options or clauses of the statement that references the view,      but the effect is undefined. For example, if a view definition      includes a `LIMIT` clause, and you select from      the view using a statement that has its own      `LIMIT` clause, it is undefined which limit      applies. This same principle applies to options such as      `ALL`, `DISTINCT`, or      `SQL_SMALL_RESULT` that follow the      [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) keyword, and to clauses such      as `INTO`, `FOR UPDATE`,      `LOCK IN SHARE MODE`, and      `PROCEDURE`.    

​      The results obtained from a view may be affected if you change the      query processing environment by changing system variables:    

```
mysql> CREATE VIEW v (mycol) AS SELECT 'abc';
Query OK, 0 rows affected (0.01 sec)

mysql> SET sql_mode = '';
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT "mycol" FROM v;
+-------+
| mycol |
+-------+
| mycol |
+-------+
1 row in set (0.01 sec)

mysql> SET sql_mode = 'ANSI_QUOTES';
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT "mycol" FROM v;
+-------+
| mycol |
+-------+
| abc   |
+-------+
1 row in set (0.00 sec)

```

​      The `DEFINER` and `SQL SECURITY`      clauses determine which MySQL account to use when checking access      privileges for the view when a statement is executed that      references the view. The valid `SQL SECURITY`      characteristic values are `DEFINER` (the default)      and `INVOKER`. These indicate that the required      privileges must be held by the user who defined or invoked the      view, respectively.    

​      If a *user* value is given for the      `DEFINER` clause, it should be a MySQL account      specified as      `'*user_name*'@'*host_name*'`,      [`CURRENT_USER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-user), or      [`CURRENT_USER()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-user). The default      `DEFINER` value is the user who executes the      [`CREATE VIEW`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-view) statement. This is the      same as specifying `DEFINER = CURRENT_USER`      explicitly.    

​      If the `DEFINER` clause is present, these rules      determine the valid `DEFINER` user values:

- ​          If you do not have the [`SUPER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_super)          privilege, the only valid *user*          value is your own account, either specified literally or by          using [`CURRENT_USER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-user). You cannot          set the definer to some other account.        
- ​          If you have the [`SUPER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_super)          privilege, you can specify any syntactically valid account          name. If the account does not exist, a warning is generated.        
- ​          Although it is possible to create a view with a nonexistent          `DEFINER` account, an error occurs when the          view is referenced if the `SQL SECURITY`          value is `DEFINER` but the definer account          does not exist.

​      For more information about view security, see      [Section 20.6, “Access Control for Stored Programs and Views”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/stored-programs-views.html#stored-programs-security).    

​      Within a view definition,      [`CURRENT_USER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-user) returns the view's      `DEFINER` value by default. For views defined      with the `SQL SECURITY INVOKER` characteristic,      [`CURRENT_USER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-user) returns the account      for the view's invoker. For information about user auditing within      views, see [Section 6.3.8, “SQL-Based MySQL Account Activity Auditing”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#account-activity-auditing).    

​      Within a stored routine that is defined with the `SQL      SECURITY DEFINER` characteristic,      [`CURRENT_USER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-user) returns the routine's      `DEFINER` value. This also affects a view defined      within such a routine, if the view definition contains a      `DEFINER` value of      [`CURRENT_USER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_current-user).    

​      MySQL checks view privileges like this:

- ​          At view definition time, the view creator must have the          privileges needed to use the top-level objects accessed by the          view. For example, if the view definition refers to table          columns, the creator must have some privilege for each column          in the select list of the definition, and the          [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_select) privilege for each          column used elsewhere in the definition. If the definition          refers to a stored function, only the privileges needed to          invoke the function can be checked. The privileges required at          function invocation time can be checked only as it executes:          For different invocations, different execution paths within          the function might be taken.        
- ​          The user who references a view must have appropriate          privileges to access it ([`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_select)          to select from it, [`INSERT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_insert) to          insert into it, and so forth.)        
- ​          When a view has been referenced, privileges for objects          accessed by the view are checked against the privileges held          by the view `DEFINER` account or invoker,          depending on whether the `SQL SECURITY`          characteristic is `DEFINER` or          `INVOKER`, respectively.        
- ​          If reference to a view causes execution of a stored function,          privilege checking for statements executed within the function          depend on whether the function `SQL SECURITY`          characteristic is `DEFINER` or          `INVOKER`. If the security characteristic is          `DEFINER`, the function runs with the          privileges of the `DEFINER` account. If the          characteristic is `INVOKER`, the function          runs with the privileges determined by the view's `SQL          SECURITY` characteristic.

​      Example: A view might depend on a stored function, and that      function might invoke other stored routines. For example, the      following view invokes a stored function `f()`:    

```
CREATE VIEW v AS SELECT * FROM t WHERE t.id = f(t.name);

```

​      Suppose that `f()` contains a statement such as      this:    

```
IF name IS NULL then
  CALL p1();
ELSE
  CALL p2();
END IF;

```

​      The privileges required for executing statements within      `f()` need to be checked when      `f()` executes. This might mean that privileges      are needed for `p1()` or `p2()`,      depending on the execution path within `f()`.      Those privileges must be checked at runtime, and the user who must      possess the privileges is determined by the `SQL      SECURITY` values of the view `v` and the      function `f()`.    

​      The `DEFINER` and `SQL SECURITY`      clauses for views are extensions to standard SQL. In standard SQL,      views are handled using the rules for `SQL SECURITY      DEFINER`. The standard says that the definer of the view,      which is the same as the owner of the view's schema, gets      applicable privileges on the view (for example,      [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_select)) and may grant them. MySQL      has no concept of a schema “owner”, so MySQL adds a      clause to identify the definer. The `DEFINER`      clause is an extension where the intent is to have what the      standard has; that is, a permanent record of who defined the view.      This is why the default `DEFINER` value is the      account of the view creator.    

​      The optional `ALGORITHM` clause is a MySQL      extension to standard SQL. It affects how MySQL processes the      view. `ALGORITHM` takes three values:      `MERGE`, `TEMPTABLE`, or      `UNDEFINED`. The default algorithm is      `UNDEFINED` if no `ALGORITHM`      clause is present. For more information, see      [Section 20.5.2, “View Processing Algorithms”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/stored-programs-views.html#view-algorithms), as well as      [Optimizing Derived Tables](http://dev.mysql.com/doc/refman/5.6/en/derived-table-optimization.html).    

​      Some views are updatable. That is, you can use them in statements      such as [`UPDATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#update),      [`DELETE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#delete), or      [`INSERT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert) to update the contents of      the underlying table. For a view to be updatable, there must be a      one-to-one relationship between the rows in the view and the rows      in the underlying table. There are also certain other constructs      that make a view nonupdatable.    

​      The `WITH CHECK OPTION` clause can be given for      an updatable view to prevent inserts or updates to rows except      those for which the `WHERE` clause in the      *select_statement* is true.    

​      In a `WITH CHECK OPTION` clause for an updatable      view, the `LOCAL` and `CASCADED`      keywords determine the scope of check testing when the view is      defined in terms of another view. The `LOCAL`      keyword restricts the `CHECK OPTION` only to the      view being defined. `CASCADED` causes the checks      for underlying views to be evaluated as well. When neither keyword      is given, the default is `CASCADED`.    

​      For more information about updatable views and the `WITH      CHECK OPTION` clause, see      [Section 20.5.3, “Updatable and Insertable Views”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/stored-programs-views.html#view-updatability), and      [Section 20.5.4, “The View WITH CHECK OPTION Clause”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/stored-programs-views.html#view-check-option).

### 13.1.21 DROP DATABASE Syntax

```
DROP {DATABASE | SCHEMA} [IF EXISTS] db_name

```

​      [`DROP DATABASE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-database) drops all tables in      the database and deletes the database. Be      *very* careful with this statement! To use      [`DROP DATABASE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-database), you need the      [`DROP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_drop) privilege on the database.      [`DROP      SCHEMA`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-database) is a synonym for [`DROP      DATABASE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-database).

Important

​        When a database is dropped, privileges granted specifically for        the database are *not* automatically dropped.        They must be dropped manually. See [Section 13.7.1.3, “GRANT Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#grant).

​      `IF EXISTS` is used to prevent an error from      occurring if the database does not exist.    

​      If the default database is dropped, the default database is unset      (the [`DATABASE()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_database) function returns      `NULL`).    

​      If you use [`DROP DATABASE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-database) on a      symbolically linked database, both the link and the original      database are deleted.    

​      [`DROP DATABASE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-database) returns the number of      tables that were removed. This corresponds to the number of      `.frm` files removed.    

​      The [`DROP DATABASE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-database) statement removes      from the given database directory those files and directories that      MySQL itself may create during normal operation:

- ​          All files with the following extensions.

  | `.BAK` | `.DAT` | `.HSH` | `.MRG` |
  | ------ | ------ | ------ | ------ |
  | `.MYD` | `.MYI` | `.TRG` | `.TRN` |
  | `.db`  | `.frm` | `.ibd` | `.ndb` |
  | `.par` |        |        |        |

- ​          The `db.opt` file, if it exists.

​      If other files or directories remain in the database directory      after MySQL removes those just listed, the database directory      cannot be removed. In this case, you must remove any remaining      files or directories manually and issue the      [`DROP DATABASE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-database) statement again.    

​      Dropping a database does not remove any      `TEMPORARY` tables that were created in that      database. `TEMPORARY` tables are automatically      removed when the session that created them ends. See      [Section 13.1.17.3, “CREATE TEMPORARY TABLE Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-temporary-table).    

​      You can also drop databases with [**mysqladmin**](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/programs.html#mysqladmin).      See [Section 4.5.2, “**mysqladmin** — Client for Administering a MySQL Server”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/programs.html#mysqladmin).

### 13.1.22 DROP EVENT Syntax

```
DROP EVENT [IF EXISTS] event_name

```

​      This statement drops the event named      *event_name*. The event immediately      ceases being active, and is deleted completely from the server.    

​      If the event does not exist, the error ERROR 1517      (HY000): Unknown event      '*event_name*' results. You      can override this and cause the statement to generate a warning      for nonexistent events instead using `IF EXISTS`.    

​      This statement requires the [`EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_event)      privilege for the schema to which the event to be dropped belongs.

### 13.1.23 DROP FUNCTION Syntax

​      The [`DROP FUNCTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-function) statement is used      to drop stored functions and user-defined functions (UDFs):

- ​          For information about dropping stored functions, see          [Section 13.1.26, “DROP PROCEDURE and DROP FUNCTION Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-procedure).        
- ​          For information about dropping user-defined functions, see          [Section 13.7.3.2, “DROP FUNCTION Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-function-udf).

### 13.1.24 DROP INDEX Syntax

```
DROP [ONLINE|OFFLINE] INDEX index_name ON tbl_name

```

​      [`DROP INDEX`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-index) drops the index named      *index_name* from the table      *tbl_name*. This statement is mapped to      an [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) statement to drop      the index. See [Section 13.1.7, “ALTER TABLE Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table).    

​      To drop a primary key, the index name is always      `PRIMARY`, which must be specified as a quoted      identifier because `PRIMARY` is a reserved word:    

```
DROP INDEX `PRIMARY` ON t;

```

​      Indexes on variable-width columns of      [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) tables are dropped online; that      is, without any table copying. The table is not locked against      access from other NDB Cluster API nodes, although it is locked      against other operations on the *same* API node      for the duration of the operation. This is done automatically by      the server whenever it determines that it is possible to do so;      you do not have to use any special SQL syntax or server options to      cause it to happen.    

​      In standard MySQL 5.5 releases, it is not possible to      override the server when it determines that an index is to be      dropped without table copying. In NDB Cluster, you can drop      indexes offline (which causes the table to be locked for all API      nodes in the cluster) using the `OFFLINE`      keyword. The rules and limitations governing `DROP OFFLINE      INDEX` and `DROP ONLINE INDEX` are the      same as for `ALTER OFFLINE TABLE ... DROP INDEX`      and `ALTER ONLINE TABLE ... DROP INDEX`. You      cannot cause the noncopying dropping of an index that would      normally be dropped offline by using the `ONLINE`      keyword: If it is not possible to perform the      `DROP` operation without table copying, the      server ignores the `ONLINE` keyword. For more      information, see [Section 13.1.7.2, “ALTER TABLE Online Operations in NDB Cluster 7.2”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table-online-operations).    

​      The `ONLINE` and `OFFLINE`      keywords are available only in NDB Cluster; attempting to use      these keywords in standard MySQL Server 5.5 releases      results in a syntax error.

### 13.1.25 DROP LOGFILE GROUP Syntax

```
DROP LOGFILE GROUP logfile_group
    ENGINE [=] engine_name

```

​      This statement drops the log file group named      *logfile_group*. The log file group must      already exist or an error results. (For information on creating      log file groups, see [Section 13.1.14, “CREATE LOGFILE GROUP Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-logfile-group).)

Important

​        Before dropping a log file group, you must drop all tablespaces        that use that log file group for `UNDO`        logging.

​      The required `ENGINE` clause provides the name of      the storage engine used by the log file group to be dropped.      Currently, the only permitted values for      *engine_name* are      [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) and      [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html).    

​      [`DROP LOGFILE GROUP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-logfile-group) is useful only      with Disk Data storage for NDB Cluster. See      [Section 18.5.12, “NDB Cluster Disk Data Tables”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html#mysql-cluster-disk-data).

### 13.1.26 DROP PROCEDURE and DROP FUNCTION Syntax

```
DROP {PROCEDURE | FUNCTION} [IF EXISTS] sp_name

```

​      This statement is used to drop a stored procedure or function.      That is, the specified routine is removed from the server. You      must have the [`ALTER ROUTINE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_alter-routine)      privilege for the routine. (If the      `automatic_sp_privileges` system variable is      enabled, that privilege and [`EXECUTE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_execute)      are granted automatically to the routine creator when the routine      is created and dropped from the creator when the routine is      dropped. See [Section 20.2.2, “Stored Routines and MySQL Privileges”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/stored-programs-views.html#stored-routines-privileges).)    

​      The `IF EXISTS` clause is a MySQL extension. It      prevents an error from occurring if the procedure or function does      not exist. A warning is produced that can be viewed with      [`SHOW WARNINGS`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-warnings).    

​      [`DROP FUNCTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-function) is also used to drop      user-defined functions (see [Section 13.7.3.2, “DROP FUNCTION Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-function-udf)).

### 13.1.27 DROP SERVER Syntax

```
DROP SERVER [ IF EXISTS ] server_name

```

​      Drops the server definition for the server named      `*server_name*`. The      corresponding row in the `mysql.servers` table is      deleted. This statement requires the      [`SUPER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_super) privilege.    

​      Dropping a server for a table does not affect any      `FEDERATED` tables that used this connection      information when they were created. See      [Section 13.1.16, “CREATE SERVER Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-server).    

​      `DROP SERVER` causes an implicit commit. See      [Section 13.3.3, “Statements That Cause an Implicit Commit”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#implicit-commit).    

​      `DROP SERVER` is not written to the binary log,      regardless of the logging format that is in use.

### 13.1.28 DROP TABLE Syntax

```
DROP [TEMPORARY] TABLE [IF EXISTS]
    tbl_name [, tbl_name] ...
    [RESTRICT | CASCADE]

```

`DROP TABLE` removes one or more      tables. You must have the [`DROP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_drop)      privilege for each table.    

*Be careful* with this statement! It removes      the table definition and all table data. For a partitioned table,      it permanently removes the table definition, all its partitions,      and all data stored in those partitions. It also removes the      partitioning definition (`.par`) file      associated with the dropped table.    

`DROP TABLE` causes an implicit      commit, except when used with the `TEMPORARY`      keyword. See [Section 13.3.3, “Statements That Cause an Implicit Commit”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#implicit-commit).

Important

​        When a table is dropped, privileges granted specifically for the        table are *not* automatically dropped. They        must be dropped manually. See [Section 13.7.1.3, “GRANT Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#grant).

​      If any tables named in the argument list do not exist, the      statement returns an error indicating by name which nonexisting      tables it was unable to drop, but also drops all tables in the      list that do exist.    

​      Use `IF EXISTS` to prevent an error from      occurring for tables that do not exist. Instead of an error, a      `NOTE` is generated for each nonexistent table;      these notes can be displayed with [`SHOW      WARNINGS`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-warnings). See [Section 13.7.5.41, “SHOW WARNINGS Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-warnings).    

​      `IF EXISTS` can also be useful for dropping      tables in unusual circumstances under which there is an      `.frm` file but no table managed by the storage      engine. (For example, if an abnormal server exit occurs after      removal of the table from the storage engine but before      `.frm` file removal.)    

​      The `TEMPORARY` keyword has the following      effects:

- ​          The statement drops only `TEMPORARY` tables.        
- ​          The statement does not cause an implicit commit.        
- ​          No access rights are checked. A `TEMPORARY`          table is visible only with the session that created it, so no          check is necessary.

​      Using `TEMPORARY` is a good way to ensure that      you do not accidentally drop a non-`TEMPORARY`      table.    

​      The `RESTRICT` and `CASCADE`      keywords do nothing. They are permitted to make porting easier      from other database systems.

### 13.1.29 DROP TABLESPACE Syntax

```
DROP TABLESPACE tablespace_name
    ENGINE [=] engine_name

```

​      This statement drops a tablespace that was previously created      using [`CREATE TABLESPACE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-tablespace) (see      [Section 13.1.18, “CREATE TABLESPACE Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-tablespace)).

Important

​        The tablespace to be dropped must not contain any data files; in        other words, before you can drop a tablespace, you must first        drop each of its data files using `ALTER TABLESPACE ...        DROP DATAFILE` (see        [Section 13.1.8, “ALTER TABLESPACE Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-tablespace)).

​      The `ENGINE` clause (required) specifies the      storage engine used by the tablespace. Currently, the only      accepted values for *engine_name* are      [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) and      [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html).    

​      [`DROP TABLESPACE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-tablespace) is useful only with      Disk Data storage for NDB Cluster. See      [Section 18.5.12, “NDB Cluster Disk Data Tables”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html#mysql-cluster-disk-data).

### 13.1.30 DROP TRIGGER Syntax

```
DROP TRIGGER [IF EXISTS] [schema_name.]trigger_name

```

​      This statement drops a trigger. The schema (database) name is      optional. If the schema is omitted, the trigger is dropped from      the default schema. [`DROP TRIGGER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-trigger)      requires the [`TRIGGER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_trigger) privilege for      the table associated with the trigger.    

​      Use `IF EXISTS` to prevent an error from      occurring for a trigger that does not exist. A      `NOTE` is generated for a nonexistent trigger      when using `IF EXISTS`. See      [Section 13.7.5.41, “SHOW WARNINGS Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-warnings).    

​      Triggers for a table are also dropped if you drop the table.

Note

​        When upgrading from a version of MySQL older than MySQL 5.0.10        to 5.0.10 or higher—including all MySQL 5.5        releases—you must drop all triggers and re-create them.        Otherwise, [`DROP TRIGGER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-trigger) does not        work for older triggers after the upgrade. See        [Section 2.11.1.1, “Changes Affecting Upgrades to MySQL 5.5”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/installing.html#upgrading-from-previous-series), for a        suggested upgrade procedure.

### 13.1.31 DROP VIEW Syntax

```
DROP VIEW [IF EXISTS]
    view_name [, view_name] ...
    [RESTRICT | CASCADE]

```

​      [`DROP VIEW`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-view) removes one or more      views. You must have the [`DROP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_drop)      privilege for each view.    

​      If any views named in the argument list do not exist, the      statement returns an error indicating by name which nonexisting      views it was unable to drop, but also drops all views in the list      that do exist.    

​      The `IF EXISTS` clause prevents an error from      occurring for views that don't exist. When this clause is given, a      `NOTE` is generated for each nonexistent view.      See [Section 13.7.5.41, “SHOW WARNINGS Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-warnings).    

​      `RESTRICT` and `CASCADE`, if      given, are parsed and ignored.

### 13.1.32 RENAME TABLE Syntax

```
RENAME TABLE
    tbl_name TO new_tbl_name
    [, tbl_name2 TO new_tbl_name2] ...

```

​      [`RENAME TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#rename-table) renames one or more      tables. You must have [`ALTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_alter) and      [`DROP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_drop) privileges for the original      table, and [`CREATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_create) and      [`INSERT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_insert) privileges for the new      table.    

​      For example, to rename a table named `old_table`      to to `new_table`, use this statement:    

```
RENAME TABLE old_table TO new_table;

```

​      That statement is equivalent to the following      [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) statement:    

```
ALTER TABLE old_table RENAME new_table;

```

​      `RENAME TABLE`, unlike [`ALTER      TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table), can rename multiple tables within a single      statement:    

```
RENAME TABLE old_table1 TO new_table1,
             old_table2 TO new_table2,
             old_table3 TO new_table3;

```

​      Renaming operations are performed left to right. Thus, to swap two      table names, do this (assuming that a table with the intermediary      name `tmp_table` does not already exist):    

```
RENAME TABLE old_table TO tmp_table,
             new_table TO old_table,
             tmp_table TO new_table;

```

​      When you execute `RENAME TABLE`, you cannot have      any locked tables or active transactions. With that condition      satisfied, the rename operation is done atomically; no other      session can access any of the tables while the rename is in      progress.    

​      If any errors occur during a `RENAME TABLE`, the      statement fails and no changes are made.    

​      You can use `RENAME TABLE` to move a table from      one database to another:    

```
RENAME TABLE current_db.tbl_name TO other_db.tbl_name;

```

​      Using this method to move all tables from one database to a      different one in effect renames the database (an operation for      which MySQL has no single statement), except that the original      database continues to exist, albeit with no tables.    

​      Like `RENAME TABLE`, `ALTER TABLE ...      RENAME` can also be used to move a table to a different      database. Regardless of the statement used, if the rename      operation would move the table to a database located on a      different file system, the success of the outcome is platform      specific and depends on the underlying operating system calls used      to move the table files.    

​      If a table has triggers, attempts to rename the table into a      different database fail with a Trigger in wrong      schema error.    

​      `RENAME TABLE` does not work for      `TEMPORARY` tables. However, you can use      [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) to rename      `TEMPORARY` tables.    

​      `RENAME TABLE` works for views, except that views      cannot be renamed into a different database.    

​      Any privileges granted specifically for a renamed table or view      are not migrated to the new name. They must be changed manually.    

​      `RENAME TABLE` changes internally generated      foreign key constraint names and user-defined foreign key      constraint names that contain the string      “*tbl_name*_ibfk_” to      reflect the new table name. `InnoDB` interprets      foreign key constraint names that contain the string      “*tbl_name*_ibfk_” as      internally generated names.    

​      Foreign key constraint names that point to the renamed table are      automatically updated unless there is a conflict, in which case,      the statement fails with an error. A conflict occurs if the      renamed constraint name already exists. In such cases, you must      drop and re-create the foreign keys in order for them to function      properly.

### 13.1.33 TRUNCATE TABLE Syntax

```
TRUNCATE [TABLE] tbl_name

```

​      [`TRUNCATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#truncate-table) empties a table      completely. It requires the [`DROP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_drop)      privilege.    

​      Logically, [`TRUNCATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#truncate-table) is      similar to a [`DELETE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#delete) statement that      deletes all rows, or a sequence of [`DROP      TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-table) and [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table)      statements. To achieve high performance, it bypasses the DML      method of deleting data. Thus, it cannot be rolled back, it does      not cause `ON DELETE` triggers to fire, and it      cannot be performed for `InnoDB` tables with      parent-child foreign key relationships.    

​      Although [`TRUNCATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#truncate-table) is similar      to [`DELETE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#delete), it is classified as a      DDL statement rather than a DML statement. It differs from      [`DELETE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#delete) in the following ways:

- ​          Truncate operations drop and re-create the table, which is          much faster than deleting rows one by one, particularly for          large tables.        
- ​          Truncate operations cause an implicit commit, and so cannot be          rolled back. See [Section 13.3.3, “Statements That Cause an Implicit Commit”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#implicit-commit).        
- ​          Truncation operations cannot be performed if the session holds          an active table lock.        
- ​          [`TRUNCATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#truncate-table) fails for an          `InnoDB` table if there are any          `FOREIGN KEY` constraints from other tables          that reference the table. Foreign key constraints between          columns of the same table are permitted.        
- ​          Truncation operations do not return a meaningful value for the          number of deleted rows. The usual result is “0 rows          affected,” which should be interpreted as “no          information.”        
- ​          As long as the table format file          `*tbl_name*.frm`          is valid, the table can be re-created as an empty table with          [`TRUNCATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#truncate-table), even if the          data or index files have become corrupted.        
- ​          Any `AUTO_INCREMENT` value is reset to its          start value. This is true even for `MyISAM`          and `InnoDB`, which normally do not reuse          sequence values.        
- ​          When used with partitioned tables,          [`TRUNCATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#truncate-table) preserves the          partitioning; that is, the data and index files are dropped          and re-created, while the partition definitions          (`.par`) file is unaffected.        
- ​          The [`TRUNCATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#truncate-table) statement          does not invoke `ON DELETE` triggers.

​      [`TRUNCATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#truncate-table) for a table closes      all handlers for the table that were opened with      [`HANDLER OPEN`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#handler).    

​      [`TRUNCATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#truncate-table) is treated for      purposes of binary logging and replication as      [`DROP TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-table) followed by      [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table)—that is, as DDL      rather than DML. This is due to the fact that, when using      [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html) and other transactional      storage engines where the transaction isolation level does not      permit statement-based logging ([`READ      COMMITTED`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#isolevel_read-committed) or [`READ      UNCOMMITTED`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#isolevel_read-uncommitted)), the statement was not logged and      replicated when using `STATEMENT` or      `MIXED` logging mode. (Bug #36763) However, it is      still applied on replication slaves using      [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html) in the manner described      previously.    

​      On a system with a large `InnoDB` buffer pool and      [`innodb_adaptive_hash_index`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#sysvar_innodb_adaptive_hash_index)      enabled, `TRUNCATE TABLE` operations may cause a      temporary drop in system performance due to an LRU scan that      occurs when removing an `InnoDB` table's adaptive      hash index entries. The problem was addressed for      [`DROP TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-table) in MySQL 5.5.23 (Bug      #13704145, Bug #64284) but remains a known issue for      `TRUNCATE TABLE` (Bug #68184).    

​      [`TRUNCATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#truncate-table) can be used with      Performance Schema summary tables, but the effect is to reset the      summary columns to 0 or `NULL`, not to remove      rows. See [Section 22.9.5, “Performance Schema Summary Tables”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/performance-schema.html#performance-schema-summary-tables).