

## 13.3 Transactional and Locking Statements

MySQL supports local transactions (within a given client session)    through statements such as    [`SET autocommit`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit),    [`START TRANSACTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit),    [`COMMIT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit), and    [`ROLLBACK`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit). See    [Section 13.3.1, “START TRANSACTION, COMMIT, and ROLLBACK Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit). XA transaction support enables MySQL to    participate in distributed transactions as well. See    [Section 13.3.7, “XA Transactions”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#xa).

### 13.3.1 START TRANSACTION, COMMIT, and ROLLBACK Syntax

```
START TRANSACTION [WITH CONSISTENT SNAPSHOT]
BEGIN [WORK]
COMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE]
ROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE]
SET autocommit = {0 | 1}

```

​      These statements provide control over use of      [transactions](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/glossary.html#glos_transaction):

- ​          `START TRANSACTION` or          `BEGIN` start a new transaction.        
- ​          `COMMIT` commits the current transaction,          making its changes permanent.        
- ​          `ROLLBACK` rolls back the current          transaction, canceling its changes.        
- ​          `SET autocommit` disables or enables the          default autocommit mode for the current session.

​      By default, MySQL runs with      [autocommit](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/glossary.html#glos_autocommit) mode enabled.      This means that as soon as you execute a statement that updates      (modifies) a table, MySQL stores the update on disk to make it      permanent. The change cannot be rolled back.    

​      To disable autocommit mode implicitly for a single series of      statements, use the `START TRANSACTION`      statement:    

```
START TRANSACTION;
SELECT @A:=SUM(salary) FROM table1 WHERE type=1;
UPDATE table2 SET summary=@A WHERE type=1;
COMMIT;

```

​      With `START TRANSACTION`, autocommit remains      disabled until you end the transaction with      `COMMIT` or `ROLLBACK`. The      autocommit mode then reverts to its previous state.    

​      You can also begin a transaction like this:    

```
START TRANSACTION WITH CONSISTENT SNAPSHOT;

```

​      The `WITH CONSISTENT SNAPSHOT` option starts a      [consistent      read](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/glossary.html#glos_consistent_read) for storage engines that are capable of it. This      applies only to `InnoDB`. The effect is the same      as issuing a `START TRANSACTION` followed by a      [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) from any      `InnoDB` table. See      [Section 14.8.2.3, “Consistent Nonlocking Reads”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#innodb-consistent-read). The `WITH      CONSISTENT SNAPSHOT` option does not change the current      transaction [isolation      level](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/glossary.html#glos_isolation_level), so it provides a consistent snapshot only if the      current isolation level is one that permits a consistent read. The      only isolation level that permits a consistent read is      [`REPEATABLE READ`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#isolevel_repeatable-read). For all other      isolation levels, the `WITH CONSISTENT SNAPSHOT`      clause is ignored. As of MySQL 5.5.34, a warning is generated when      the `WITH CONSISTENT SNAPSHOT` is ignored.

Important

​        Many APIs used for writing MySQL client applications (such as        JDBC) provide their own methods for starting transactions that        can (and sometimes should) be used instead of sending a        `START TRANSACTION` statement from the client.        See [Chapter 23, *Connectors and APIs*](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/connectors-apis.html), or the documentation for        your API, for more information.

​      To disable autocommit mode explicitly, use the following      statement:    

```
SET autocommit=0;

```

​      After disabling autocommit mode by setting the      [`autocommit`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_autocommit) variable to zero,      changes to transaction-safe tables (such as those for      [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html) or      [`NDBCLUSTER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html)) are not made permanent      immediately. You must use `COMMIT` to store your      changes to disk or `ROLLBACK` to ignore the      changes.    

​      [`autocommit`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_autocommit) is a session variable      and must be set for each session. To disable autocommit mode for      each new connection, see the description of the      [`autocommit`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_autocommit) system variable at      [Section 5.1.5, “Server System Variables”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#server-system-variables).    

​      `BEGIN` and `BEGIN WORK` are      supported as aliases of `START TRANSACTION` for      initiating a transaction. `START TRANSACTION` is      standard SQL syntax and is the recommended way to start an ad-hoc      transaction.    

​      The `BEGIN` statement differs from the use of the      `BEGIN` keyword that starts a      [`BEGIN ... END`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#begin-end)      compound statement. The latter does not begin a transaction. See      [Section 13.6.1, “BEGIN ... END Compound-Statement Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#begin-end).

Note

​        Within all stored programs (stored procedures and functions,        triggers, and events), the parser treats `BEGIN        [WORK]` as the beginning of a        [`BEGIN ...        END`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#begin-end) block. Begin a transaction in this context with        `START TRANSACTION` instead.

​      The optional `WORK` keyword is supported for      `COMMIT` and `ROLLBACK`, as are      the `CHAIN` and `RELEASE`      clauses. `CHAIN` and `RELEASE`      can be used for additional control over transaction completion.      The value of the [`completion_type`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_completion_type)      system variable determines the default completion behavior. See      [Section 5.1.5, “Server System Variables”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#server-system-variables).    

​      The `AND CHAIN` clause causes a new transaction      to begin as soon as the current one ends, and the new transaction      has the same isolation level as the just-terminated transaction.      The new transaction also uses the same access mode (`READ      WRITE` or `READ ONLY`) as the      just-terminated transaction. The `RELEASE` clause      causes the server to disconnect the current client session after      terminating the current transaction. Including the      `NO` keyword suppresses `CHAIN`      or `RELEASE` completion, which can be useful if      the [`completion_type`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_completion_type) system      variable is set to cause chaining or release completion by      default.    

​      Beginning a transaction causes any pending transaction to be      committed. See [Section 13.3.3, “Statements That Cause an Implicit Commit”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#implicit-commit), for more      information.    

​      Beginning a transaction also causes table locks acquired with      [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) to be released, as      though you had executed      [`UNLOCK      TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables). Beginning a transaction does not release a      global read lock acquired with [`FLUSH TABLES      WITH READ LOCK`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#flush-tables-with-read-lock).    

​      For best results, transactions should be performed using only      tables managed by a single transaction-safe storage engine.      Otherwise, the following problems can occur:

- ​          If you use tables from more than one transaction-safe storage          engine (such as `InnoDB`), and the          transaction isolation level is not          [`SERIALIZABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#isolevel_serializable), it is          possible that when one transaction commits, another ongoing          transaction that uses the same tables will see only some of          the changes made by the first transaction. That is, the          atomicity of transactions is not guaranteed with mixed engines          and inconsistencies can result. (If mixed-engine transactions          are infrequent, you can use          [`SET          TRANSACTION ISOLATION LEVEL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#set-transaction) to set the isolation          level to [`SERIALIZABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#isolevel_serializable) on a          per-transaction basis as necessary.)        
- ​          If you use tables that are not transaction-safe within a          transaction, changes to those tables are stored at once,          regardless of the status of autocommit mode.        
- ​          If you issue a          [`ROLLBACK`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit)          statement after updating a nontransactional table within a          transaction, an          [`ER_WARNING_NOT_COMPLETE_ROLLBACK`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/error-handling.html#error_er_warning_not_complete_rollback)          warning occurs. Changes to transaction-safe tables are rolled          back, but not changes to nontransaction-safe tables.

​      Each transaction is stored in the binary log in one chunk, upon      [`COMMIT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit). Transactions that are      rolled back are not logged.      (**Exception**: Modifications to      nontransactional tables cannot be rolled back. If a transaction      that is rolled back includes modifications to nontransactional      tables, the entire transaction is logged with a      [`ROLLBACK`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit)      statement at the end to ensure that modifications to the      nontransactional tables are replicated.) See      [Section 5.4.4, “The Binary Log”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#binary-log).    

​      You can change the isolation level for transactions with the      [`SET TRANSACTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#set-transaction) statement. See      [Section 13.3.6, “SET TRANSACTION Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#set-transaction).    

​      Rolling back can be a slow operation that may occur implicitly      without the user having explicitly asked for it (for example, when      an error occurs). Because of this, [`SHOW      PROCESSLIST`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#show-processlist) displays `Rolling back` in      the `State` column for the session, not only for      explicit rollbacks performed with the      [`ROLLBACK`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit)      statement but also for implicit rollbacks.

Note

​        In MySQL 5.5, `BEGIN`,        `COMMIT`, and `ROLLBACK` are        not affected by [`--replicate-do-db`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/replication.html#option_mysqld_replicate-do-db)        or [`--replicate-ignore-db`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/replication.html#option_mysqld_replicate-ignore-db) rules.

### 13.3.2 Statements That Cannot Be Rolled Back

​      Some statements cannot be rolled back. In general, these include      data definition language (DDL) statements, such as those that      create or drop databases, those that create, drop, or alter tables      or stored routines.    

​      You should design your transactions not to include such      statements. If you issue a statement early in a transaction that      cannot be rolled back, and then another statement later fails, the      full effect of the transaction cannot be rolled back in such cases      by issuing a      [`ROLLBACK`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit)      statement.

### 13.3.3 Statements That Cause an Implicit Commit

​      The statements listed in this section (and any synonyms for them)      implicitly end any transaction active in the current session, as      if you had done a [`COMMIT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit) before      executing the statement. As of MySQL 5.5.3, most of these      statements also cause an implicit commit after executing; for      additional details, see the end of this section.

- ​          **Data definition language (DDL)          statements that define or modify database objects.**          `ALTER DATABASE ... UPGRADE DATA DIRECTORY          NAME`, [`ALTER EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-event),          [`ALTER PROCEDURE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-procedure),          [`ALTER SERVER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-server),          [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table),          [`ALTER VIEW`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-view),          [`CREATE DATABASE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-database),          [`CREATE EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-event),          [`CREATE INDEX`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-index),          [`CREATE PROCEDURE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-procedure),          [`CREATE SERVER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-server),          [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table),          [`CREATE TRIGGER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-trigger),          [`CREATE VIEW`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-view),          [`DROP DATABASE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-database),          [`DROP EVENT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-event),          [`DROP INDEX`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-index),          [`DROP PROCEDURE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-procedure),          [`DROP SERVER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-server),          [`DROP TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-table),          [`DROP TRIGGER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-trigger),          [`DROP VIEW`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-view),          [`RENAME TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#rename-table),          [`TRUNCATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#truncate-table).        

  ​          [`ALTER FUNCTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-function),          [`CREATE FUNCTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-function) and          [`DROP FUNCTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-function) also cause an          implicit commit when used with stored functions, but not with          user-defined functions. ([`ALTER          FUNCTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-function) can only be used with stored functions.)        

  ​          [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) and          [`DROP TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-table) statements do not          commit a transaction if the `TEMPORARY`          keyword is used. (This does not apply to other operations on          temporary tables such as [`ALTER          TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) and [`CREATE          INDEX`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-index), which do cause a commit.) However, although          no implicit commit occurs, neither can the statement be rolled          back, which means that the use of such statements causes          transactional atomicity to be violated. For example, if you          use [`CREATE          TEMPORARY TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) and then roll back the transaction,          the table remains in existence.        

  ​          The [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) statement in          `InnoDB` is processed as a single          transaction. This means that a          [`ROLLBACK`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit)          from the user does not undo [`CREATE          TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) statements the user made during that          transaction.        

  ​          [`CREATE TABLE ...          SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) causes an implicit commit before and after          the statement is executed when you are creating nontemporary          tables. (No commit occurs for `CREATE TEMPORARY TABLE          ... SELECT`.)        

- ​          **Statements that implicitly use or modify          tables in the mysql database.**          [`CREATE USER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-user),          [`DROP USER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-user),          [`GRANT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#grant),          [`RENAME USER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#rename-user),          [`REVOKE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#revoke),          [`SET PASSWORD`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#set-password).        

- ​          **Transaction-control and locking          statements.**          [`BEGIN`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit),          [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables), `SET          autocommit = 1` (if the value is not already 1),          [`START          TRANSACTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit),          [`UNLOCK          TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables).        

  ​          [`UNLOCK          TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) commits a transaction only if any tables          currently have been locked with [`LOCK          TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) to acquire nontransactional table locks. A          commit does not occur for          [`UNLOCK          TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) following [`FLUSH TABLES          WITH READ LOCK`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#flush-tables-with-read-lock) because the latter statement does not          acquire table-level locks.        

  ​          Transactions cannot be nested. This is a consequence of the          implicit commit performed for any current transaction when you          issue a [`START          TRANSACTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit) statement or one of its synonyms.        

  ​          Statements that cause an implicit commit cannot be used in an          XA transaction while the transaction is in an          `ACTIVE` state.        

  ​          The [`BEGIN`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit)          statement differs from the use of the `BEGIN`          keyword that starts a          [`BEGIN ...          END`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#begin-end) compound statement. The latter does not cause an          implicit commit. See [Section 13.6.1, “BEGIN ... END Compound-Statement Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#begin-end).        

- ​          **Data loading statements.**          [`LOAD DATA          INFILE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#load-data).          [`LOAD DATA          INFILE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#load-data) causes an implicit commit only for tables          using the [`NDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/mysql-cluster.html) storage engine. For          more information, see Bug #11151.        

- ​          **Administrative statements.**          [`ANALYZE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#analyze-table),          [`CACHE INDEX`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#cache-index),          [`CHECK TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#check-table),          [`LOAD INDEX INTO          CACHE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#load-index), [`OPTIMIZE          TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#optimize-table), [`REPAIR TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#repair-table).

​      As of MySQL 5.5.3, most statements that previously caused an      implicit commit before executing also do so after executing. The      intent is to handle each such statement in its own special      transaction because it cannot be rolled back anyway. The following      list provides additional details pertaining to this change:

- ​          The [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) variants          ([`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table) for          `InnoDB` tables and          [`CREATE TABLE ...          SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table)) that previously were special cases no longer          are so because [`CREATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table)          uniformly causes an implicit commit before and after          executing.        
- ​          The [`FLUSH`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#flush) and          [`RESET`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#reset) statements cause an          implicit commit.        
- ​          Transaction-control and locking statements behave as before.          If an implicit commit occurs before execution, another does          not occur after.

### 13.3.4 SAVEPOINT, ROLLBACK TO SAVEPOINT, and RELEASE SAVEPOINT Syntax

```
SAVEPOINT identifier
ROLLBACK [WORK] TO [SAVEPOINT] identifier
RELEASE SAVEPOINT identifier

```

​      `InnoDB` supports the SQL statements      [`SAVEPOINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#savepoint),      [`ROLLBACK TO      SAVEPOINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#savepoint),      [`RELEASE      SAVEPOINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#savepoint) and the optional `WORK`      keyword for      [`ROLLBACK`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit).    

​      The [`SAVEPOINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#savepoint) statement sets a      named transaction savepoint with a name of      *identifier*. If the current transaction      has a savepoint with the same name, the old savepoint is deleted      and a new one is set.    

​      The [`ROLLBACK TO      SAVEPOINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#savepoint) statement rolls back a transaction to the      named savepoint without terminating the transaction. Modifications      that the current transaction made to rows after the savepoint was      set are undone in the rollback, but `InnoDB` does      *not* release the row locks that were stored in      memory after the savepoint. (For a new inserted row, the lock      information is carried by the transaction ID stored in the row;      the lock is not separately stored in memory. In this case, the row      lock is released in the undo.) Savepoints that were set at a later      time than the named savepoint are deleted.    

​      If the [`ROLLBACK TO      SAVEPOINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#savepoint) statement returns the following error, it      means that no savepoint with the specified name exists:    

```
ERROR 1305 (42000): SAVEPOINT identifier does not exist

```

​      The [`RELEASE      SAVEPOINT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#savepoint) statement removes the named savepoint from the      set of savepoints of the current transaction. No commit or      rollback occurs. It is an error if the savepoint does not exist.    

​      All savepoints of the current transaction are deleted if you      execute a [`COMMIT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit), or a      [`ROLLBACK`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit) that      does not name a savepoint.    

​      A new savepoint level is created when a stored function is invoked      or a trigger is activated. The savepoints on previous levels      become unavailable and thus do not conflict with savepoints on the      new level. When the function or trigger terminates, any savepoints      it created are released and the previous savepoint level is      restored.

### 13.3.5 LOCK TABLES and UNLOCK TABLES Syntax

- [13.3.5.1 Interaction of Table Locking and Transactions](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables-and-transactions)
- [13.3.5.2 LOCK TABLES and Triggers](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables-and-triggers)
- [13.3.5.3 Table-Locking Restrictions and Conditions](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables-restrictions)

```
LOCK TABLES
    tbl_name [[AS] alias] lock_type
    [, tbl_name [[AS] alias] lock_type] ...

lock_type:
    READ [LOCAL]
  | [LOW_PRIORITY] WRITE

UNLOCK TABLES

```

​      MySQL enables client sessions to acquire table locks explicitly      for the purpose of cooperating with other sessions for access to      tables, or to prevent other sessions from modifying tables during      periods when a session requires exclusive access to them. A      session can acquire or release locks only for itself. One session      cannot acquire locks for another session or release locks held by      another session.    

​      Locks may be used to emulate transactions or to get more speed      when updating tables. This is explained in more detail later in      this section.    

​      [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) explicitly acquires      table locks for the current client session. Table locks can be      acquired for base tables or views. You must have the      [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_lock-tables) privilege, and the      [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_select) privilege for each object to      be locked.    

​      For view locking, [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) adds      all base tables used in the view to the set of tables to be locked      and locks them automatically. If you lock a table explicitly with      [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables), any tables used in      triggers are also locked implicitly, as described in      [Section 13.3.5.2, “LOCK TABLES and Triggers”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables-and-triggers).    

​      [`UNLOCK      TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) explicitly releases any table locks held by the      current session. [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables)      implicitly releases any table locks held by the current session      before acquiring new locks.    

​      Another use for      [`UNLOCK      TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) is to release the global read lock acquired with      the [`FLUSH TABLES WITH READ LOCK`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#flush-tables-with-read-lock)      statement, which enables you to lock all tables in all databases.      See [Section 13.7.6.3, “FLUSH Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#flush). (This is a very convenient way to get      backups if you have a file system such as Veritas that can take      snapshots in time.)    

​      A table lock only protects against inappropriate reads or writes      by other sessions. A session holding a `WRITE`      lock can perform table-level operations such as      [`DROP TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-table) or      [`TRUNCATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#truncate-table). For sessions      holding a `READ` lock, [`DROP      TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-table) and [`TRUNCATE TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#truncate-table)      operations are not permitted.    

​      The following discussion applies only to      non-`TEMPORARY` tables. [`LOCK      TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) is permitted (but ignored) for a      `TEMPORARY` table. The table can be accessed      freely by the session within which it was created, regardless of      what other locking may be in effect. No lock is necessary because      no other session can see the table.    

​      For information about other conditions on the use of      [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) and statements that      cannot be used while [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) is      in effect, see [Section 13.3.5.3, “Table-Locking Restrictions and Conditions”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables-restrictions)    

​      **Rules for Lock Acquisition**    

​      To acquire table locks within the current session, use the      [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) statement. The      following lock types are available:    

​      `READ [LOCAL]` lock:

- ​          The session that holds the lock can read the table (but not          write it).        
- ​          Multiple sessions can acquire a `READ` lock          for the table at the same time.        
- ​          Other sessions can read the table without explicitly acquiring          a `READ` lock.        
- ​          The `LOCAL` modifier enables nonconflicting          [`INSERT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert) statements (concurrent          inserts) by other sessions to execute while the lock is held.          (See [Section 8.11.3, “Concurrent Inserts”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/optimization.html#concurrent-inserts).) However,          `READ LOCAL` cannot be used if you are going          to manipulate the database using processes external to the          server while you hold the lock. For `InnoDB`          tables, `READ LOCAL` is the same as          `READ`.

​      `[LOW_PRIORITY] WRITE` lock:

- ​          The session that holds the lock can read and write the table.        
- ​          Only the session that holds the lock can access the table. No          other session can access it until the lock is released.        
- ​          Lock requests for the table by other sessions block while the          `WRITE` lock is held.        
- ​          The `LOW_PRIORITY` modifier has no effect as          of MySQL 5.5.3. Before 5.5.3, it affects lock scheduling if          the `WRITE` lock request must wait, as          described later.

​      If the [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) statement must      wait due to locks held by other sessions on any of the tables, it      blocks until all locks can be acquired.    

​      A session that requires locks must acquire all the locks that it      needs in a single [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables)      statement. While the locks thus obtained are held, the session can      access only the locked tables. For example, in the following      sequence of statements, an error occurs for the attempt to access      `t2` because it was not locked in the      [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) statement:    

```
mysql> LOCK TABLES t1 READ;
mysql> SELECT COUNT(*) FROM t1;
+----------+
| COUNT(*) |
+----------+
|        3 |
+----------+
mysql> SELECT COUNT(*) FROM t2;
ERROR 1100 (HY000): Table 't2' was not locked with LOCK TABLES

```

​      Tables in the `INFORMATION_SCHEMA` database are      an exception. They can be accessed without being locked explicitly      even while a session holds table locks obtained with      [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables).    

​      You cannot refer to a locked table multiple times in a single      query using the same name. Use aliases instead, and obtain a      separate lock for the table and each alias:    

```
mysql> LOCK TABLE t WRITE, t AS t1 READ;
mysql> INSERT INTO t SELECT * FROM t;
ERROR 1100: Table 't' was not locked with LOCK TABLES
mysql> INSERT INTO t SELECT * FROM t AS t1;

```

​      The error occurs for the first      [`INSERT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert) because there are two      references to the same name for a locked table. The second      [`INSERT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert) succeeds because the      references to the table use different names.    

​      If your statements refer to a table by means of an alias, you must      lock the table using that same alias. It does not work to lock the      table without specifying the alias:    

```
mysql> LOCK TABLE t READ;
mysql> SELECT * FROM t AS myalias;
ERROR 1100: Table 'myalias' was not locked with LOCK TABLES

```

​      Conversely, if you lock a table using an alias, you must refer to      it in your statements using that alias:    

```
mysql> LOCK TABLE t AS myalias READ;
mysql> SELECT * FROM t;
ERROR 1100: Table 't' was not locked with LOCK TABLES
mysql> SELECT * FROM t AS myalias;

```

​      `WRITE` locks normally have higher priority than      `READ` locks to ensure that updates are processed      as soon as possible. This means that if one session obtains a      `READ` lock and then another session requests a      `WRITE` lock, subsequent `READ`      lock requests wait until the session that requested the      `WRITE` lock has obtained the lock and released      it. Before MySQL 5.5.3, the `LOW_PRIORITY`      modifier can be given to affect locking behavior as follows (as of      5.5.3, it has no effect): A request for a `LOW_PRIORITY      WRITE` lock permits subsequent `READ`      lock requests by other sessions to be satisfied first if they      occur while the `LOW_PRIORITY WRITE` request is      waiting. You should use `LOW_PRIORITY WRITE`      locks only if you are sure that eventually there will be a time      when no sessions have a `READ` lock. For      `InnoDB` tables in transactional mode (autocommit      = 0), a waiting `LOW_PRIORITY WRITE` lock acts      like a regular `WRITE` lock and causes subsequent      `READ` lock requests to wait.    

​      [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) acquires locks as      follows:

1. ​          Sort all tables to be locked in an internally defined order.          From the user standpoint, this order is undefined.        
2. ​          If a table is to be locked with a read and a write lock, put          the write lock request before the read lock request.        
3. ​          Lock one table at a time until the session gets all locks.

​      This policy ensures that table locking is deadlock free. There      are, however, other things you need to be aware of about this      policy: If you are using a `LOW_PRIORITY WRITE`      lock for a table, it means only that MySQL waits for this      particular lock until there are no other sessions that want a      `READ` lock. When the session has gotten the      `WRITE` lock and is waiting to get the lock for      the next table in the lock table list, all other sessions wait for      the `WRITE` lock to be released. If this becomes      a serious problem with your application, you should consider      converting some of your tables to transaction-safe tables.

Note

​        `LOCK TABLES` or `UNLOCK        TABLES`, when applied to a partitioned table, always        locks or unlocks the entire table. See        [Section 19.5.4, “Partitioning and Table-Level Locking”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/partitioning.html#partitioning-limitations-locking).

​      **Rules for Lock Release**    

​      When the table locks held by a session are released, they are all      released at the same time. A session can release its locks      explicitly, or locks may be released implicitly under certain      conditions.

- ​          A session can release its locks explicitly with          [`UNLOCK          TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables).        
- ​          If a session issues a [`LOCK          TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) statement to acquire a lock while already          holding locks, its existing locks are released implicitly          before the new locks are granted.        
- ​          If a session begins a transaction (for example, with          [`START          TRANSACTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit)), an implicit          [`UNLOCK          TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) is performed, which causes existing locks to          be released. (For additional information about the interaction          between table locking and transactions, see          [Section 13.3.5.1, “Interaction of Table Locking and Transactions”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables-and-transactions).)

​      If the connection for a client session terminates, whether      normally or abnormally, the server implicitly releases all table      locks held by the session (transactional and nontransactional). If      the client reconnects, the locks will no longer be in effect. In      addition, if the client had an active transaction, the server      rolls back the transaction upon disconnect, and if reconnect      occurs, the new session begins with autocommit enabled. For this      reason, clients may wish to disable auto-reconnect. With      auto-reconnect in effect, the client is not notified if reconnect      occurs but any table locks or current transaction will have been      lost. With auto-reconnect disabled, if the connection drops, an      error occurs for the next statement issued. The client can detect      the error and take appropriate action such as reacquiring the      locks or redoing the transaction. See      [Section 23.8.20, “C API Automatic Reconnection Control”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/connectors-apis.html#c-api-auto-reconnect).

Note

​        If you use [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table) on a        locked table, it may become unlocked. For example, if you        attempt a second [`ALTER TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#alter-table)        operation, the result may be an error `Table        '*tbl_name*' was not locked with LOCK        TABLES`. To handle this, lock the table again prior to        the second alteration. See also        [Section B.5.6.1, “Problems with ALTER TABLE”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/error-handling.html#alter-table-problems).

#### 13.3.5.1 Interaction of Table Locking and Transactions

​        [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) and        [`UNLOCK        TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) interact with the use of transactions as        follows:

- ​            [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) is not            transaction-safe and implicitly commits any active            transaction before attempting to lock the tables.          

- ​            [`UNLOCK            TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) implicitly commits any active transaction,            but only if [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) has            been used to acquire table locks. For example, in the            following set of statements,            [`UNLOCK            TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) releases the global read lock but does not            commit the transaction because no table locks are in effect:          

  ```
  FLUSH TABLES WITH READ LOCK;
  START TRANSACTION;
  SELECT ... ;
  UNLOCK TABLES;

  ```

- ​            Beginning a transaction (for example, with            [`START            TRANSACTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit)) implicitly commits any current            transaction and releases existing table locks.          

- ​            [`FLUSH TABLES WITH READ LOCK`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#flush-tables-with-read-lock)            acquires a global read lock and not table locks, so it is            not subject to the same behavior as            [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) and            [`UNLOCK            TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) with respect to table locking and implicit            commits. For example,            [`START            TRANSACTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit) does not release the global read lock.            See [Section 13.7.6.3, “FLUSH Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#flush).          

- ​            Other statements that implicitly cause transactions to be            committed do not release existing table locks. For a list of            such statements, see [Section 13.3.3, “Statements That Cause an Implicit Commit”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#implicit-commit).          

- ​            The correct way to use [`LOCK            TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) and            [`UNLOCK            TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) with transactional tables, such as            `InnoDB` tables, is to begin a transaction            with `SET autocommit = 0` (not            [`START            TRANSACTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit)) followed by [`LOCK            TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables), and to not call            [`UNLOCK            TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) until you commit the transaction            explicitly. For example, if you need to write to table            `t1` and read from table            `t2`, you can do this:          

  ```
  SET autocommit=0;
  LOCK TABLES t1 WRITE, t2 READ, ...;
  ... do something with tables t1 and t2 here ...
  COMMIT;
  UNLOCK TABLES;

  ```

  ​            When you call [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables),            `InnoDB` internally takes its own table            lock, and MySQL takes its own table lock.            `InnoDB` releases its internal table lock            at the next commit, but for MySQL to release its table lock,            you have to call            [`UNLOCK            TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables). You should not have            [`autocommit = 1`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_autocommit), because            then `InnoDB` releases its internal table            lock immediately after the call of [`LOCK            TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables), and deadlocks can very easily happen.            `InnoDB` does not acquire the internal            table lock at all if [`autocommit =            1`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_autocommit), to help old applications avoid unnecessary            deadlocks.          

- ​            [`ROLLBACK`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit)            does not release table locks.

#### 13.3.5.2 LOCK TABLES and Triggers

​        If you lock a table explicitly with [`LOCK        TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables), any tables used in triggers are also locked        implicitly:

- ​            The locks are taken as the same time as those acquired            explicitly with the [`LOCK            TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) statement.          
- ​            The lock on a table used in a trigger depends on whether the            table is used only for reading. If so, a read lock suffices.            Otherwise, a write lock is used.          
- ​            If a table is locked explicitly for reading with            [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables), but needs to be            locked for writing because it might be modified within a            trigger, a write lock is taken rather than a read lock.            (That is, an implicit write lock needed due to the table's            appearance within a trigger causes an explicit read lock            request for the table to be converted to a write lock            request.)

​        Suppose that you lock two tables, `t1` and        `t2`, using this statement:      

```
LOCK TABLES t1 WRITE, t2 READ;

```

​        If `t1` or `t2` have any        triggers, tables used within the triggers will also be locked.        Suppose that `t1` has a trigger defined like        this:      

```
CREATE TRIGGER t1_a_ins AFTER INSERT ON t1 FOR EACH ROW
BEGIN
  UPDATE t4 SET count = count+1
      WHERE id = NEW.id AND EXISTS (SELECT a FROM t3);
  INSERT INTO t2 VALUES(1, 2);
END;

```

​        The result of the [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables)        statement is that `t1` and        `t2` are locked because they appear in the        statement, and `t3` and `t4`        are locked because they are used within the trigger:

- ​            `t1` is locked for writing per the            `WRITE` lock request.          
- ​            `t2` is locked for writing, even though the            request is for a `READ` lock. This occurs            because `t2` is inserted into within the            trigger, so the `READ` request is converted            to a `WRITE` request.          
- ​            `t3` is locked for reading because it is            only read from within the trigger.          
- ​            `t4` is locked for writing because it might            be updated within the trigger.

#### 13.3.5.3 Table-Locking Restrictions and Conditions

​        You can safely use [`KILL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#kill) to        terminate a session that is waiting for a table lock. See        [Section 13.7.6.4, “KILL Syntax”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#kill).      

​        You should *not* lock any tables that you are        using with [`INSERT DELAYED`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert-delayed). An        [`INSERT DELAYED`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#insert-delayed) in this case        results in an error because the insert must be handled by a        separate thread, not by the session which holds the lock.      

​        [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) and        [`UNLOCK        TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) cannot be used within stored programs.      

​        Tables in the `performance_schema` database        cannot be locked with [`LOCK        TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables), except the        `setup_*xxx*` tables.      

​        The following statements are prohibited while a        [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) statement is in        effect:

- ​            As of MySQL 5.5.3, [`CREATE            TABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table),            [`CREATE TABLE            ... LIKE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-table), [`CREATE            VIEW`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#create-view), [`DROP VIEW`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#drop-view),            and DDL statements on stored procedures and functions.          
- ​            As of MySQL 5.5.8, DDL statements on events

​        For some operations, system tables in the        `mysql` database must be accessed. For example,        the [`HELP`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#help) statement requires the        contents of the server-side help tables, and        [`CONVERT_TZ()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_convert-tz) might need to read        the time zone tables. The server implicitly locks the system        tables for reading as necessary so that you need not lock them        explicitly. These tables are treated as just described:      

```
mysql.help_category
mysql.help_keyword
mysql.help_relation
mysql.help_topic
mysql.proc
mysql.time_zone
mysql.time_zone_leap_second
mysql.time_zone_name
mysql.time_zone_transition
mysql.time_zone_transition_type

```

​        If you want to explicitly place a `WRITE` lock        on any of those tables with a [`LOCK        TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) statement, the table must be the only one        locked; no other table can be locked with the same statement.      

​        Normally, you do not need to lock tables, because all single        [`UPDATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#update) statements are atomic; no        other session can interfere with any other currently executing        SQL statement. However, there are a few cases when locking        tables may provide an advantage:

- ​            If you are going to run many operations on a set of            `MyISAM` tables, it is much faster to lock            the tables you are going to use. Locking            `MyISAM` tables speeds up inserting,            updating, or deleting on them because MySQL does not flush            the key cache for the locked tables until            [`UNLOCK            TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) is called. Normally, the key cache is            flushed after each SQL statement.          

  ​            The downside to locking the tables is that no session can            update a `READ`-locked table (including the            one holding the lock) and no session can access a            `WRITE`-locked table other than the one            holding the lock.          

- ​            If you are using tables for a nontransactional storage            engine, you must use [`LOCK            TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) if you want to ensure that no other session            modifies the tables between a            [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) and an            [`UPDATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#update). The example shown            here requires [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables) to            execute safely:          

  ```
  LOCK TABLES trans READ, customer WRITE;
  SELECT SUM(value) FROM trans WHERE customer_id=some_id;
  UPDATE customer
    SET total_value=sum_from_previous_statement
    WHERE customer_id=some_id;
  UNLOCK TABLES;

  ```

  ​            Without [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables), it is            possible that another session might insert a new row in the            `trans` table between execution of the            [`SELECT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#select) and            [`UPDATE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#update) statements.

​        You can avoid using [`LOCK TABLES`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#lock-tables)        in many cases by using relative updates (`UPDATE        customer SET        *value*=*value*+*new_value*`)        or the [`LAST_INSERT_ID()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_last-insert-id) function.      

​        You can also avoid locking tables in some cases by using the        user-level advisory lock functions        [`GET_LOCK()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_get-lock) and        [`RELEASE_LOCK()`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#function_release-lock). These locks are        saved in a hash table in the server and implemented with        `pthread_mutex_lock()` and        `pthread_mutex_unlock()` for high speed. See        [Section 12.17, “Miscellaneous Functions”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/functions.html#miscellaneous-functions).      

​        See [Section 8.11.1, “Internal Locking Methods”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/optimization.html#internal-locking), for more information on        locking policy.

### 13.3.6 SET TRANSACTION Syntax

```
SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL
  {
       REPEATABLE READ
     | READ COMMITTED
     | READ UNCOMMITTED
     | SERIALIZABLE
   }

```

​      This statement sets the transaction isolation level, used for      operations on [`InnoDB`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html) tables.

#### Scope of the Isolation Level

​      You can set the isolation level globally, for the current session,      or for the next transaction:

- ​          With the `GLOBAL` keyword, the statement sets          the default transaction level globally for all subsequent          sessions. Existing sessions are unaffected.        
- ​          With the `SESSION` keyword, the statement          sets the default transaction level for all subsequent          transactions performed within the current session.        
- ​          Without any `SESSION` or          `GLOBAL` keyword, the statement sets the          isolation level for the next (not started) transaction          performed within the current session. Subsequent transactions          revert to using the `SESSION` isolation          level.

​      A change to the global default isolation level requires the      [`SUPER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/security.html#priv_super) privilege. Any session is      free to change its session isolation level (even in the middle of      a transaction), or the isolation level for its next transaction.    

​      [`SET TRANSACTION      ISOLATION LEVEL`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#set-transaction) without `GLOBAL` or      `SESSION` is not permitted while there is an      active transaction:    

```
mysql> START TRANSACTION;
Query OK, 0 rows affected (0.02 sec)

mysql> SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
ERROR 1568 (25001): Transaction isolation level can't be changed
while a transaction is in progress

```

​      To set the global default isolation level at server startup, use      the      [`--transaction-isolation=*level*`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#option_mysqld_transaction-isolation)      option to [**mysqld**](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/programs.html#mysqld) on the command line or in an      option file. Values of *level* for this      option use dashes rather than spaces, so the permissible values      are [`READ-UNCOMMITTED`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#isolevel_read-uncommitted),      [`READ-COMMITTED`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#isolevel_read-committed),      [`REPEATABLE-READ`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#isolevel_repeatable-read), or      [`SERIALIZABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#isolevel_serializable). For example, to      set the default isolation level to      [`REPEATABLE READ`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#isolevel_repeatable-read), use these      lines in the `[mysqld]` section of an option      file:    

```
[mysqld]
transaction-isolation = REPEATABLE-READ

```

​      It is possible to check or set the global and session transaction      isolation levels at runtime by using the      [`tx_isolation`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/server-administration.html#sysvar_tx_isolation) system variable:    

```
SELECT @@GLOBAL.tx_isolation, @@tx_isolation;
SET GLOBAL tx_isolation='REPEATABLE-READ';
SET SESSION tx_isolation='SERIALIZABLE';

```

#### Transaction Isolation Levels

​      For information about transaction isolation levels, see      [Section 14.8.2.1, “Transaction Isolation Levels”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#innodb-transaction-isolation-levels).

### 13.3.7 XA Transactions

- [13.3.7.1 XA Transaction SQL Syntax](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#xa-statements)
- [13.3.7.2 XA Transaction States](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#xa-states)

​      Support for XA transactions is available for the      `InnoDB` storage engine. The MySQL XA      implementation is based on the X/Open CAE document      *Distributed Transaction Processing: The XA      Specification*. This document is published by The Open      Group and available at      <http://www.opengroup.org/public/pubs/catalog/c193.htm>.      Limitations of the current XA implementation are described in      [Section C.6, “Restrictions on XA Transactions”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/restrictions.html#xa-restrictions).    

​      On the client side, there are no special requirements. The XA      interface to a MySQL server consists of SQL statements that begin      with the `XA` keyword. MySQL client programs must      be able to send SQL statements and to understand the semantics of      the XA statement interface. They do not need be linked against a      recent client library. Older client libraries also will work.    

​      Among the MySQL Connectors, MySQL Connector/J 5.0.0 supports XA      directly (by means of a class interface that handles the XA SQL      statement interface for you).    

​      XA supports distributed transactions, that is, the ability to      permit multiple separate transactional resources to participate in      a global transaction. Transactional resources often are RDBMSs but      may be other kinds of resources.    

​      A global transaction involves several actions that are      transactional in themselves, but that all must either complete      successfully as a group, or all be rolled back as a group. In      essence, this extends ACID properties “up a level” so      that multiple ACID transactions can be executed in concert as      components of a global operation that also has ACID properties.      (As with nondistributed transactions,      [`SERIALIZABLE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#isolevel_serializable) may be preferred      if your applications are sensitive to read phenomena.      [`REPEATABLE READ`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/innodb-storage-engine.html#isolevel_repeatable-read) may not be      sufficient for distributed transactions.)    

​      Some examples of distributed transactions:

- ​          An application may act as an integration tool that combines a          messaging service with an RDBMS. The application makes sure          that transactions dealing with message sending, retrieval, and          processing that also involve a transactional database all          happen in a global transaction. You can think of this as          “transactional email.”        
- ​          An application performs actions that involve different          database servers, such as a MySQL server and an Oracle server          (or multiple MySQL servers), where actions that involve          multiple servers must happen as part of a global transaction,          rather than as separate transactions local to each server.        
- ​          A bank keeps account information in an RDBMS and distributes          and receives money through automated teller machines (ATMs).          It is necessary to ensure that ATM actions are correctly          reflected in the accounts, but this cannot be done with the          RDBMS alone. A global transaction manager integrates the ATM          and database resources to ensure overall consistency of          financial transactions.

​      Applications that use global transactions involve one or more      Resource Managers and a Transaction Manager:

- ​          A Resource Manager (RM) provides access to transactional          resources. A database server is one kind of resource manager.          It must be possible to either commit or roll back transactions          managed by the RM.        
- ​          A Transaction Manager (TM) coordinates the transactions that          are part of a global transaction. It communicates with the RMs          that handle each of these transactions. The individual          transactions within a global transaction are          “branches” of the global transaction. Global          transactions and their branches are identified by a naming          scheme described later.

​      The MySQL implementation of XA enables a MySQL server to act as a      Resource Manager that handles XA transactions within a global      transaction. A client program that connects to the MySQL server      acts as the Transaction Manager.    

​      To carry out a global transaction, it is necessary to know which      components are involved, and bring each component to a point when      it can be committed or rolled back. Depending on what each      component reports about its ability to succeed, they must all      commit or roll back as an atomic group. That is, either all      components must commit, or all components must roll back. To      manage a global transaction, it is necessary to take into account      that any component or the connecting network might fail.    

​      The process for executing a global transaction uses two-phase      commit (2PC). This takes place after the actions performed by the      branches of the global transaction have been executed.

1. ​          In the first phase, all branches are prepared. That is, they          are told by the TM to get ready to commit. Typically, this          means each RM that manages a branch records the actions for          the branch in stable storage. The branches indicate whether          they are able to do this, and these results are used for the          second phase.        
2. ​          In the second phase, the TM tells the RMs whether to commit or          roll back. If all branches indicated when they were prepared          that they will be able to commit, all branches are told to          commit. If any branch indicated when it was prepared that it          will not be able to commit, all branches are told to roll          back.

​      In some cases, a global transaction might use one-phase commit      (1PC). For example, when a Transaction Manager finds that a global      transaction consists of only one transactional resource (that is,      a single branch), that resource can be told to prepare and commit      at the same time.

#### 13.3.7.1 XA Transaction SQL Syntax

​        To perform XA transactions in MySQL, use the following        statements:      

```
XA {START|BEGIN} xid [JOIN|RESUME]

XA END xid [SUSPEND [FOR MIGRATE]]

XA PREPARE xid

XA COMMIT xid [ONE PHASE]

XA ROLLBACK xid

XA RECOVER

```

​        For [`XA        START`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#xa-statements), the `JOIN` and        `RESUME` clauses are not supported.      

​        For [`XA        END`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#xa-statements) the `SUSPEND [FOR MIGRATE]`        clause is not supported.      

​        Each XA statement begins with the `XA` keyword,        and most of them require an *xid*        value. An *xid* is an XA transaction        identifier. It indicates which transaction the statement applies        to. *xid* values are supplied by the        client, or generated by the MySQL server. An        *xid* value has from one to three        parts:      

```
xid: gtrid [, bqual [, formatID ]]

```

​        *gtrid* is a global transaction        identifier, *bqual* is a branch        qualifier, and *formatID* is a number        that identifies the format used by the        *gtrid* and        *bqual* values. As indicated by the        syntax, *bqual* and        *formatID* are optional. The default        *bqual* value is `''`        if not given. The default *formatID*        value is 1 if not given.      

​        *gtrid* and        *bqual* must be string literals, each        up to 64 bytes (not characters) long.        *gtrid* and        *bqual* can be specified in several        ways. You can use a quoted string (`'ab'`), hex        string (`X'6162'`, `0x6162`),        or bit value        (`b'*nnnn*'`).      

​        *formatID* is an unsigned integer.      

​        The *gtrid* and        *bqual* values are interpreted in bytes        by the MySQL server's underlying XA support routines. However,        while an SQL statement containing an XA statement is being        parsed, the server works with some specific character set. To be        safe, write *gtrid* and        *bqual* as hex strings.      

​        *xid* values typically are generated by        the Transaction Manager. Values generated by one TM must be        different from values generated by other TMs. A given TM must be        able to recognize its own *xid* values        in a list of values returned by the        [`XA        RECOVER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#xa-statements) statement.      

​        For [`XA START        *xid*`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#xa-statements) starts an XA        transaction with the given *xid* value.        Each XA transaction must have a unique        *xid* value, so the value must not        currently be used by another XA transaction. Uniqueness is        assessed using the *gtrid* and        *bqual* values. All following XA        statements for the XA transaction must be specified using the        same *xid* value as that given in the        [`XA        START`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#xa-statements) statement. If you use any of those statements        but specify an *xid* value that does        not correspond to some existing XA transaction, an error occurs.      

​        One or more XA transactions can be part of the same global        transaction. All XA transactions within a given global        transaction must use the same *gtrid*        value in the *xid* value. For this        reason, *gtrid* values must be globally        unique so that there is no ambiguity about which global        transaction a given XA transaction is part of. The        *bqual* part of the        *xid* value must be different for each        XA transaction within a global transaction. (The requirement        that *bqual* values be different is a        limitation of the current MySQL XA implementation. It is not        part of the XA specification.)      

​        The [`XA        RECOVER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#xa-statements) statement returns information for those XA        transactions on the MySQL server that are in the        `PREPARED` state. (See        [Section 13.3.7.2, “XA Transaction States”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#xa-states).) The output includes a row for each        such XA transaction on the server, regardless of which client        started it.      

​        [`XA        RECOVER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#xa-statements) output rows look like this (for an example        *xid* value consisting of the parts        `'abc'`, `'def'`, and        `7`):      

```
mysql> XA RECOVER;
+----------+--------------+--------------+--------+
| formatID | gtrid_length | bqual_length | data   |
+----------+--------------+--------------+--------+
|        7 |            3 |            3 | abcdef |
+----------+--------------+--------------+--------+

```

​        The output columns have the following meanings:

- ​            `formatID` is the            *formatID* part of the transaction            *xid*          
- ​            `gtrid_length` is the length in bytes of            the *gtrid* part of the            *xid*          
- ​            `bqual_length` is the length in bytes of            the *bqual* part of the            *xid*          
- ​            `data` is the concatenation of the            *gtrid* and            *bqual* parts of the            *xid*

#### 13.3.7.2 XA Transaction States

​        An XA transaction progresses through the following states:

1. ​            Use [`XA            START`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#xa-statements) to start an XA transaction and put it in the            `ACTIVE` state.          
2. ​            For an `ACTIVE` XA transaction, issue the            SQL statements that make up the transaction, and then issue            an [`XA            END`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#xa-statements) statement.            [`XA            END`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#xa-statements) puts the transaction in the            `IDLE` state.          
3. ​            For an `IDLE` XA transaction, you can issue            either an [`XA            PREPARE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#xa-statements) statement or an `XA COMMIT ... ONE            PHASE` statement:
   - ​                [`XA                PREPARE`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#xa-statements) puts the transaction in the                `PREPARED` state. An                [`XA                RECOVER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#xa-statements) statement at this point will include                the transaction's *xid* value                in its output, because                [`XA                RECOVER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#xa-statements) lists all XA transactions that are in                the `PREPARED` state.              
   - ​                `XA COMMIT ... ONE PHASE` prepares and                commits the transaction. The                *xid* value will not be listed                by [`XA                RECOVER`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#xa-statements) because the transaction terminates.
4. ​            For a `PREPARED` XA transaction, you can            issue an [`XA            COMMIT`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#xa-statements) statement to commit and terminate the            transaction, or            [`XA            ROLLBACK`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#xa-statements) to roll back and terminate the            transaction.

​        Here is a simple XA transaction that inserts a row into a table        as part of a global transaction:      

```
mysql> XA START 'xatest';
Query OK, 0 rows affected (0.00 sec)

mysql> INSERT INTO mytable (i) VALUES(10);
Query OK, 1 row affected (0.04 sec)

mysql> XA END 'xatest';
Query OK, 0 rows affected (0.00 sec)

mysql> XA PREPARE 'xatest';
Query OK, 0 rows affected (0.00 sec)

mysql> XA COMMIT 'xatest';
Query OK, 0 rows affected (0.00 sec)

```

​        Within the context of a given client connection, XA transactions        and local (non-XA) transactions are mutually exclusive. For        example, if [`XA        START`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#xa-statements) has been issued to begin an XA transaction, a        local transaction cannot be started until the XA transaction has        been committed or rolled back. Conversely, if a local        transaction has been started with        [`START        TRANSACTION`](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#commit), no XA statements can be used until the        transaction has been committed or rolled back.      

​        If an XA transaction is in the `ACTIVE` state,        you cannot issue any statements that cause an implicit commit.        That would violate the XA contract because you could not roll        back the XA transaction. You will receive the following error if        you try to execute such a statement:      

```
ERROR 1399 (XAE07): XAER_RMFAIL: The command cannot be executed
when global transaction is in the ACTIVE state

```

​        Statements to which the preceding remark applies are listed at        [Section 13.3.3, “Statements That Cause an Implicit Commit”](file:///F:/Tech_doc/Mysql/refman-5.5-en.html-chapter/sql-syntax.html#implicit-commit).